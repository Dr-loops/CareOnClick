"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/imap-simple";
exports.ids = ["vendor-chunks/imap-simple"];
exports.modules = {

/***/ "(rsc)/../node_modules/imap-simple/index.js":
/*!********************************************!*\
  !*** ../node_modules/imap-simple/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nmodule.exports = __webpack_require__(/*! ./lib/imapSimple */ \"(rsc)/../node_modules/imap-simple/lib/imapSimple.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2ltYXAtc2ltcGxlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLG1IQUE0QyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxrZnJ5dFxcLmdlbWluaVxcYW50aWdyYXZpdHlcXHNjcmF0Y2hcXGRyX2thbHNfdmlydHVhbF9ob3NwaXRhbFxcbm9kZV9tb2R1bGVzXFxpbWFwLXNpbXBsZVxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2ltYXBTaW1wbGUnKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/imap-simple/index.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/imap-simple/lib/errors.js":
/*!*************************************************!*\
  !*** ../node_modules/imap-simple/lib/errors.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar util = __webpack_require__(/*! util */ \"util\");\n\n/**\n * Error thrown when a connection attempt has timed out\n *\n * @param {number} timeout timeout in milliseconds that the connection waited before timing out\n * @constructor\n */\nfunction ConnectionTimeoutError(timeout) {\n    Error.call(this);\n    Error.captureStackTrace(this, this.constructor);\n    this.message = 'connection timed out';\n\n    if (timeout) {\n        this.message += '. timeout = ' + timeout + ' ms';\n    }\n\n    this.name = 'ConnectionTimeoutError';\n}\n\nutil.inherits(ConnectionTimeoutError, Error);\n\nexports.ConnectionTimeoutError = ConnectionTimeoutError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2ltYXAtc2ltcGxlL2xpYi9lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixXQUFXLG1CQUFPLENBQUMsa0JBQU07O0FBRXpCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsOEJBQThCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGtmcnl0XFwuZ2VtaW5pXFxhbnRpZ3Jhdml0eVxcc2NyYXRjaFxcZHJfa2Fsc192aXJ0dWFsX2hvc3BpdGFsXFxub2RlX21vZHVsZXNcXGltYXAtc2ltcGxlXFxsaWJcXGVycm9ycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuLyoqXG4gKiBFcnJvciB0aHJvd24gd2hlbiBhIGNvbm5lY3Rpb24gYXR0ZW1wdCBoYXMgdGltZWQgb3V0XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXQgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdGhhdCB0aGUgY29ubmVjdGlvbiB3YWl0ZWQgYmVmb3JlIHRpbWluZyBvdXRcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBDb25uZWN0aW9uVGltZW91dEVycm9yKHRpbWVvdXQpIHtcbiAgICBFcnJvci5jYWxsKHRoaXMpO1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgIHRoaXMubWVzc2FnZSA9ICdjb25uZWN0aW9uIHRpbWVkIG91dCc7XG5cbiAgICBpZiAodGltZW91dCkge1xuICAgICAgICB0aGlzLm1lc3NhZ2UgKz0gJy4gdGltZW91dCA9ICcgKyB0aW1lb3V0ICsgJyBtcyc7XG4gICAgfVxuXG4gICAgdGhpcy5uYW1lID0gJ0Nvbm5lY3Rpb25UaW1lb3V0RXJyb3InO1xufVxuXG51dGlsLmluaGVyaXRzKENvbm5lY3Rpb25UaW1lb3V0RXJyb3IsIEVycm9yKTtcblxuZXhwb3J0cy5Db25uZWN0aW9uVGltZW91dEVycm9yID0gQ29ubmVjdGlvblRpbWVvdXRFcnJvcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/imap-simple/lib/errors.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/imap-simple/lib/helpers/getMessage.js":
/*!*************************************************************!*\
  !*** ../node_modules/imap-simple/lib/helpers/getMessage.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar Imap = __webpack_require__(/*! imap */ \"(rsc)/../node_modules/imap/lib/Connection.js\");\n\n/**\n * Given an 'ImapMessage' from the node-imap library,\n * retrieves the message formatted as:\n *\n * {\n *   attributes: object,\n *   parts: [ { which: string, size: number, body: string }, ... ]\n * }\n *\n * @param {object} message an ImapMessage from the node-imap library\n * @returns {Promise} a promise resolving to `message` with schema as described above\n */\nmodule.exports = function getMessage(message) {\n    return new Promise(function (resolve) {\n        var attributes;\n        var messageParts = [];\n        var isHeader = /^HEADER/g;\n\n        function messageOnBody(stream, info) {\n            var body = '';\n\n            function streamOnData(chunk) {\n                body += chunk.toString('utf8');\n            }\n\n            stream.on('data', streamOnData);\n\n            stream.once('end', function streamOnEnd() {\n                stream.removeListener('data', streamOnData);\n\n                var part = {\n                    which: info.which,\n                    size: info.size,\n                    body: body\n                };\n\n                if (isHeader.test(part.which)) {\n                    part.body = Imap.parseHeader(part.body);\n                }\n\n                messageParts.push(part);\n            });\n        }\n\n        function messageOnAttributes(attrs) {\n            attributes = attrs;\n        }\n\n        function messageOnEnd() {\n            message.removeListener('body', messageOnBody);\n            message.removeListener('attributes', messageOnAttributes);\n            resolve({\n                attributes: attributes,\n                parts: messageParts\n            });\n        }\n\n        message.on('body', messageOnBody);\n        message.once('attributes', messageOnAttributes);\n        message.once('end', messageOnEnd);\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2ltYXAtc2ltcGxlL2xpYi9oZWxwZXJzL2dldE1lc3NhZ2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixXQUFXLG1CQUFPLENBQUMsMERBQU07O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyQ0FBMkM7QUFDM0Q7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xca2ZyeXRcXC5nZW1pbmlcXGFudGlncmF2aXR5XFxzY3JhdGNoXFxkcl9rYWxzX3ZpcnR1YWxfaG9zcGl0YWxcXG5vZGVfbW9kdWxlc1xcaW1hcC1zaW1wbGVcXGxpYlxcaGVscGVyc1xcZ2V0TWVzc2FnZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgSW1hcCA9IHJlcXVpcmUoJ2ltYXAnKTtcblxuLyoqXG4gKiBHaXZlbiBhbiAnSW1hcE1lc3NhZ2UnIGZyb20gdGhlIG5vZGUtaW1hcCBsaWJyYXJ5LFxuICogcmV0cmlldmVzIHRoZSBtZXNzYWdlIGZvcm1hdHRlZCBhczpcbiAqXG4gKiB7XG4gKiAgIGF0dHJpYnV0ZXM6IG9iamVjdCxcbiAqICAgcGFydHM6IFsgeyB3aGljaDogc3RyaW5nLCBzaXplOiBudW1iZXIsIGJvZHk6IHN0cmluZyB9LCAuLi4gXVxuICogfVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBtZXNzYWdlIGFuIEltYXBNZXNzYWdlIGZyb20gdGhlIG5vZGUtaW1hcCBsaWJyYXJ5XG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlIHJlc29sdmluZyB0byBgbWVzc2FnZWAgd2l0aCBzY2hlbWEgYXMgZGVzY3JpYmVkIGFib3ZlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0TWVzc2FnZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzO1xuICAgICAgICB2YXIgbWVzc2FnZVBhcnRzID0gW107XG4gICAgICAgIHZhciBpc0hlYWRlciA9IC9eSEVBREVSL2c7XG5cbiAgICAgICAgZnVuY3Rpb24gbWVzc2FnZU9uQm9keShzdHJlYW0sIGluZm8pIHtcbiAgICAgICAgICAgIHZhciBib2R5ID0gJyc7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHN0cmVhbU9uRGF0YShjaHVuaykge1xuICAgICAgICAgICAgICAgIGJvZHkgKz0gY2h1bmsudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RyZWFtLm9uKCdkYXRhJywgc3RyZWFtT25EYXRhKTtcblxuICAgICAgICAgICAgc3RyZWFtLm9uY2UoJ2VuZCcsIGZ1bmN0aW9uIHN0cmVhbU9uRW5kKCkge1xuICAgICAgICAgICAgICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIHN0cmVhbU9uRGF0YSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcGFydCA9IHtcbiAgICAgICAgICAgICAgICAgICAgd2hpY2g6IGluZm8ud2hpY2gsXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IGluZm8uc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogYm9keVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNIZWFkZXIudGVzdChwYXJ0LndoaWNoKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0LmJvZHkgPSBJbWFwLnBhcnNlSGVhZGVyKHBhcnQuYm9keSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWVzc2FnZVBhcnRzLnB1c2gocGFydCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1lc3NhZ2VPbkF0dHJpYnV0ZXMoYXR0cnMpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMgPSBhdHRycztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1lc3NhZ2VPbkVuZCgpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UucmVtb3ZlTGlzdGVuZXIoJ2JvZHknLCBtZXNzYWdlT25Cb2R5KTtcbiAgICAgICAgICAgIG1lc3NhZ2UucmVtb3ZlTGlzdGVuZXIoJ2F0dHJpYnV0ZXMnLCBtZXNzYWdlT25BdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgcGFydHM6IG1lc3NhZ2VQYXJ0c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBtZXNzYWdlLm9uKCdib2R5JywgbWVzc2FnZU9uQm9keSk7XG4gICAgICAgIG1lc3NhZ2Uub25jZSgnYXR0cmlidXRlcycsIG1lc3NhZ2VPbkF0dHJpYnV0ZXMpO1xuICAgICAgICBtZXNzYWdlLm9uY2UoJ2VuZCcsIG1lc3NhZ2VPbkVuZCk7XG4gICAgfSk7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/imap-simple/lib/helpers/getMessage.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/imap-simple/lib/imapSimple.js":
/*!*****************************************************!*\
  !*** ../node_modules/imap-simple/lib/imapSimple.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar Imap = __webpack_require__(/*! imap */ \"(rsc)/../node_modules/imap/lib/Connection.js\");\nvar nodeify = __webpack_require__(/*! nodeify */ \"(rsc)/../node_modules/nodeify/index.js\");\nvar getMessage = __webpack_require__(/*! ./helpers/getMessage */ \"(rsc)/../node_modules/imap-simple/lib/helpers/getMessage.js\");\nvar errors = __webpack_require__(/*! ./errors */ \"(rsc)/../node_modules/imap-simple/lib/errors.js\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar qp = __webpack_require__(/*! quoted-printable */ \"(rsc)/../node_modules/quoted-printable/quoted-printable.js\");\nvar iconvlite = __webpack_require__(/*! iconv-lite */ \"(rsc)/../node_modules/iconv-lite/lib/index.js\");\nvar utf8 = __webpack_require__(/*! utf8 */ \"(rsc)/../node_modules/utf8/utf8.js\");\nvar uuencode = __webpack_require__(/*! uuencode */ \"(rsc)/../node_modules/uuencode/index.js\");\n\n/**\n * Constructs an instance of ImapSimple\n *\n * @param {object} imap a constructed node-imap connection\n * @constructor\n * @class ImapSimple\n */\nfunction ImapSimple(imap) {\n    var self = this;\n    self.imap = imap;\n\n    // flag to determine whether we should suppress ECONNRESET from bubbling up to listener\n    self.ending = false;\n\n    // pass most node-imap `Connection` events through 1:1\n    ['alert', 'mail', 'expunge', 'uidvalidity', 'update', 'close', 'end'].forEach(function (event) {\n        self.imap.on(event, self.emit.bind(self, event));\n    });\n\n    // special handling for `error` event\n    self.imap.on('error', function (err) {\n        // if .end() has been called and an 'ECONNRESET' error is received, don't bubble\n        if (err && self.ending && (err.code.toUpperCase() === 'ECONNRESET')) {\n            return;\n        }\n\n        self.emit('error', err);\n    });\n}\n\nutil.inherits(ImapSimple, EventEmitter);\n\n/**\n * disconnect from the imap server\n */\nImapSimple.prototype.end = function () {\n    var self = this;\n\n    // set state flag to suppress 'ECONNRESET' errors that are triggered when .end() is called.\n    // it is a known issue that has no known fix. This just temporarily ignores that error.\n    // https://github.com/mscdex/node-imap/issues/391\n    // https://github.com/mscdex/node-imap/issues/395\n    self.ending = true;\n\n    // using 'close' event to unbind ECONNRESET error handler, because the node-imap\n    // maintainer claims it is the more reliable event between 'end' and 'close'.\n    // https://github.com/mscdex/node-imap/issues/394\n    self.imap.once('close', function () {\n        self.ending = false;\n    });\n\n    self.imap.end();\n};\n\n/**\n * Open a mailbox\n *\n * @param {string} boxName The name of the box to open\n * @param {function} [callback] Optional callback, receiving signature (err, boxName)\n * @returns {undefined|Promise} Returns a promise when no callback is specified, resolving to `boxName`\n * @memberof ImapSimple\n */\nImapSimple.prototype.openBox = function (boxName, callback) {\n    var self = this;\n\n    if (callback) {\n        return nodeify(this.openBox(boxName), callback);\n    }\n\n    return new Promise(function (resolve, reject) {\n\n        self.imap.openBox(boxName, function (err, result) {\n\n            if (err) {\n                reject(err);\n                return;\n            }\n\n            resolve(result);\n        });\n    });\n};\n\n/**\n * Close a mailbox\n *\n * @param {boolean} [autoExpunge=true] If autoExpunge is true, any messages marked as Deleted in the currently open mailbox will be remove\n * @param {function} [callback] Optional callback, receiving signature (err)\n * @returns {undefined|Promise} Returns a promise when no callback is specified, resolving to `boxName`\n * @memberof ImapSimple\n */\nImapSimple.prototype.closeBox = function (autoExpunge=true, callback) {\n    var self = this;    \n\n    if (typeof(autoExpunge) == 'function'){\n        callback = autoExpunge;\n        autoExpunge = true;\n    }\n\n    if (callback) {\n        return nodeify(this.closeBox(autoExpunge), callback);\n    }\n\n    return new Promise(function (resolve, reject) {\n\n        self.imap.closeBox(autoExpunge, function (err, result) {\n\n            if (err) {\n                reject(err);\n                return;\n            }\n\n            resolve(result);\n        });\n    });\n};\n\n/**\n * Search the currently open mailbox, and retrieve the results\n *\n * Results are in the form:\n *\n * [{\n *   attributes: object,\n *   parts: [ { which: string, size: number, body: string }, ... ]\n * }, ...]\n *\n * See node-imap's ImapMessage signature for information about `attributes`, `which`, `size`, and `body`.\n * For any message part that is a `HEADER`, the body is automatically parsed into an object.\n *\n * @param {object} searchCriteria Criteria to use to search. Passed to node-imap's .search() 1:1\n * @param {object} fetchOptions Criteria to use to fetch the search results. Passed to node-imap's .fetch() 1:1\n * @param {function} [callback] Optional callback, receiving signature (err, results)\n * @returns {undefined|Promise} Returns a promise when no callback is specified, resolving to `results`\n * @memberof ImapSimple\n */\nImapSimple.prototype.search = function (searchCriteria, fetchOptions, callback) {\n    var self = this;\n\n    if (!callback && typeof fetchOptions === 'function') {\n        callback = fetchOptions;\n        fetchOptions = null;\n    }\n\n    if (callback) {\n        return nodeify(this.search(searchCriteria, fetchOptions), callback);\n    }\n\n    return new Promise(function (resolve, reject) {\n\n        self.imap.search(searchCriteria, function (err, uids) {\n\n            if (err) {\n                reject(err);\n                return;\n            }\n\n            if (!uids.length) {\n                resolve([]);\n                return;\n            }\n\n            var fetch = self.imap.fetch(uids, fetchOptions);\n            var messagesRetrieved = 0;\n            var messages = [];\n\n            function fetchOnMessage(message, seqNo) {\n                getMessage(message).then(function (message) {\n                    message.seqNo = seqNo;\n                    messages[seqNo] = message;\n\n                    messagesRetrieved++;\n                    if (messagesRetrieved === uids.length) {\n                        fetchCompleted();\n                    }\n                });\n            }\n\n            function fetchCompleted() {\n                // pare array down while keeping messages in order\n                var pared = messages.filter(function (m) { return !!m; });\n                resolve(pared);\n            }\n\n            function fetchOnError(err) {\n                fetch.removeListener('message', fetchOnMessage);\n                fetch.removeListener('end', fetchOnEnd);\n                reject(err);\n            }\n\n            function fetchOnEnd() {\n                fetch.removeListener('message', fetchOnMessage);\n                fetch.removeListener('error', fetchOnError);\n            }\n\n            fetch.on('message', fetchOnMessage);\n            fetch.once('error', fetchOnError);\n            fetch.once('end', fetchOnEnd);\n        });\n    });\n};\n\n/**\n * Download a \"part\" (either a portion of the message body, or an attachment)\n *\n * @param {object} message The message returned from `search()`\n * @param {object} part The message part to be downloaded, from the `message.attributes.struct` Array\n * @param {function} [callback] Optional callback, receiving signature (err, data)\n * @returns {undefined|Promise} Returns a promise when no callback is specified, resolving to `data`\n * @memberof ImapSimple\n */\nImapSimple.prototype.getPartData = function (message, part, callback) {\n    var self = this;\n\n    if (callback) {\n        return nodeify(self.getPartData(message, part), callback);\n    }\n\n    return new Promise(function (resolve, reject) {\n        var fetch = self.imap.fetch(message.attributes.uid, {\n            bodies: [part.partID],\n            struct: true\n        });\n\n        function fetchOnMessage(msg) {\n            getMessage(msg).then(function (result) {\n                if (result.parts.length !== 1) {\n                    reject(new Error('Got ' + result.parts.length + ' parts, should get 1'));\n                    return;\n                }\n\n                var data = result.parts[0].body;\n\n                var encoding = part.encoding.toUpperCase();\n\n                if (encoding === 'BASE64') {\n                    resolve(new Buffer(data, 'base64'));\n                    return;\n                }\n\n                if (encoding === 'QUOTED-PRINTABLE') {\n                    if (part.params && part.params.charset &&\n                        part.params.charset.toUpperCase() === 'UTF-8') {\n                        resolve((new Buffer(utf8.decode(qp.decode(data)))).toString());\n                    } else {\n                        resolve((new Buffer(qp.decode(data))).toString());\n                    }\n                    return;\n                }\n\n                if (encoding === '7BIT') {\n                    resolve((new Buffer(data)).toString('ascii'));\n                    return;\n                }\n\n                if (encoding === '8BIT' || encoding === 'BINARY') {\n                    var charset = (part.params && part.params.charset) || 'utf-8';\n                    resolve(iconvlite.decode(new Buffer(data), charset));\n                    return;\n                }\n\n                if (encoding === 'UUENCODE') {\n                    var parts = data.toString().split('\\n'); // remove newline characters\n                    var merged = parts.splice(1, parts.length - 4).join(''); // remove excess lines and join lines with empty string\n                    resolve(uuencode.decode(merged));\n                    return;\n                }\n\n                // if it gets here, the encoding is not currently supported\n                reject(new Error('Unknown encoding ' + part.encoding));\n            });\n        }\n\n        function fetchOnError(err) {\n            fetch.removeListener('message', fetchOnMessage);\n            fetch.removeListener('end', fetchOnEnd);\n            reject(err);\n        }\n\n        function fetchOnEnd() {\n            fetch.removeListener('message', fetchOnMessage);\n            fetch.removeListener('error', fetchOnError);\n        }\n\n        fetch.once('message', fetchOnMessage);\n        fetch.once('error', fetchOnError);\n        fetch.once('end', fetchOnEnd);\n    });\n};\n\n/**\n * Moves the specified message(s) in the currently open mailbox to another mailbox.\n *\n * @param {string|Array} source The node-imap `MessageSource` indicating the message(s) from the current open mailbox\n *  to move.\n * @param {string} boxName The mailbox to move the message(s) to.\n * @param {function} [callback] Optional callback, receiving signature (err)\n * @returns {undefined|Promise} Returns a promise when no callback is specified, resolving when the action succeeds.\n * @memberof ImapSimple\n */\nImapSimple.prototype.moveMessage = function (source, boxName, callback) {\n    var self = this;\n\n    if (callback) {\n        return nodeify(self.moveMessage(source, boxName), callback);\n    }\n\n    return new Promise(function (resolve, reject) {\n        self.imap.move(source, boxName, function (err) {\n            if (err) {\n                reject(err);\n                return;\n            }\n\n            resolve();\n        });\n    });\n};\n\n/**\n * Adds the provided label(s) to the specified message(s).\n *\n * This is a Gmail extension method (X-GM-EXT-1)\n *\n * @param {string|Array} source The node-imap `MessageSource` indicating the message(s) to add the label(s) to.\n * @param {string|Array} labels Either a single string or an array of strings indicating the labels to add to the\n *  message(s).\n * @param {function} [callback] Optional callback, receiving signature (err)\n * @returns {undefined|Promise} Returns a promise when no callback is specified, resolving when the action succeeds.\n * @memberof ImapSimple\n */\nImapSimple.prototype.addMessageLabel = function (source, labels, callback) {\n    var self = this;\n\n    if (callback) {\n        return nodeify(self.addMessageLabel(source, labels), callback);\n    }\n\n    return new Promise(function (resolve, reject) {\n        self.imap.addLabels(source, labels, function (err) {\n            if (err) {\n                reject(err);\n                return;\n            }\n\n            resolve();\n        });\n    });\n};\n\n/**\n * Remove the provided label(s) from the specified message(s).\n *\n * This is a Gmail extension method (X-GM-EXT-1)\n *\n * @param {string|Array} source The node-imap `MessageSource` indicating the message(s) to remove the label(s) from.\n * @param {string|Array} labels Either a single string or an array of strings indicating the labels to remove from the\n *  message(s).\n * @param {function} [callback] Optional callback, receiving signature (err)\n * @returns {undefined|Promise} Returns a promise when no callback is specified, resolving when the action succeeds.\n * @memberof ImapSimple\n */\nImapSimple.prototype.removeMessageLabel = function (source, labels, callback) {\n  var self = this;\n\n  if (callback) {\n      return nodeify(self.removeMessageLabel(source, labels), callback);\n  }\n\n  return new Promise(function (resolve, reject) {\n      self.imap.delLabels(source, labels, function (err) {\n          if (err) {\n              reject(err);\n              return;\n          }\n\n          resolve();\n      });\n  });\n};\n\n/**\n * Adds the provided flag(s) to the specified message(s).\n *\n * @param {string|Array} uid The messages uid\n * @param {string|Array} flags Either a single string or an array of strings indicating the flags to add to the\n *  message(s).\n * @param {function} [callback] Optional callback, receiving signature (err)\n * @returns {undefined|Promise} Returns a promise when no callback is specified, resolving when the action succeeds.\n * @memberof ImapSimple\n */\nImapSimple.prototype.addFlags = function (uid, flags, callback) {\n    var self = this;\n\n    if (callback) {\n        return nodeify(self.addFlags(uid, flags), callback);\n    }\n\n    return new Promise(function (resolve, reject) {\n        self.imap.addFlags(uid, flags, function (err) {\n            if (err) {\n                reject(err);\n                return;\n            }\n\n            resolve();\n        });\n    });\n};\n\n/**\n * Removes the provided flag(s) to the specified message(s).\n *\n * @param {string|Array} uid The messages uid\n * @param {string|Array} flags Either a single string or an array of strings indicating the flags to remove from the\n *  message(s).\n * @param {function} [callback] Optional callback, receiving signature (err)\n * @returns {undefined|Promise} Returns a promise when no callback is specified, resolving when the action succeeds.\n * @memberof ImapSimple\n */\nImapSimple.prototype.delFlags = function (uid, flags, callback) {\n    var self = this;\n\n    if (callback) {\n        return nodeify(self.delFlags(uid, flags), callback);\n    }\n\n    return new Promise(function (resolve, reject) {\n        self.imap.delFlags(uid, flags, function (err) {\n            if (err) {\n                reject(err);\n                return;\n            }\n\n            resolve();\n        });\n    });\n};\n\n/**\n * Deletes the specified message(s).\n *\n * @param {string|Array} uid The uid or array of uids indicating the messages to be deleted\n * @param {function} [callback] Optional callback, receiving signature (err)\n * @returns {undefined|Promise} Returns a promise when no callback is specified, resolving when the action succeeds.\n * @memberof ImapSimple\n */\nImapSimple.prototype.deleteMessage = function (uid, callback) {\n    var self = this;\n\n    if (callback) {\n        return nodeify(self.deleteMessage(uid), callback);\n    }\n\n    return new Promise(function (resolve, reject) {\n        self.imap.addFlags(uid, '\\\\Deleted', function (err) {\n            if (err) {\n                reject(err);\n                return;\n            }\n            self.imap.expunge( function (err) {\n                if (err) {\n                    reject(err);\n                    return;\n                }\n                resolve();\n            });\n        });\n    });\n};\n\n/**\n * Appends a mime-encoded message to a mailbox\n *\n * @param {string|Buffer} message The messages to append to the mailbox\n * @param {object} [options]\n * @param {string} [options.mailbox] The mailbox to append the message to.\n  Defaults to the currently open mailbox.\n * @param {string|Array<String>} [options.flag] A single flag (e.g. 'Seen') or an array\n  of flags (e.g. ['Seen', 'Flagged']) to append to the message. Defaults to\n  no flags.\n * @param {function} [callback] Optional callback, receiving signature (err)\n * @returns {undefined|Promise} Returns a promise when no callback is specified, resolving when the action succeeds.\n * @memberof ImapSimple\n */\nImapSimple.prototype.append = function (message, options, callback) {\n    var self = this;\n\n    if (callback) {\n        return nodeify(self.append(message, options), callback);\n    }\n\n    return new Promise(function (resolve, reject) {\n        self.imap.append(message, options, function (err) {\n            if (err) {\n                reject(err);\n                return;\n            }\n\n            resolve();\n        });\n    });\n};\n\n/**\n * Returns a list of mailboxes (folders).\n *\n * @param {function} [callback] Optional callback containing 'boxes' object.\n * @returns {undefined|Promise} Returns a promise when no callback is specified,\n *  resolving when the action succeeds.\n */\n\nImapSimple.prototype.getBoxes = function (callback) {\n    var self = this;\n\n    if (callback) {\n        return nodeify(self.getBoxes(), callback);\n    }\n\n    return new Promise(function (resolve, reject) {\n        self.imap.getBoxes(function (err, boxes) {\n            if (err) {\n                reject(err);\n                return;\n            }\n\n            resolve(boxes);\n        });\n    });\n};\n\n/**\n * Add new mailbox (folder)\n *\n * @param {string} boxName The name of the box to added\n * @param {function} [callback] Optional callback, receiving signature (err, boxName)\n * @returns {undefined|Promise} Returns a promise when no callback is specified, resolving to `boxName`\n * @memberof ImapSimple\n */\nImapSimple.prototype.addBox = function (boxName, callback) {\n    var self = this;\n\n    if (callback) {\n        return nodeify(this.addBox(boxName), callback);\n    }\n\n    return new Promise(function (resolve, reject) {\n\n        self.imap.addBox(boxName, function (err) {\n\n            if (err) {\n                reject(err);\n                return;\n            }\n\n            resolve(boxName);\n        });\n    });\n};\n\n/**\n * Delete mailbox (folder)\n *\n * @param {string} boxName The name of the box to deleted\n * @param {function} [callback] Optional callback, receiving signature (err, boxName)\n * @returns {undefined|Promise} Returns a promise when no callback is specified, resolving to `boxName`\n * @memberof ImapSimple\n */\nImapSimple.prototype.delBox = function (boxName, callback) {\n    var self = this;\n\n    if (callback) {\n        return nodeify(this.delBox(boxName), callback);\n    }\n\n    return new Promise(function (resolve, reject) {\n\n        self.imap.delBox(boxName, function (err) {\n\n            if (err) {\n                reject(err);\n                return;\n            }\n\n            resolve(boxName);\n        });\n    });\n};\n\n/**\n * Connect to an Imap server, returning an ImapSimple instance, which is a wrapper over node-imap to\n * simplify it's api for common use cases.\n *\n * @param {object} options\n * @param {object} options.imap Options to pass to node-imap constructor 1:1\n * @param {function} [callback] Optional callback, receiving signature (err, connection)\n * @returns {undefined|Promise} Returns a promise when no callback is specified, resolving to `connection`\n */\nfunction connect(options, callback) {\n    options = options || {};\n    options.imap = options.imap || {};\n\n    // support old connectTimeout config option. Remove in v2.0.0\n    if (options.hasOwnProperty('connectTimeout')) {\n        console.warn('[imap-simple] connect: options.connectTimeout is deprecated. ' +\n            'Please use options.imap.authTimeout instead.');\n        options.imap.authTimeout = options.connectTimeout;\n    }\n\n    // set default authTimeout\n    options.imap.authTimeout = options.imap.hasOwnProperty('authTimeout') ? options.imap.authTimeout : 2000;\n\n    if (callback) {\n        return nodeify(connect(options), callback);\n    }\n\n    return new Promise(function (resolve, reject) {\n        var imap = new Imap(options.imap);\n\n        function imapOnReady() {\n            imap.removeListener('error', imapOnError);\n            imap.removeListener('close', imapOnClose);\n            imap.removeListener('end', imapOnEnd);\n            resolve(new ImapSimple(imap));\n        }\n\n        function imapOnError(err) {\n            if (err.source === 'timeout-auth') {\n                err = new errors.ConnectionTimeoutError(options.imap.authTimeout);\n            }\n\n            imap.removeListener('ready', imapOnReady);\n            imap.removeListener('close', imapOnClose);\n            imap.removeListener('end', imapOnEnd);\n            reject(err);\n        }\n\n        function imapOnEnd() {\n            imap.removeListener('ready', imapOnReady);\n            imap.removeListener('error', imapOnError);\n            imap.removeListener('close', imapOnClose);\n            reject(new Error('Connection ended unexpectedly'));\n        }\n\n        function imapOnClose() {\n            imap.removeListener('ready', imapOnReady);\n            imap.removeListener('error', imapOnError);\n            imap.removeListener('end', imapOnEnd);\n            reject(new Error('Connection closed unexpectedly'));\n        }\n\n        imap.once('ready', imapOnReady);\n        imap.once('error', imapOnError);\n        imap.once('close', imapOnClose);\n        imap.once('end', imapOnEnd);\n\n        if (options.hasOwnProperty('onmail')) {\n            imap.on('mail', options.onmail);\n        }\n\n        if (options.hasOwnProperty('onexpunge')) {\n            imap.on('expunge', options.onexpunge);\n        }\n\n        if (options.hasOwnProperty('onupdate')) {\n            imap.on('update', options.onupdate);\n        }\n\n        imap.connect();\n    });\n}\n\n/**\n * Given the `message.attributes.struct`, retrieve a flattened array of `parts` objects that describe the structure of\n * the different parts of the message's body. Useful for getting a simple list to iterate for the purposes of,\n * for example, finding all attachments.\n *\n * Code taken from http://stackoverflow.com/questions/25247207/how-to-read-and-save-attachments-using-node-imap\n *\n * @param {Array} struct The `message.attributes.struct` value from the message you wish to retrieve parts for.\n * @param {Array} [parts] The list of parts to push to.\n * @returns {Array} a flattened array of `parts` objects that describe the structure of the different parts of the\n *  message's body\n */\nfunction getParts(struct, parts) {\n    parts = parts || [];\n    for (var i = 0; i < struct.length; i++) {\n        if (Array.isArray(struct[i])) {\n            getParts(struct[i], parts);\n        } else if (struct[i].partID) {\n            parts.push(struct[i]);\n        }\n    }\n    return parts;\n}\n\nmodule.exports = {\n    connect: connect,\n    ImapSimple: ImapSimple,\n    parseHeader: Imap.parseHeader,\n    getParts: getParts,\n    errors: errors\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2ltYXAtc2ltcGxlL2xpYi9pbWFwU2ltcGxlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsV0FBVyxtQkFBTyxDQUFDLDBEQUFNO0FBQ3pCLGNBQWMsbUJBQU8sQ0FBQyx1REFBUztBQUMvQixpQkFBaUIsbUJBQU8sQ0FBQyx5RkFBc0I7QUFDL0MsYUFBYSxtQkFBTyxDQUFDLGlFQUFVO0FBQy9CLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixtQkFBbUIsMERBQThCO0FBQ2pELFNBQVMsbUJBQU8sQ0FBQyxvRkFBa0I7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsaUVBQVk7QUFDcEMsV0FBVyxtQkFBTyxDQUFDLGdEQUFNO0FBQ3pCLGVBQWUsbUJBQU8sQ0FBQyx5REFBVTs7QUFFakM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxVQUFVO0FBQ3JCLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztB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QTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixhQUFhLG1CQUFtQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxrZnJ5dFxcLmdlbWluaVxcYW50aWdyYXZpdHlcXHNjcmF0Y2hcXGRyX2thbHNfdmlydHVhbF9ob3NwaXRhbFxcbm9kZV9tb2R1bGVzXFxpbWFwLXNpbXBsZVxcbGliXFxpbWFwU2ltcGxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciBJbWFwID0gcmVxdWlyZSgnaW1hcCcpO1xudmFyIG5vZGVpZnkgPSByZXF1aXJlKCdub2RlaWZ5Jyk7XG52YXIgZ2V0TWVzc2FnZSA9IHJlcXVpcmUoJy4vaGVscGVycy9nZXRNZXNzYWdlJyk7XG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBxcCA9IHJlcXVpcmUoJ3F1b3RlZC1wcmludGFibGUnKTtcbnZhciBpY29udmxpdGUgPSByZXF1aXJlKCdpY29udi1saXRlJyk7XG52YXIgdXRmOCA9IHJlcXVpcmUoJ3V0ZjgnKTtcbnZhciB1dWVuY29kZSA9IHJlcXVpcmUoJ3V1ZW5jb2RlJyk7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhbiBpbnN0YW5jZSBvZiBJbWFwU2ltcGxlXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGltYXAgYSBjb25zdHJ1Y3RlZCBub2RlLWltYXAgY29ubmVjdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKiBAY2xhc3MgSW1hcFNpbXBsZVxuICovXG5mdW5jdGlvbiBJbWFwU2ltcGxlKGltYXApIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5pbWFwID0gaW1hcDtcblxuICAgIC8vIGZsYWcgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgd2Ugc2hvdWxkIHN1cHByZXNzIEVDT05OUkVTRVQgZnJvbSBidWJibGluZyB1cCB0byBsaXN0ZW5lclxuICAgIHNlbGYuZW5kaW5nID0gZmFsc2U7XG5cbiAgICAvLyBwYXNzIG1vc3Qgbm9kZS1pbWFwIGBDb25uZWN0aW9uYCBldmVudHMgdGhyb3VnaCAxOjFcbiAgICBbJ2FsZXJ0JywgJ21haWwnLCAnZXhwdW5nZScsICd1aWR2YWxpZGl0eScsICd1cGRhdGUnLCAnY2xvc2UnLCAnZW5kJ10uZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgc2VsZi5pbWFwLm9uKGV2ZW50LCBzZWxmLmVtaXQuYmluZChzZWxmLCBldmVudCkpO1xuICAgIH0pO1xuXG4gICAgLy8gc3BlY2lhbCBoYW5kbGluZyBmb3IgYGVycm9yYCBldmVudFxuICAgIHNlbGYuaW1hcC5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIC8vIGlmIC5lbmQoKSBoYXMgYmVlbiBjYWxsZWQgYW5kIGFuICdFQ09OTlJFU0VUJyBlcnJvciBpcyByZWNlaXZlZCwgZG9uJ3QgYnViYmxlXG4gICAgICAgIGlmIChlcnIgJiYgc2VsZi5lbmRpbmcgJiYgKGVyci5jb2RlLnRvVXBwZXJDYXNlKCkgPT09ICdFQ09OTlJFU0VUJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH0pO1xufVxuXG51dGlsLmluaGVyaXRzKEltYXBTaW1wbGUsIEV2ZW50RW1pdHRlcik7XG5cbi8qKlxuICogZGlzY29ubmVjdCBmcm9tIHRoZSBpbWFwIHNlcnZlclxuICovXG5JbWFwU2ltcGxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gc2V0IHN0YXRlIGZsYWcgdG8gc3VwcHJlc3MgJ0VDT05OUkVTRVQnIGVycm9ycyB0aGF0IGFyZSB0cmlnZ2VyZWQgd2hlbiAuZW5kKCkgaXMgY2FsbGVkLlxuICAgIC8vIGl0IGlzIGEga25vd24gaXNzdWUgdGhhdCBoYXMgbm8ga25vd24gZml4LiBUaGlzIGp1c3QgdGVtcG9yYXJpbHkgaWdub3JlcyB0aGF0IGVycm9yLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tc2NkZXgvbm9kZS1pbWFwL2lzc3Vlcy8zOTFcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbXNjZGV4L25vZGUtaW1hcC9pc3N1ZXMvMzk1XG4gICAgc2VsZi5lbmRpbmcgPSB0cnVlO1xuXG4gICAgLy8gdXNpbmcgJ2Nsb3NlJyBldmVudCB0byB1bmJpbmQgRUNPTk5SRVNFVCBlcnJvciBoYW5kbGVyLCBiZWNhdXNlIHRoZSBub2RlLWltYXBcbiAgICAvLyBtYWludGFpbmVyIGNsYWltcyBpdCBpcyB0aGUgbW9yZSByZWxpYWJsZSBldmVudCBiZXR3ZWVuICdlbmQnIGFuZCAnY2xvc2UnLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tc2NkZXgvbm9kZS1pbWFwL2lzc3Vlcy8zOTRcbiAgICBzZWxmLmltYXAub25jZSgnY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuZW5kaW5nID0gZmFsc2U7XG4gICAgfSk7XG5cbiAgICBzZWxmLmltYXAuZW5kKCk7XG59O1xuXG4vKipcbiAqIE9wZW4gYSBtYWlsYm94XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJveE5hbWUgVGhlIG5hbWUgb2YgdGhlIGJveCB0byBvcGVuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIE9wdGlvbmFsIGNhbGxiYWNrLCByZWNlaXZpbmcgc2lnbmF0dXJlIChlcnIsIGJveE5hbWUpXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfFByb21pc2V9IFJldHVybnMgYSBwcm9taXNlIHdoZW4gbm8gY2FsbGJhY2sgaXMgc3BlY2lmaWVkLCByZXNvbHZpbmcgdG8gYGJveE5hbWVgXG4gKiBAbWVtYmVyb2YgSW1hcFNpbXBsZVxuICovXG5JbWFwU2ltcGxlLnByb3RvdHlwZS5vcGVuQm94ID0gZnVuY3Rpb24gKGJveE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBub2RlaWZ5KHRoaXMub3BlbkJveChib3hOYW1lKSwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cbiAgICAgICAgc2VsZi5pbWFwLm9wZW5Cb3goYm94TmFtZSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XG5cbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIENsb3NlIGEgbWFpbGJveFxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2F1dG9FeHB1bmdlPXRydWVdIElmIGF1dG9FeHB1bmdlIGlzIHRydWUsIGFueSBtZXNzYWdlcyBtYXJrZWQgYXMgRGVsZXRlZCBpbiB0aGUgY3VycmVudGx5IG9wZW4gbWFpbGJveCB3aWxsIGJlIHJlbW92ZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBPcHRpb25hbCBjYWxsYmFjaywgcmVjZWl2aW5nIHNpZ25hdHVyZSAoZXJyKVxuICogQHJldHVybnMge3VuZGVmaW5lZHxQcm9taXNlfSBSZXR1cm5zIGEgcHJvbWlzZSB3aGVuIG5vIGNhbGxiYWNrIGlzIHNwZWNpZmllZCwgcmVzb2x2aW5nIHRvIGBib3hOYW1lYFxuICogQG1lbWJlcm9mIEltYXBTaW1wbGVcbiAqL1xuSW1hcFNpbXBsZS5wcm90b3R5cGUuY2xvc2VCb3ggPSBmdW5jdGlvbiAoYXV0b0V4cHVuZ2U9dHJ1ZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7ICAgIFxuXG4gICAgaWYgKHR5cGVvZihhdXRvRXhwdW5nZSkgPT0gJ2Z1bmN0aW9uJyl7XG4gICAgICAgIGNhbGxiYWNrID0gYXV0b0V4cHVuZ2U7XG4gICAgICAgIGF1dG9FeHB1bmdlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIG5vZGVpZnkodGhpcy5jbG9zZUJveChhdXRvRXhwdW5nZSksIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXG4gICAgICAgIHNlbGYuaW1hcC5jbG9zZUJveChhdXRvRXhwdW5nZSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XG5cbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFNlYXJjaCB0aGUgY3VycmVudGx5IG9wZW4gbWFpbGJveCwgYW5kIHJldHJpZXZlIHRoZSByZXN1bHRzXG4gKlxuICogUmVzdWx0cyBhcmUgaW4gdGhlIGZvcm06XG4gKlxuICogW3tcbiAqICAgYXR0cmlidXRlczogb2JqZWN0LFxuICogICBwYXJ0czogWyB7IHdoaWNoOiBzdHJpbmcsIHNpemU6IG51bWJlciwgYm9keTogc3RyaW5nIH0sIC4uLiBdXG4gKiB9LCAuLi5dXG4gKlxuICogU2VlIG5vZGUtaW1hcCdzIEltYXBNZXNzYWdlIHNpZ25hdHVyZSBmb3IgaW5mb3JtYXRpb24gYWJvdXQgYGF0dHJpYnV0ZXNgLCBgd2hpY2hgLCBgc2l6ZWAsIGFuZCBgYm9keWAuXG4gKiBGb3IgYW55IG1lc3NhZ2UgcGFydCB0aGF0IGlzIGEgYEhFQURFUmAsIHRoZSBib2R5IGlzIGF1dG9tYXRpY2FsbHkgcGFyc2VkIGludG8gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBzZWFyY2hDcml0ZXJpYSBDcml0ZXJpYSB0byB1c2UgdG8gc2VhcmNoLiBQYXNzZWQgdG8gbm9kZS1pbWFwJ3MgLnNlYXJjaCgpIDE6MVxuICogQHBhcmFtIHtvYmplY3R9IGZldGNoT3B0aW9ucyBDcml0ZXJpYSB0byB1c2UgdG8gZmV0Y2ggdGhlIHNlYXJjaCByZXN1bHRzLiBQYXNzZWQgdG8gbm9kZS1pbWFwJ3MgLmZldGNoKCkgMToxXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIE9wdGlvbmFsIGNhbGxiYWNrLCByZWNlaXZpbmcgc2lnbmF0dXJlIChlcnIsIHJlc3VsdHMpXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfFByb21pc2V9IFJldHVybnMgYSBwcm9taXNlIHdoZW4gbm8gY2FsbGJhY2sgaXMgc3BlY2lmaWVkLCByZXNvbHZpbmcgdG8gYHJlc3VsdHNgXG4gKiBAbWVtYmVyb2YgSW1hcFNpbXBsZVxuICovXG5JbWFwU2ltcGxlLnByb3RvdHlwZS5zZWFyY2ggPSBmdW5jdGlvbiAoc2VhcmNoQ3JpdGVyaWEsIGZldGNoT3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoIWNhbGxiYWNrICYmIHR5cGVvZiBmZXRjaE9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBmZXRjaE9wdGlvbnM7XG4gICAgICAgIGZldGNoT3B0aW9ucyA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBub2RlaWZ5KHRoaXMuc2VhcmNoKHNlYXJjaENyaXRlcmlhLCBmZXRjaE9wdGlvbnMpLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblxuICAgICAgICBzZWxmLmltYXAuc2VhcmNoKHNlYXJjaENyaXRlcmlhLCBmdW5jdGlvbiAoZXJyLCB1aWRzKSB7XG5cbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdWlkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKFtdKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmZXRjaCA9IHNlbGYuaW1hcC5mZXRjaCh1aWRzLCBmZXRjaE9wdGlvbnMpO1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2VzUmV0cmlldmVkID0gMDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlcyA9IFtdO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBmZXRjaE9uTWVzc2FnZShtZXNzYWdlLCBzZXFObykge1xuICAgICAgICAgICAgICAgIGdldE1lc3NhZ2UobWVzc2FnZSkudGhlbihmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNlcU5vID0gc2VxTm87XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzW3NlcU5vXSA9IG1lc3NhZ2U7XG5cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXNSZXRyaWV2ZWQrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VzUmV0cmlldmVkID09PSB1aWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hDb21wbGV0ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBmZXRjaENvbXBsZXRlZCgpIHtcbiAgICAgICAgICAgICAgICAvLyBwYXJlIGFycmF5IGRvd24gd2hpbGUga2VlcGluZyBtZXNzYWdlcyBpbiBvcmRlclxuICAgICAgICAgICAgICAgIHZhciBwYXJlZCA9IG1lc3NhZ2VzLmZpbHRlcihmdW5jdGlvbiAobSkgeyByZXR1cm4gISFtOyB9KTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHBhcmVkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZmV0Y2hPbkVycm9yKGVycikge1xuICAgICAgICAgICAgICAgIGZldGNoLnJlbW92ZUxpc3RlbmVyKCdtZXNzYWdlJywgZmV0Y2hPbk1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGZldGNoLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBmZXRjaE9uRW5kKTtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZmV0Y2hPbkVuZCgpIHtcbiAgICAgICAgICAgICAgICBmZXRjaC5yZW1vdmVMaXN0ZW5lcignbWVzc2FnZScsIGZldGNoT25NZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBmZXRjaC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBmZXRjaE9uRXJyb3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmZXRjaC5vbignbWVzc2FnZScsIGZldGNoT25NZXNzYWdlKTtcbiAgICAgICAgICAgIGZldGNoLm9uY2UoJ2Vycm9yJywgZmV0Y2hPbkVycm9yKTtcbiAgICAgICAgICAgIGZldGNoLm9uY2UoJ2VuZCcsIGZldGNoT25FbmQpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogRG93bmxvYWQgYSBcInBhcnRcIiAoZWl0aGVyIGEgcG9ydGlvbiBvZiB0aGUgbWVzc2FnZSBib2R5LCBvciBhbiBhdHRhY2htZW50KVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBtZXNzYWdlIFRoZSBtZXNzYWdlIHJldHVybmVkIGZyb20gYHNlYXJjaCgpYFxuICogQHBhcmFtIHtvYmplY3R9IHBhcnQgVGhlIG1lc3NhZ2UgcGFydCB0byBiZSBkb3dubG9hZGVkLCBmcm9tIHRoZSBgbWVzc2FnZS5hdHRyaWJ1dGVzLnN0cnVjdGAgQXJyYXlcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gT3B0aW9uYWwgY2FsbGJhY2ssIHJlY2VpdmluZyBzaWduYXR1cmUgKGVyciwgZGF0YSlcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR8UHJvbWlzZX0gUmV0dXJucyBhIHByb21pc2Ugd2hlbiBubyBjYWxsYmFjayBpcyBzcGVjaWZpZWQsIHJlc29sdmluZyB0byBgZGF0YWBcbiAqIEBtZW1iZXJvZiBJbWFwU2ltcGxlXG4gKi9cbkltYXBTaW1wbGUucHJvdG90eXBlLmdldFBhcnREYXRhID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHBhcnQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBub2RlaWZ5KHNlbGYuZ2V0UGFydERhdGEobWVzc2FnZSwgcGFydCksIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgZmV0Y2ggPSBzZWxmLmltYXAuZmV0Y2gobWVzc2FnZS5hdHRyaWJ1dGVzLnVpZCwge1xuICAgICAgICAgICAgYm9kaWVzOiBbcGFydC5wYXJ0SURdLFxuICAgICAgICAgICAgc3RydWN0OiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZ1bmN0aW9uIGZldGNoT25NZXNzYWdlKG1zZykge1xuICAgICAgICAgICAgZ2V0TWVzc2FnZShtc2cpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQucGFydHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0dvdCAnICsgcmVzdWx0LnBhcnRzLmxlbmd0aCArICcgcGFydHMsIHNob3VsZCBnZXQgMScpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gcmVzdWx0LnBhcnRzWzBdLmJvZHk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZW5jb2RpbmcgPSBwYXJ0LmVuY29kaW5nLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICdCQVNFNjQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobmV3IEJ1ZmZlcihkYXRhLCAnYmFzZTY0JykpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGVuY29kaW5nID09PSAnUVVPVEVELVBSSU5UQUJMRScpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnQucGFyYW1zICYmIHBhcnQucGFyYW1zLmNoYXJzZXQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnQucGFyYW1zLmNoYXJzZXQudG9VcHBlckNhc2UoKSA9PT0gJ1VURi04Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgobmV3IEJ1ZmZlcih1dGY4LmRlY29kZShxcC5kZWNvZGUoZGF0YSkpKSkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKChuZXcgQnVmZmVyKHFwLmRlY29kZShkYXRhKSkpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICc3QklUJykge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKChuZXcgQnVmZmVyKGRhdGEpKS50b1N0cmluZygnYXNjaWknKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICc4QklUJyB8fCBlbmNvZGluZyA9PT0gJ0JJTkFSWScpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYXJzZXQgPSAocGFydC5wYXJhbXMgJiYgcGFydC5wYXJhbXMuY2hhcnNldCkgfHwgJ3V0Zi04JztcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShpY29udmxpdGUuZGVjb2RlKG5ldyBCdWZmZXIoZGF0YSksIGNoYXJzZXQpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChlbmNvZGluZyA9PT0gJ1VVRU5DT0RFJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBkYXRhLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpOyAvLyByZW1vdmUgbmV3bGluZSBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXJnZWQgPSBwYXJ0cy5zcGxpY2UoMSwgcGFydHMubGVuZ3RoIC0gNCkuam9pbignJyk7IC8vIHJlbW92ZSBleGNlc3MgbGluZXMgYW5kIGpvaW4gbGluZXMgd2l0aCBlbXB0eSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh1dWVuY29kZS5kZWNvZGUobWVyZ2VkKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiBpdCBnZXRzIGhlcmUsIHRoZSBlbmNvZGluZyBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZFxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcgJyArIHBhcnQuZW5jb2RpbmcpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZmV0Y2hPbkVycm9yKGVycikge1xuICAgICAgICAgICAgZmV0Y2gucmVtb3ZlTGlzdGVuZXIoJ21lc3NhZ2UnLCBmZXRjaE9uTWVzc2FnZSk7XG4gICAgICAgICAgICBmZXRjaC5yZW1vdmVMaXN0ZW5lcignZW5kJywgZmV0Y2hPbkVuZCk7XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGZldGNoT25FbmQoKSB7XG4gICAgICAgICAgICBmZXRjaC5yZW1vdmVMaXN0ZW5lcignbWVzc2FnZScsIGZldGNoT25NZXNzYWdlKTtcbiAgICAgICAgICAgIGZldGNoLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGZldGNoT25FcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICBmZXRjaC5vbmNlKCdtZXNzYWdlJywgZmV0Y2hPbk1lc3NhZ2UpO1xuICAgICAgICBmZXRjaC5vbmNlKCdlcnJvcicsIGZldGNoT25FcnJvcik7XG4gICAgICAgIGZldGNoLm9uY2UoJ2VuZCcsIGZldGNoT25FbmQpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBNb3ZlcyB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UocykgaW4gdGhlIGN1cnJlbnRseSBvcGVuIG1haWxib3ggdG8gYW5vdGhlciBtYWlsYm94LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSBzb3VyY2UgVGhlIG5vZGUtaW1hcCBgTWVzc2FnZVNvdXJjZWAgaW5kaWNhdGluZyB0aGUgbWVzc2FnZShzKSBmcm9tIHRoZSBjdXJyZW50IG9wZW4gbWFpbGJveFxuICogIHRvIG1vdmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gYm94TmFtZSBUaGUgbWFpbGJveCB0byBtb3ZlIHRoZSBtZXNzYWdlKHMpIHRvLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBPcHRpb25hbCBjYWxsYmFjaywgcmVjZWl2aW5nIHNpZ25hdHVyZSAoZXJyKVxuICogQHJldHVybnMge3VuZGVmaW5lZHxQcm9taXNlfSBSZXR1cm5zIGEgcHJvbWlzZSB3aGVuIG5vIGNhbGxiYWNrIGlzIHNwZWNpZmllZCwgcmVzb2x2aW5nIHdoZW4gdGhlIGFjdGlvbiBzdWNjZWVkcy5cbiAqIEBtZW1iZXJvZiBJbWFwU2ltcGxlXG4gKi9cbkltYXBTaW1wbGUucHJvdG90eXBlLm1vdmVNZXNzYWdlID0gZnVuY3Rpb24gKHNvdXJjZSwgYm94TmFtZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIG5vZGVpZnkoc2VsZi5tb3ZlTWVzc2FnZShzb3VyY2UsIGJveE5hbWUpLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5pbWFwLm1vdmUoc291cmNlLCBib3hOYW1lLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBBZGRzIHRoZSBwcm92aWRlZCBsYWJlbChzKSB0byB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UocykuXG4gKlxuICogVGhpcyBpcyBhIEdtYWlsIGV4dGVuc2lvbiBtZXRob2QgKFgtR00tRVhULTEpXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8QXJyYXl9IHNvdXJjZSBUaGUgbm9kZS1pbWFwIGBNZXNzYWdlU291cmNlYCBpbmRpY2F0aW5nIHRoZSBtZXNzYWdlKHMpIHRvIGFkZCB0aGUgbGFiZWwocykgdG8uXG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gbGFiZWxzIEVpdGhlciBhIHNpbmdsZSBzdHJpbmcgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyBpbmRpY2F0aW5nIHRoZSBsYWJlbHMgdG8gYWRkIHRvIHRoZVxuICogIG1lc3NhZ2UocykuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIE9wdGlvbmFsIGNhbGxiYWNrLCByZWNlaXZpbmcgc2lnbmF0dXJlIChlcnIpXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfFByb21pc2V9IFJldHVybnMgYSBwcm9taXNlIHdoZW4gbm8gY2FsbGJhY2sgaXMgc3BlY2lmaWVkLCByZXNvbHZpbmcgd2hlbiB0aGUgYWN0aW9uIHN1Y2NlZWRzLlxuICogQG1lbWJlcm9mIEltYXBTaW1wbGVcbiAqL1xuSW1hcFNpbXBsZS5wcm90b3R5cGUuYWRkTWVzc2FnZUxhYmVsID0gZnVuY3Rpb24gKHNvdXJjZSwgbGFiZWxzLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gbm9kZWlmeShzZWxmLmFkZE1lc3NhZ2VMYWJlbChzb3VyY2UsIGxhYmVscyksIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBzZWxmLmltYXAuYWRkTGFiZWxzKHNvdXJjZSwgbGFiZWxzLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIHByb3ZpZGVkIGxhYmVsKHMpIGZyb20gdGhlIHNwZWNpZmllZCBtZXNzYWdlKHMpLlxuICpcbiAqIFRoaXMgaXMgYSBHbWFpbCBleHRlbnNpb24gbWV0aG9kIChYLUdNLUVYVC0xKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSBzb3VyY2UgVGhlIG5vZGUtaW1hcCBgTWVzc2FnZVNvdXJjZWAgaW5kaWNhdGluZyB0aGUgbWVzc2FnZShzKSB0byByZW1vdmUgdGhlIGxhYmVsKHMpIGZyb20uXG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gbGFiZWxzIEVpdGhlciBhIHNpbmdsZSBzdHJpbmcgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyBpbmRpY2F0aW5nIHRoZSBsYWJlbHMgdG8gcmVtb3ZlIGZyb20gdGhlXG4gKiAgbWVzc2FnZShzKS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gT3B0aW9uYWwgY2FsbGJhY2ssIHJlY2VpdmluZyBzaWduYXR1cmUgKGVycilcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR8UHJvbWlzZX0gUmV0dXJucyBhIHByb21pc2Ugd2hlbiBubyBjYWxsYmFjayBpcyBzcGVjaWZpZWQsIHJlc29sdmluZyB3aGVuIHRoZSBhY3Rpb24gc3VjY2VlZHMuXG4gKiBAbWVtYmVyb2YgSW1hcFNpbXBsZVxuICovXG5JbWFwU2ltcGxlLnByb3RvdHlwZS5yZW1vdmVNZXNzYWdlTGFiZWwgPSBmdW5jdGlvbiAoc291cmNlLCBsYWJlbHMsIGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBub2RlaWZ5KHNlbGYucmVtb3ZlTWVzc2FnZUxhYmVsKHNvdXJjZSwgbGFiZWxzKSwgY2FsbGJhY2spO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHNlbGYuaW1hcC5kZWxMYWJlbHMoc291cmNlLCBsYWJlbHMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBBZGRzIHRoZSBwcm92aWRlZCBmbGFnKHMpIHRvIHRoZSBzcGVjaWZpZWQgbWVzc2FnZShzKS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gdWlkIFRoZSBtZXNzYWdlcyB1aWRcbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSBmbGFncyBFaXRoZXIgYSBzaW5nbGUgc3RyaW5nIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgaW5kaWNhdGluZyB0aGUgZmxhZ3MgdG8gYWRkIHRvIHRoZVxuICogIG1lc3NhZ2UocykuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIE9wdGlvbmFsIGNhbGxiYWNrLCByZWNlaXZpbmcgc2lnbmF0dXJlIChlcnIpXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfFByb21pc2V9IFJldHVybnMgYSBwcm9taXNlIHdoZW4gbm8gY2FsbGJhY2sgaXMgc3BlY2lmaWVkLCByZXNvbHZpbmcgd2hlbiB0aGUgYWN0aW9uIHN1Y2NlZWRzLlxuICogQG1lbWJlcm9mIEltYXBTaW1wbGVcbiAqL1xuSW1hcFNpbXBsZS5wcm90b3R5cGUuYWRkRmxhZ3MgPSBmdW5jdGlvbiAodWlkLCBmbGFncywgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIG5vZGVpZnkoc2VsZi5hZGRGbGFncyh1aWQsIGZsYWdzKSwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNlbGYuaW1hcC5hZGRGbGFncyh1aWQsIGZsYWdzLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBwcm92aWRlZCBmbGFnKHMpIHRvIHRoZSBzcGVjaWZpZWQgbWVzc2FnZShzKS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gdWlkIFRoZSBtZXNzYWdlcyB1aWRcbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSBmbGFncyBFaXRoZXIgYSBzaW5nbGUgc3RyaW5nIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgaW5kaWNhdGluZyB0aGUgZmxhZ3MgdG8gcmVtb3ZlIGZyb20gdGhlXG4gKiAgbWVzc2FnZShzKS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gT3B0aW9uYWwgY2FsbGJhY2ssIHJlY2VpdmluZyBzaWduYXR1cmUgKGVycilcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR8UHJvbWlzZX0gUmV0dXJucyBhIHByb21pc2Ugd2hlbiBubyBjYWxsYmFjayBpcyBzcGVjaWZpZWQsIHJlc29sdmluZyB3aGVuIHRoZSBhY3Rpb24gc3VjY2VlZHMuXG4gKiBAbWVtYmVyb2YgSW1hcFNpbXBsZVxuICovXG5JbWFwU2ltcGxlLnByb3RvdHlwZS5kZWxGbGFncyA9IGZ1bmN0aW9uICh1aWQsIGZsYWdzLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gbm9kZWlmeShzZWxmLmRlbEZsYWdzKHVpZCwgZmxhZ3MpLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5pbWFwLmRlbEZsYWdzKHVpZCwgZmxhZ3MsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIERlbGV0ZXMgdGhlIHNwZWNpZmllZCBtZXNzYWdlKHMpLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSB1aWQgVGhlIHVpZCBvciBhcnJheSBvZiB1aWRzIGluZGljYXRpbmcgdGhlIG1lc3NhZ2VzIHRvIGJlIGRlbGV0ZWRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gT3B0aW9uYWwgY2FsbGJhY2ssIHJlY2VpdmluZyBzaWduYXR1cmUgKGVycilcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR8UHJvbWlzZX0gUmV0dXJucyBhIHByb21pc2Ugd2hlbiBubyBjYWxsYmFjayBpcyBzcGVjaWZpZWQsIHJlc29sdmluZyB3aGVuIHRoZSBhY3Rpb24gc3VjY2VlZHMuXG4gKiBAbWVtYmVyb2YgSW1hcFNpbXBsZVxuICovXG5JbWFwU2ltcGxlLnByb3RvdHlwZS5kZWxldGVNZXNzYWdlID0gZnVuY3Rpb24gKHVpZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIG5vZGVpZnkoc2VsZi5kZWxldGVNZXNzYWdlKHVpZCksIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBzZWxmLmltYXAuYWRkRmxhZ3ModWlkLCAnXFxcXERlbGV0ZWQnLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5pbWFwLmV4cHVuZ2UoIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQXBwZW5kcyBhIG1pbWUtZW5jb2RlZCBtZXNzYWdlIHRvIGEgbWFpbGJveFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gbWVzc2FnZSBUaGUgbWVzc2FnZXMgdG8gYXBwZW5kIHRvIHRoZSBtYWlsYm94XG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubWFpbGJveF0gVGhlIG1haWxib3ggdG8gYXBwZW5kIHRoZSBtZXNzYWdlIHRvLlxuICBEZWZhdWx0cyB0byB0aGUgY3VycmVudGx5IG9wZW4gbWFpbGJveC5cbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5PFN0cmluZz59IFtvcHRpb25zLmZsYWddIEEgc2luZ2xlIGZsYWcgKGUuZy4gJ1NlZW4nKSBvciBhbiBhcnJheVxuICBvZiBmbGFncyAoZS5nLiBbJ1NlZW4nLCAnRmxhZ2dlZCddKSB0byBhcHBlbmQgdG8gdGhlIG1lc3NhZ2UuIERlZmF1bHRzIHRvXG4gIG5vIGZsYWdzLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBPcHRpb25hbCBjYWxsYmFjaywgcmVjZWl2aW5nIHNpZ25hdHVyZSAoZXJyKVxuICogQHJldHVybnMge3VuZGVmaW5lZHxQcm9taXNlfSBSZXR1cm5zIGEgcHJvbWlzZSB3aGVuIG5vIGNhbGxiYWNrIGlzIHNwZWNpZmllZCwgcmVzb2x2aW5nIHdoZW4gdGhlIGFjdGlvbiBzdWNjZWVkcy5cbiAqIEBtZW1iZXJvZiBJbWFwU2ltcGxlXG4gKi9cbkltYXBTaW1wbGUucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIChtZXNzYWdlLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gbm9kZWlmeShzZWxmLmFwcGVuZChtZXNzYWdlLCBvcHRpb25zKSwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNlbGYuaW1hcC5hcHBlbmQobWVzc2FnZSwgb3B0aW9ucywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGxpc3Qgb2YgbWFpbGJveGVzIChmb2xkZXJzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIE9wdGlvbmFsIGNhbGxiYWNrIGNvbnRhaW5pbmcgJ2JveGVzJyBvYmplY3QuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfFByb21pc2V9IFJldHVybnMgYSBwcm9taXNlIHdoZW4gbm8gY2FsbGJhY2sgaXMgc3BlY2lmaWVkLFxuICogIHJlc29sdmluZyB3aGVuIHRoZSBhY3Rpb24gc3VjY2VlZHMuXG4gKi9cblxuSW1hcFNpbXBsZS5wcm90b3R5cGUuZ2V0Qm94ZXMgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIG5vZGVpZnkoc2VsZi5nZXRCb3hlcygpLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5pbWFwLmdldEJveGVzKGZ1bmN0aW9uIChlcnIsIGJveGVzKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXNvbHZlKGJveGVzKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEFkZCBuZXcgbWFpbGJveCAoZm9sZGVyKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBib3hOYW1lIFRoZSBuYW1lIG9mIHRoZSBib3ggdG8gYWRkZWRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gT3B0aW9uYWwgY2FsbGJhY2ssIHJlY2VpdmluZyBzaWduYXR1cmUgKGVyciwgYm94TmFtZSlcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR8UHJvbWlzZX0gUmV0dXJucyBhIHByb21pc2Ugd2hlbiBubyBjYWxsYmFjayBpcyBzcGVjaWZpZWQsIHJlc29sdmluZyB0byBgYm94TmFtZWBcbiAqIEBtZW1iZXJvZiBJbWFwU2ltcGxlXG4gKi9cbkltYXBTaW1wbGUucHJvdG90eXBlLmFkZEJveCA9IGZ1bmN0aW9uIChib3hOYW1lLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gbm9kZWlmeSh0aGlzLmFkZEJveChib3hOYW1lKSwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cbiAgICAgICAgc2VsZi5pbWFwLmFkZEJveChib3hOYW1lLCBmdW5jdGlvbiAoZXJyKSB7XG5cbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc29sdmUoYm94TmFtZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBEZWxldGUgbWFpbGJveCAoZm9sZGVyKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBib3hOYW1lIFRoZSBuYW1lIG9mIHRoZSBib3ggdG8gZGVsZXRlZFxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBPcHRpb25hbCBjYWxsYmFjaywgcmVjZWl2aW5nIHNpZ25hdHVyZSAoZXJyLCBib3hOYW1lKVxuICogQHJldHVybnMge3VuZGVmaW5lZHxQcm9taXNlfSBSZXR1cm5zIGEgcHJvbWlzZSB3aGVuIG5vIGNhbGxiYWNrIGlzIHNwZWNpZmllZCwgcmVzb2x2aW5nIHRvIGBib3hOYW1lYFxuICogQG1lbWJlcm9mIEltYXBTaW1wbGVcbiAqL1xuSW1hcFNpbXBsZS5wcm90b3R5cGUuZGVsQm94ID0gZnVuY3Rpb24gKGJveE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBub2RlaWZ5KHRoaXMuZGVsQm94KGJveE5hbWUpLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblxuICAgICAgICBzZWxmLmltYXAuZGVsQm94KGJveE5hbWUsIGZ1bmN0aW9uIChlcnIpIHtcblxuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzb2x2ZShib3hOYW1lKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIENvbm5lY3QgdG8gYW4gSW1hcCBzZXJ2ZXIsIHJldHVybmluZyBhbiBJbWFwU2ltcGxlIGluc3RhbmNlLCB3aGljaCBpcyBhIHdyYXBwZXIgb3ZlciBub2RlLWltYXAgdG9cbiAqIHNpbXBsaWZ5IGl0J3MgYXBpIGZvciBjb21tb24gdXNlIGNhc2VzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5pbWFwIE9wdGlvbnMgdG8gcGFzcyB0byBub2RlLWltYXAgY29uc3RydWN0b3IgMToxXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIE9wdGlvbmFsIGNhbGxiYWNrLCByZWNlaXZpbmcgc2lnbmF0dXJlIChlcnIsIGNvbm5lY3Rpb24pXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfFByb21pc2V9IFJldHVybnMgYSBwcm9taXNlIHdoZW4gbm8gY2FsbGJhY2sgaXMgc3BlY2lmaWVkLCByZXNvbHZpbmcgdG8gYGNvbm5lY3Rpb25gXG4gKi9cbmZ1bmN0aW9uIGNvbm5lY3Qob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLmltYXAgPSBvcHRpb25zLmltYXAgfHwge307XG5cbiAgICAvLyBzdXBwb3J0IG9sZCBjb25uZWN0VGltZW91dCBjb25maWcgb3B0aW9uLiBSZW1vdmUgaW4gdjIuMC4wXG4gICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2Nvbm5lY3RUaW1lb3V0JykpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdbaW1hcC1zaW1wbGVdIGNvbm5lY3Q6IG9wdGlvbnMuY29ubmVjdFRpbWVvdXQgaXMgZGVwcmVjYXRlZC4gJyArXG4gICAgICAgICAgICAnUGxlYXNlIHVzZSBvcHRpb25zLmltYXAuYXV0aFRpbWVvdXQgaW5zdGVhZC4nKTtcbiAgICAgICAgb3B0aW9ucy5pbWFwLmF1dGhUaW1lb3V0ID0gb3B0aW9ucy5jb25uZWN0VGltZW91dDtcbiAgICB9XG5cbiAgICAvLyBzZXQgZGVmYXVsdCBhdXRoVGltZW91dFxuICAgIG9wdGlvbnMuaW1hcC5hdXRoVGltZW91dCA9IG9wdGlvbnMuaW1hcC5oYXNPd25Qcm9wZXJ0eSgnYXV0aFRpbWVvdXQnKSA/IG9wdGlvbnMuaW1hcC5hdXRoVGltZW91dCA6IDIwMDA7XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIG5vZGVpZnkoY29ubmVjdChvcHRpb25zKSwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBpbWFwID0gbmV3IEltYXAob3B0aW9ucy5pbWFwKTtcblxuICAgICAgICBmdW5jdGlvbiBpbWFwT25SZWFkeSgpIHtcbiAgICAgICAgICAgIGltYXAucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgaW1hcE9uRXJyb3IpO1xuICAgICAgICAgICAgaW1hcC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBpbWFwT25DbG9zZSk7XG4gICAgICAgICAgICBpbWFwLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBpbWFwT25FbmQpO1xuICAgICAgICAgICAgcmVzb2x2ZShuZXcgSW1hcFNpbXBsZShpbWFwKSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbWFwT25FcnJvcihlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIuc291cmNlID09PSAndGltZW91dC1hdXRoJykge1xuICAgICAgICAgICAgICAgIGVyciA9IG5ldyBlcnJvcnMuQ29ubmVjdGlvblRpbWVvdXRFcnJvcihvcHRpb25zLmltYXAuYXV0aFRpbWVvdXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbWFwLnJlbW92ZUxpc3RlbmVyKCdyZWFkeScsIGltYXBPblJlYWR5KTtcbiAgICAgICAgICAgIGltYXAucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgaW1hcE9uQ2xvc2UpO1xuICAgICAgICAgICAgaW1hcC5yZW1vdmVMaXN0ZW5lcignZW5kJywgaW1hcE9uRW5kKTtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW1hcE9uRW5kKCkge1xuICAgICAgICAgICAgaW1hcC5yZW1vdmVMaXN0ZW5lcigncmVhZHknLCBpbWFwT25SZWFkeSk7XG4gICAgICAgICAgICBpbWFwLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGltYXBPbkVycm9yKTtcbiAgICAgICAgICAgIGltYXAucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgaW1hcE9uQ2xvc2UpO1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignQ29ubmVjdGlvbiBlbmRlZCB1bmV4cGVjdGVkbHknKSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbWFwT25DbG9zZSgpIHtcbiAgICAgICAgICAgIGltYXAucmVtb3ZlTGlzdGVuZXIoJ3JlYWR5JywgaW1hcE9uUmVhZHkpO1xuICAgICAgICAgICAgaW1hcC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBpbWFwT25FcnJvcik7XG4gICAgICAgICAgICBpbWFwLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBpbWFwT25FbmQpO1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignQ29ubmVjdGlvbiBjbG9zZWQgdW5leHBlY3RlZGx5JykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW1hcC5vbmNlKCdyZWFkeScsIGltYXBPblJlYWR5KTtcbiAgICAgICAgaW1hcC5vbmNlKCdlcnJvcicsIGltYXBPbkVycm9yKTtcbiAgICAgICAgaW1hcC5vbmNlKCdjbG9zZScsIGltYXBPbkNsb3NlKTtcbiAgICAgICAgaW1hcC5vbmNlKCdlbmQnLCBpbWFwT25FbmQpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KCdvbm1haWwnKSkge1xuICAgICAgICAgICAgaW1hcC5vbignbWFpbCcsIG9wdGlvbnMub25tYWlsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KCdvbmV4cHVuZ2UnKSkge1xuICAgICAgICAgICAgaW1hcC5vbignZXhwdW5nZScsIG9wdGlvbnMub25leHB1bmdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KCdvbnVwZGF0ZScpKSB7XG4gICAgICAgICAgICBpbWFwLm9uKCd1cGRhdGUnLCBvcHRpb25zLm9udXBkYXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGltYXAuY29ubmVjdCgpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEdpdmVuIHRoZSBgbWVzc2FnZS5hdHRyaWJ1dGVzLnN0cnVjdGAsIHJldHJpZXZlIGEgZmxhdHRlbmVkIGFycmF5IG9mIGBwYXJ0c2Agb2JqZWN0cyB0aGF0IGRlc2NyaWJlIHRoZSBzdHJ1Y3R1cmUgb2ZcbiAqIHRoZSBkaWZmZXJlbnQgcGFydHMgb2YgdGhlIG1lc3NhZ2UncyBib2R5LiBVc2VmdWwgZm9yIGdldHRpbmcgYSBzaW1wbGUgbGlzdCB0byBpdGVyYXRlIGZvciB0aGUgcHVycG9zZXMgb2YsXG4gKiBmb3IgZXhhbXBsZSwgZmluZGluZyBhbGwgYXR0YWNobWVudHMuXG4gKlxuICogQ29kZSB0YWtlbiBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjUyNDcyMDcvaG93LXRvLXJlYWQtYW5kLXNhdmUtYXR0YWNobWVudHMtdXNpbmctbm9kZS1pbWFwXG4gKlxuICogQHBhcmFtIHtBcnJheX0gc3RydWN0IFRoZSBgbWVzc2FnZS5hdHRyaWJ1dGVzLnN0cnVjdGAgdmFsdWUgZnJvbSB0aGUgbWVzc2FnZSB5b3Ugd2lzaCB0byByZXRyaWV2ZSBwYXJ0cyBmb3IuXG4gKiBAcGFyYW0ge0FycmF5fSBbcGFydHNdIFRoZSBsaXN0IG9mIHBhcnRzIHRvIHB1c2ggdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IGEgZmxhdHRlbmVkIGFycmF5IG9mIGBwYXJ0c2Agb2JqZWN0cyB0aGF0IGRlc2NyaWJlIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGRpZmZlcmVudCBwYXJ0cyBvZiB0aGVcbiAqICBtZXNzYWdlJ3MgYm9keVxuICovXG5mdW5jdGlvbiBnZXRQYXJ0cyhzdHJ1Y3QsIHBhcnRzKSB7XG4gICAgcGFydHMgPSBwYXJ0cyB8fCBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cnVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzdHJ1Y3RbaV0pKSB7XG4gICAgICAgICAgICBnZXRQYXJ0cyhzdHJ1Y3RbaV0sIHBhcnRzKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJ1Y3RbaV0ucGFydElEKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHN0cnVjdFtpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBjb25uZWN0OiBjb25uZWN0LFxuICAgIEltYXBTaW1wbGU6IEltYXBTaW1wbGUsXG4gICAgcGFyc2VIZWFkZXI6IEltYXAucGFyc2VIZWFkZXIsXG4gICAgZ2V0UGFydHM6IGdldFBhcnRzLFxuICAgIGVycm9yczogZXJyb3JzXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/imap-simple/lib/imapSimple.js\n");

/***/ })

};
;