"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mailparser";
exports.ids = ["vendor-chunks/mailparser"];
exports.modules = {

/***/ "(rsc)/../node_modules/mailparser/index.js":
/*!*******************************************!*\
  !*** ../node_modules/mailparser/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst MailParser = __webpack_require__(/*! ./lib/mail-parser */ \"(rsc)/../node_modules/mailparser/lib/mail-parser.js\");\nconst simpleParser = __webpack_require__(/*! ./lib/simple-parser */ \"(rsc)/../node_modules/mailparser/lib/simple-parser.js\");\n\nmodule.exports = {\n    MailParser,\n    simpleParser\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL21haWxwYXJzZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsbUJBQW1CLG1CQUFPLENBQUMsOEVBQW1CO0FBQzlDLHFCQUFxQixtQkFBTyxDQUFDLGtGQUFxQjs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xca2ZyeXRcXC5nZW1pbmlcXGFudGlncmF2aXR5XFxzY3JhdGNoXFxkcl9rYWxzX3ZpcnR1YWxfaG9zcGl0YWxcXG5vZGVfbW9kdWxlc1xcbWFpbHBhcnNlclxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNYWlsUGFyc2VyID0gcmVxdWlyZSgnLi9saWIvbWFpbC1wYXJzZXInKTtcbmNvbnN0IHNpbXBsZVBhcnNlciA9IHJlcXVpcmUoJy4vbGliL3NpbXBsZS1wYXJzZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgTWFpbFBhcnNlcixcbiAgICBzaW1wbGVQYXJzZXJcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/mailparser/index.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/mailparser/lib/mail-parser.js":
/*!*****************************************************!*\
  !*** ../node_modules/mailparser/lib/mail-parser.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst mailsplit = __webpack_require__(/*! @zone-eu/mailsplit */ \"(rsc)/../node_modules/@zone-eu/mailsplit/index.js\");\nconst libmime = __webpack_require__(/*! libmime */ \"(rsc)/../node_modules/libmime/lib/libmime.js\");\nconst addressparser = __webpack_require__(/*! nodemailer/lib/addressparser */ \"(rsc)/../node_modules/mailparser/node_modules/nodemailer/lib/addressparser/index.js\");\nconst Transform = (__webpack_require__(/*! stream */ \"stream\").Transform);\nconst Splitter = mailsplit.Splitter;\nconst ChunkedPassthrough = mailsplit.ChunkedPassthrough;\nconst punycode = __webpack_require__(/*! punycode.js */ \"(rsc)/../node_modules/punycode.js/punycode.es6.js\");\nconst FlowedDecoder = __webpack_require__(/*! @zone-eu/mailsplit/lib/flowed-decoder */ \"(rsc)/../node_modules/@zone-eu/mailsplit/lib/flowed-decoder.js\");\nconst StreamHash = __webpack_require__(/*! ./stream-hash */ \"(rsc)/../node_modules/mailparser/lib/stream-hash.js\");\nconst iconv = __webpack_require__(/*! iconv-lite */ \"(rsc)/../node_modules/mailparser/node_modules/iconv-lite/lib/index.js\");\nconst { htmlToText } = __webpack_require__(/*! html-to-text */ \"(rsc)/../node_modules/html-to-text/lib/html-to-text.cjs\");\nconst he = __webpack_require__(/*! he */ \"(rsc)/../node_modules/he/he.js\");\nconst linkify = __webpack_require__(/*! linkify-it */ \"(rsc)/../node_modules/linkify-it/build/index.cjs.js\")();\nconst tlds = __webpack_require__(/*! tlds */ \"(rsc)/../node_modules/tlds/index.json\");\nconst encodingJapanese = __webpack_require__(/*! encoding-japanese */ \"(rsc)/../node_modules/encoding-japanese/src/index.js\");\n\nlinkify\n    .tlds(tlds) // Reload with full tlds list\n    .tlds('onion', true) // Add unofficial `.onion` domain\n    .add('git:', 'http:') // Add `git:` ptotocol as \"alias\"\n    .add('ftp:', null) // Disable `ftp:` ptotocol\n    .set({ fuzzyIP: true, fuzzyLink: true, fuzzyEmail: true });\n\n// twitter linkifier from\n// https://github.com/markdown-it/linkify-it#example-2-add-twitter-mentions-handler\nlinkify.add('@', {\n    validate(text, pos, self) {\n        let tail = text.slice(pos);\n\n        if (!self.re.twitter) {\n            self.re.twitter = new RegExp('^([a-zA-Z0-9_]){1,15}(?!_)(?=$|' + self.re.src_ZPCc + ')');\n        }\n        if (self.re.twitter.test(tail)) {\n            // Linkifier allows punctuation chars before prefix,\n            // but we additionally disable `@` (\"@@mention\" is invalid)\n            if (pos >= 2 && tail[pos - 2] === '@') {\n                return false;\n            }\n            return tail.match(self.re.twitter)[0].length;\n        }\n        return 0;\n    },\n    normalize(match) {\n        match.url = 'https://twitter.com/' + match.url.replace(/^@/, '');\n    }\n});\n\nclass IconvDecoder extends Transform {\n    constructor(Iconv, charset) {\n        super();\n\n        // Iconv throws error on ks_c_5601-1987 when it is mapped to EUC-KR\n        // https://github.com/bnoordhuis/node-iconv/issues/169\n        if (charset.toLowerCase() === 'ks_c_5601-1987') {\n            charset = 'CP949';\n        }\n        this.stream = new Iconv(charset, 'UTF-8//TRANSLIT//IGNORE');\n\n        this.inputEnded = false;\n        this.endCb = false;\n\n        this.stream.on('error', err => this.emit('error', err));\n        this.stream.on('data', chunk => this.push(chunk));\n        this.stream.on('end', () => {\n            this.inputEnded = true;\n            if (typeof this.endCb === 'function') {\n                this.endCb();\n            }\n        });\n    }\n\n    _transform(chunk, encoding, done) {\n        this.stream.write(chunk);\n        done();\n    }\n\n    _flush(done) {\n        this.endCb = done;\n        this.stream.end();\n    }\n}\n\nclass JPDecoder extends Transform {\n    constructor(charset) {\n        super();\n\n        this.charset = charset;\n        this.chunks = [];\n        this.chunklen = 0;\n    }\n\n    _transform(chunk, encoding, done) {\n        if (typeof chunk === 'string') {\n            chunk = Buffer.from(chunk, encoding);\n        }\n\n        this.chunks.push(chunk);\n        this.chunklen += chunk.length;\n        done();\n    }\n\n    _flush(done) {\n        let input = Buffer.concat(this.chunks, this.chunklen);\n        try {\n            let output = encodingJapanese.convert(input, {\n                to: 'UNICODE', // to_encoding\n                from: this.charset, // from_encoding\n                type: 'string'\n            });\n            if (typeof output === 'string') {\n                output = Buffer.from(output);\n            }\n            this.push(output);\n        } catch (err) {\n            // keep as is on errors\n            this.push(input);\n        }\n\n        done();\n    }\n}\n\nclass MailParser extends Transform {\n    constructor(config) {\n        super({\n            readableObjectMode: true,\n            writableObjectMode: false\n        });\n\n        this.options = config || {};\n        this.chunkedPassthrough = new ChunkedPassthrough();\n        this.splitter = new Splitter(config);\n\n        this.chunkedPassthrough.pipe(this.splitter);\n\n        this.finished = false;\n        this.waitingEnd = false;\n\n        this.headers = false;\n        this.headerLines = false;\n\n        this.endReceived = false;\n        this.reading = false;\n        this.hasFailed = false;\n\n        this.tree = false;\n        this.curnode = false;\n        this.waitUntilAttachmentEnd = false;\n        this.attachmentCallback = false;\n\n        this.hasHtml = false;\n        this.hasText = false;\n\n        this.text = false;\n        this.html = false;\n        this.textAsHtml = false;\n\n        this.attachmentList = [];\n\n        this.boundaries = [];\n\n        this.textTypes = ['text/plain', 'text/html'].concat(!this.options.keepDeliveryStatus ? 'message/delivery-status' : []);\n\n        this.decoder = this.getDecoder();\n\n        this.chunkedPassthrough.on('error', err => {\n            this.splitter.emit('error', err);\n        });\n\n        this.splitter.on('readable', () => {\n            if (this.reading) {\n                return false;\n            }\n            this.readData();\n        });\n\n        this.splitter.on('end', () => {\n            this.endReceived = true;\n            if (!this.reading) {\n                this.endStream();\n            }\n        });\n\n        this.splitter.on('error', err => {\n            this.hasFailed = true;\n            if (typeof this.waitingEnd === 'function') {\n                return this.waitingEnd(err);\n            }\n            this.emit('error', err);\n        });\n\n        this.libmime = new libmime.Libmime({ Iconv: this.options.Iconv });\n    }\n\n    getDecoder() {\n        if (this.options.Iconv) {\n            const Iconv = this.options.Iconv;\n            // create wrapper\n            return {\n                decodeStream(charset) {\n                    return new IconvDecoder(Iconv, charset);\n                }\n            };\n        } else {\n            return {\n                decodeStream(charset) {\n                    charset = (charset || 'ascii').toString().trim().toLowerCase();\n                    if (/^jis|^iso-?2022-?jp|^EUCJP/i.test(charset)) {\n                        // special case not supported by iconv-lite\n                        return new JPDecoder(charset);\n                    }\n\n                    return iconv.decodeStream(charset);\n                }\n            };\n        }\n    }\n\n    readData() {\n        if (this.hasFailed) {\n            return false;\n        }\n        this.reading = true;\n        let data = this.splitter.read();\n        if (data === null) {\n            this.reading = false;\n            if (this.endReceived) {\n                this.endStream();\n            }\n            return;\n        }\n\n        this.processChunk(data, err => {\n            if (err) {\n                if (typeof this.waitingEnd === 'function') {\n                    return this.waitingEnd(err);\n                }\n                return this.emit('error', err);\n            }\n            setImmediate(() => this.readData());\n        });\n    }\n\n    endStream() {\n        this.finished = true;\n\n        if (this.curnode && this.curnode.decoder) {\n            this.curnode.decoder.end();\n        }\n        if (typeof this.waitingEnd === 'function') {\n            this.waitingEnd();\n        }\n    }\n\n    _transform(chunk, encoding, done) {\n        if (!chunk || !chunk.length) {\n            return done();\n        }\n\n        if (this.chunkedPassthrough.write(chunk) === false) {\n            return this.chunkedPassthrough.once('drain', () => {\n                done();\n            });\n        } else {\n            return done();\n        }\n    }\n\n    _flush(done) {\n        setImmediate(() => this.chunkedPassthrough.end());\n        if (this.finished) {\n            return this.cleanup(done);\n        }\n        this.waitingEnd = () => {\n            this.cleanup(() => {\n                done();\n            });\n        };\n    }\n\n    cleanup(done) {\n        let finish = () => {\n            try {\n                let t = this.getTextContent();\n                this.push(t);\n            } catch (err) {\n                return this.emit('error', err);\n            }\n\n            done();\n        };\n\n        if (this.curnode && this.curnode.decoder && this.curnode.decoder.readable && !this.decoderEnded) {\n            (this.curnode.contentStream || this.curnode.decoder).once('end', () => {\n                finish();\n            });\n            this.curnode.decoder.end();\n        } else {\n            setImmediate(() => {\n                finish();\n            });\n        }\n    }\n\n    processHeaders(lines) {\n        let headers = new Map();\n        (lines || []).forEach(line => {\n            let key = line.key;\n            let value = ((this.libmime.decodeHeader(line.line) || {}).value || '').toString().trim();\n            value = Buffer.from(value, 'binary').toString();\n            switch (key) {\n                case 'content-type':\n                case 'content-disposition':\n                case 'dkim-signature':\n                    value = this.libmime.parseHeaderValue(value);\n                    if (value.value) {\n                        value.value = this.libmime.decodeWords(value.value);\n                    }\n                    Object.keys((value && value.params) || {}).forEach(key => {\n                        try {\n                            value.params[key] = this.libmime.decodeWords(value.params[key]);\n                        } catch (E) {\n                            // ignore, keep as is\n                        }\n                    });\n                    break;\n                case 'date': {\n                    let dateValue = new Date(value);\n                    if (isNaN(dateValue)) {\n                        // date parsing failed :S\n                        dateValue = new Date();\n                    }\n                    value = dateValue;\n                    break;\n                }\n                case 'subject':\n                    try {\n                        value = this.libmime.decodeWords(value);\n                    } catch (E) {\n                        // ignore, keep as is\n                    }\n                    break;\n                case 'references':\n                    try {\n                        value = this.libmime.decodeWords(value);\n                    } catch (E) {\n                        // ignore\n                    }\n                    value = value.split(/\\s+/).map(this.ensureMessageIDFormat);\n                    break;\n                case 'message-id':\n                case 'in-reply-to':\n                    try {\n                        value = this.libmime.decodeWords(value);\n                    } catch (E) {\n                        // ignore\n                    }\n                    value = this.ensureMessageIDFormat(value);\n                    break;\n                case 'priority':\n                case 'x-priority':\n                case 'x-msmail-priority':\n                case 'importance':\n                    key = 'priority';\n                    value = this.parsePriority(value);\n                    break;\n                case 'from':\n                case 'to':\n                case 'cc':\n                case 'bcc':\n                case 'sender':\n                case 'reply-to':\n                case 'delivered-to':\n                case 'return-path':\n                case 'disposition-notification-to':\n                    value = addressparser(value);\n                    this.decodeAddresses(value);\n                    value = {\n                        value,\n                        html: this.getAddressesHTML(value),\n                        text: this.getAddressesText(value)\n                    };\n                    break;\n            }\n\n            // handle list-* keys\n            if (key.substr(0, 5) === 'list-') {\n                value = this.parseListHeader(key.substr(5), value);\n                key = 'list';\n            }\n\n            if (value) {\n                if (!headers.has(key)) {\n                    headers.set(key, [].concat(value || []));\n                } else if (Array.isArray(value)) {\n                    headers.set(key, headers.get(key).concat(value));\n                } else {\n                    headers.get(key).push(value);\n                }\n            }\n        });\n\n        // keep only the first value\n        let singleKeys = [\n            'message-id',\n            'content-id',\n            'from',\n            'sender',\n            'in-reply-to',\n            'reply-to',\n            'subject',\n            'date',\n            'content-disposition',\n            'content-type',\n            'content-transfer-encoding',\n            'priority',\n            'mime-version',\n            'content-description',\n            'precedence',\n            'errors-to',\n            'disposition-notification-to'\n        ];\n\n        headers.forEach((value, key) => {\n            if (Array.isArray(value)) {\n                if (singleKeys.includes(key) && value.length) {\n                    headers.set(key, value[value.length - 1]);\n                } else if (value.length === 1) {\n                    headers.set(key, value[0]);\n                }\n            }\n\n            if (key === 'list') {\n                // normalize List-* headers\n                let listValue = {};\n                [].concat(value || []).forEach(val => {\n                    Object.keys(val || {}).forEach(listKey => {\n                        listValue[listKey] = val[listKey];\n                    });\n                });\n                headers.set(key, listValue);\n            }\n        });\n\n        return headers;\n    }\n\n    parseListHeader(key, value) {\n        let addresses = addressparser(value);\n        let response = {};\n        let data = addresses\n            .map(address => {\n                if (/^https?:/i.test(address.name)) {\n                    response.url = address.name;\n                } else if (address.name) {\n                    response.name = address.name;\n                }\n                if (/^mailto:/.test(address.address)) {\n                    response.mail = address.address.substr(7);\n                } else if (address.address && address.address.indexOf('@') < 0) {\n                    response.id = address.address;\n                } else if (address.address) {\n                    response.mail = address.address;\n                }\n                if (Object.keys(response).length) {\n                    return response;\n                }\n                return false;\n            })\n            .filter(address => address);\n        if (data.length) {\n            return {\n                [key]: response\n            };\n        }\n        return false;\n    }\n\n    parsePriority(value) {\n        value = value.toLowerCase().trim();\n        if (!isNaN(parseInt(value, 10))) {\n            // support \"X-Priority: 1 (Highest)\"\n            value = parseInt(value, 10) || 0;\n            if (value === 3) {\n                return 'normal';\n            } else if (value > 3) {\n                return 'low';\n            } else {\n                return 'high';\n            }\n        } else {\n            switch (value) {\n                case 'non-urgent':\n                case 'low':\n                    return 'low';\n                case 'urgent':\n                case 'high':\n                    return 'high';\n            }\n        }\n        return 'normal';\n    }\n\n    ensureMessageIDFormat(value) {\n        if (!value.length) {\n            return false;\n        }\n\n        if (value.charAt(0) !== '<') {\n            value = '<' + value;\n        }\n\n        if (value.charAt(value.length - 1) !== '>') {\n            value += '>';\n        }\n\n        return value;\n    }\n\n    decodeAddresses(addresses) {\n        let processedAddress = new WeakSet();\n        for (let i = 0; i < addresses.length; i++) {\n            let address = addresses[i];\n            address.name = (address.name || '').toString().trim();\n\n            if (!address.address && /^(=\\?([^?]+)\\?[Bb]\\?[^?]*\\?=)(\\s*=\\?([^?]+)\\?[Bb]\\?[^?]*\\?=)*$/.test(address.name) && !processedAddress.has(address)) {\n                let parsed = addressparser(this.libmime.decodeWords(address.name));\n                if (parsed.length) {\n                    parsed.forEach(entry => {\n                        processedAddress.add(entry);\n                        addresses.push(entry);\n                    });\n                }\n\n                // remove current element\n                addresses.splice(i, 1);\n                i--;\n                continue;\n            }\n\n            if (address.name) {\n                try {\n                    address.name = this.libmime.decodeWords(address.name);\n                } catch (E) {\n                    //ignore, keep as is\n                }\n            }\n            if (/@xn--/.test(address.address)) {\n                try {\n                    address.address =\n                        address.address.substr(0, address.address.lastIndexOf('@') + 1) +\n                        punycode.toUnicode(address.address.substr(address.address.lastIndexOf('@') + 1));\n                } catch (E) {\n                    // Not a valid punycode string; keep as is\n                }\n            }\n            if (address.group) {\n                this.decodeAddresses(address.group);\n            }\n        }\n    }\n\n    createNode(node) {\n        let contentType = node.contentType;\n        let disposition = node.disposition;\n        let encoding = node.encoding;\n        let charset = node.charset;\n\n        if (!contentType && node.root) {\n            contentType = 'text/plain';\n        }\n\n        let newNode = {\n            node,\n            headerLines: node.headers.lines,\n            headers: this.processHeaders(node.headers.getList()),\n            contentType,\n            children: []\n        };\n\n        if (!/^multipart\\//i.test(contentType)) {\n            if (disposition && !['attachment', 'inline'].includes(disposition)) {\n                disposition = 'attachment';\n            }\n\n            if (!disposition && !this.textTypes.includes(contentType)) {\n                newNode.disposition = 'attachment';\n            } else {\n                newNode.disposition = disposition || 'inline';\n            }\n\n            newNode.isAttachment = !this.textTypes.includes(contentType) || newNode.disposition !== 'inline';\n\n            newNode.encoding = ['quoted-printable', 'base64'].includes(encoding) ? encoding : 'binary';\n\n            if (charset) {\n                newNode.charset = charset;\n            }\n\n            let decoder = node.getDecoder();\n            decoder.on('end', () => {\n                this.decoderEnded = true;\n            });\n            newNode.decoder = decoder;\n        }\n\n        if (node.root) {\n            this.headers = newNode.headers;\n            this.headerLines = newNode.headerLines;\n        }\n\n        // find location in tree\n\n        if (!this.tree) {\n            newNode.root = true;\n            this.curnode = this.tree = newNode;\n            return newNode;\n        }\n\n        // immediate child of root node\n        if (!this.curnode.parent) {\n            newNode.parent = this.curnode;\n            this.curnode.children.push(newNode);\n            this.curnode = newNode;\n            return newNode;\n        }\n\n        // siblings\n        if (this.curnode.parent.node === node.parentNode) {\n            newNode.parent = this.curnode.parent;\n            this.curnode.parent.children.push(newNode);\n            this.curnode = newNode;\n            return newNode;\n        }\n\n        // first child\n        if (this.curnode.node === node.parentNode) {\n            newNode.parent = this.curnode;\n            this.curnode.children.push(newNode);\n            this.curnode = newNode;\n            return newNode;\n        }\n\n        // move up\n        let parentNode = this.curnode;\n        while ((parentNode = parentNode.parent)) {\n            if (parentNode.node === node.parentNode) {\n                newNode.parent = parentNode;\n                parentNode.children.push(newNode);\n                this.curnode = newNode;\n                return newNode;\n            }\n        }\n\n        // should never happen, can't detect parent\n        this.curnode = newNode;\n        return newNode;\n    }\n\n    getTextContent() {\n        let text = [];\n        let html = [];\n        let processNode = (alternative, level, node) => {\n            if (node.showMeta) {\n                let meta = ['From', 'Subject', 'Date', 'To', 'Cc', 'Bcc']\n                    .map(fkey => {\n                        let key = fkey.toLowerCase();\n                        if (!node.headers.has(key)) {\n                            return false;\n                        }\n                        let value = node.headers.get(key);\n                        if (!value) {\n                            return false;\n                        }\n                        return {\n                            key: fkey,\n                            value: Array.isArray(value) ? value[value.length - 1] : value\n                        };\n                    })\n                    .filter(entry => entry);\n                if (this.hasHtml) {\n                    html.push(\n                        '<table class=\"mp_head\">' +\n                            meta\n                                .map(entry => {\n                                    let value = entry.value;\n                                    switch (entry.key) {\n                                        case 'From':\n                                        case 'To':\n                                        case 'Cc':\n                                        case 'Bcc':\n                                            value = value.html;\n                                            break;\n                                        case 'Date':\n                                            value = this.options.formatDateString ? this.options.formatDateString(value) : value.toUTCString();\n                                            break;\n                                        case 'Subject':\n                                            value = '<strong>' + he.encode(value) + '</strong>';\n                                            break;\n                                        default:\n                                            value = he.encode(value);\n                                    }\n\n                                    return '<tr><td class=\"mp_head_key\">' + he.encode(entry.key) + ':</td><td class=\"mp_head_value\">' + value + '<td></tr>';\n                                })\n                                .join('\\n') +\n                            '<table>'\n                    );\n                }\n                if (this.hasText) {\n                    text.push(\n                        '\\n' +\n                            meta\n                                .map(entry => {\n                                    let value = entry.value;\n                                    switch (entry.key) {\n                                        case 'From':\n                                        case 'To':\n                                        case 'Cc':\n                                        case 'Bcc':\n                                            value = value.text;\n                                            break;\n                                        case 'Date':\n                                            value = this.options.formatDateString ? this.options.formatDateString(value) : value.toUTCString();\n                                            break;\n                                    }\n                                    return entry.key + ': ' + value;\n                                })\n                                .join('\\n') +\n                            '\\n'\n                    );\n                }\n            }\n            if (node.textContent) {\n                if (node.contentType === 'text/plain') {\n                    text.push(node.textContent);\n                    if (!alternative && this.hasHtml) {\n                        html.push(this.textToHtml(node.textContent));\n                    }\n                } else if (node.contentType === 'message/delivery-status' && !this.options.keepDeliveryStatus) {\n                    text.push(node.textContent);\n                    if (!alternative && this.hasHtml) {\n                        html.push(this.textToHtml(node.textContent));\n                    }\n                } else if (node.contentType === 'text/html') {\n                    let failedToParseHtml = false;\n                    if ((!alternative && this.hasText) || (node.root && !this.hasText)) {\n                        if (this.options.skipHtmlToText) {\n                            text.push('');\n                        } else if (node.textContent.length > this.options.maxHtmlLengthToParse) {\n                            this.emit('error', new Error(`HTML too long for parsing ${node.textContent.length} bytes`));\n                            text.push('Invalid HTML content (too long)');\n                            failedToParseHtml = true;\n                        } else {\n                            try {\n                                text.push(htmlToText(node.textContent));\n                            } catch (err) {\n                                this.emit('error', new Error('Failed to parse HTML'));\n                                text.push('Invalid HTML content');\n                                failedToParseHtml = true;\n                            }\n                        }\n                    }\n                    if (!failedToParseHtml) {\n                        html.push(node.textContent);\n                    }\n                }\n            }\n            alternative = alternative || node.contentType === 'multipart/alternative';\n            if (node.children) {\n                node.children.forEach(subNode => {\n                    processNode(alternative, level + 1, subNode);\n                });\n            }\n        };\n\n        processNode(false, 0, this.tree);\n\n        let response = {\n            type: 'text'\n        };\n        if (html.length) {\n            this.html = response.html = html.join('<br/>\\n');\n        }\n        if (text.length) {\n            this.text = response.text = text.join('\\n');\n            this.textAsHtml = response.textAsHtml = text.map(part => this.textToHtml(part)).join('<br/>\\n');\n        }\n        return response;\n    }\n\n    processChunk(data, done) {\n        let partId = null;\n        if (data._parentBoundary) {\n            partId = this._getPartId(data._parentBoundary);\n        }\n        switch (data.type) {\n            case 'node': {\n                let node = this.createNode(data);\n                if (node === this.tree) {\n                    ['subject', 'references', 'date', 'to', 'from', 'to', 'cc', 'bcc', 'message-id', 'in-reply-to', 'reply-to'].forEach(key => {\n                        if (node.headers.has(key)) {\n                            this[key.replace(/-([a-z])/g, (m, c) => c.toUpperCase())] = node.headers.get(key);\n                        }\n                    });\n                    this.emit('headers', node.headers);\n\n                    if (node.headerLines) {\n                        this.emit('headerLines', node.headerLines);\n                    }\n                }\n\n                if (data.contentType === 'message/rfc822' && data.messageNode) {\n                    break;\n                }\n\n                if (data.parentNode && data.parentNode.contentType === 'message/rfc822') {\n                    node.showMeta = true;\n                }\n\n                if (node.isAttachment) {\n                    let contentType = node.contentType;\n                    if (node.contentType === 'application/octet-stream' && data.filename) {\n                        contentType = this.libmime.detectMimeType(data.filename) || 'application/octet-stream';\n                    }\n\n                    let attachment = {\n                        type: 'attachment',\n                        content: null,\n                        contentType,\n                        partId,\n                        release: () => {\n                            attachment.release = null;\n                            if (this.waitUntilAttachmentEnd && typeof this.attachmentCallback === 'function') {\n                                setImmediate(this.attachmentCallback);\n                            }\n                            this.attachmentCallback = false;\n                            this.waitUntilAttachmentEnd = false;\n                        }\n                    };\n\n                    let algo = this.options.checksumAlgo || 'md5';\n                    let hasher = new StreamHash(attachment, algo);\n                    node.decoder.on('error', err => {\n                        hasher.emit('error', err);\n                    });\n\n                    node.decoder.on('readable', () => {\n                        let chunk;\n\n                        while ((chunk = node.decoder.read()) !== null) {\n                            hasher.write(chunk);\n                        }\n                    });\n\n                    node.decoder.once('end', () => {\n                        hasher.end();\n                    });\n\n                    //node.decoder.pipe(hasher);\n                    attachment.content = hasher;\n\n                    this.waitUntilAttachmentEnd = true;\n                    if (data.disposition) {\n                        attachment.contentDisposition = data.disposition;\n                    }\n\n                    if (data.filename) {\n                        attachment.filename = data.filename;\n                    }\n\n                    if (node.headers.has('content-id')) {\n                        attachment.contentId = [].concat(node.headers.get('content-id') || []).shift();\n                        attachment.cid = attachment.contentId.trim().replace(/^<|>$/g, '').trim();\n                        // check if the attachment is \"related\" to text content like an embedded image etc\n                        let parentNode = node;\n                        while ((parentNode = parentNode.parent)) {\n                            if (parentNode.contentType === 'multipart/related') {\n                                attachment.related = true;\n                            }\n                        }\n                    }\n\n                    attachment.headers = node.headers;\n                    this.push(attachment);\n                    this.attachmentList.push(attachment);\n                } else if (node.disposition === 'inline') {\n                    let chunks = [];\n                    let chunklen = 0;\n                    node.contentStream = node.decoder;\n\n                    if (node.contentType === 'text/plain') {\n                        this.hasText = true;\n                    } else if (node.contentType === 'text/html') {\n                        this.hasHtml = true;\n                    } else if (node.contentType === 'message/delivery-status' && !this.options.keepDeliveryStatus) {\n                        this.hasText = true;\n                    }\n\n                    if (node.node.flowed) {\n                        let contentStream = node.contentStream;\n                        let flowDecoder = new FlowedDecoder({\n                            delSp: node.node.delSp\n                        });\n                        contentStream.on('error', err => {\n                            flowDecoder.emit('error', err);\n                        });\n                        contentStream.pipe(flowDecoder);\n                        node.contentStream = flowDecoder;\n                    }\n\n                    let charset = node.charset || 'utf-8';\n                    //charset = charset || 'windows-1257';\n\n                    if (!['ascii', 'usascii', 'utf8'].includes(charset.toLowerCase().replace(/[^a-z0-9]+/g, ''))) {\n                        try {\n                            let contentStream = node.contentStream;\n                            let decodeStream = this.decoder.decodeStream(charset);\n                            contentStream.on('error', err => {\n                                decodeStream.emit('error', err);\n                            });\n                            contentStream.pipe(decodeStream);\n                            node.contentStream = decodeStream;\n                        } catch (E) {\n                            // do not decode charset\n                        }\n                    }\n\n                    node.contentStream.on('readable', () => {\n                        let chunk;\n                        while ((chunk = node.contentStream.read()) !== null) {\n                            if (typeof chunk === 'string') {\n                                chunk = Buffer.from(chunk);\n                            }\n                            chunks.push(chunk);\n                            chunklen += chunk.length;\n                        }\n                    });\n\n                    node.contentStream.once('end', () => {\n                        node.textContent = Buffer.concat(chunks, chunklen).toString().replace(/\\r?\\n/g, '\\n');\n                    });\n\n                    node.contentStream.once('error', err => {\n                        this.emit('error', err);\n                    });\n                }\n\n                break;\n            }\n\n            case 'data':\n                if (this.curnode && this.curnode.decoder) {\n                    this.curnode.decoder.end();\n                }\n\n                if (this.waitUntilAttachmentEnd) {\n                    this.attachmentCallback = done;\n                    return;\n                }\n\n                // multipart message structure\n                // this is not related to any specific 'node' block as it includes\n                // everything between the end of some node body and between the next header\n                //process.stdout.write(data.value);\n                break;\n\n            case 'body':\n                if (this.curnode && this.curnode.decoder && this.curnode.decoder.writable) {\n                    if (this.curnode.decoder.write(data.value) === false) {\n                        return this.curnode.decoder.once('drain', done);\n                    }\n                }\n\n                // Leaf element body. Includes the body for the last 'node' block. You might\n                // have several 'body' calls for a single 'node' block\n                //process.stdout.write(data.value);\n                break;\n        }\n\n        setImmediate(done);\n    }\n\n    _getPartId(parentBoundary) {\n        let boundaryIndex = this.boundaries.findIndex(item => item.name === parentBoundary);\n        if (boundaryIndex === -1) {\n            this.boundaries.push({ name: parentBoundary, count: 1 });\n            boundaryIndex = this.boundaries.length - 1;\n        } else {\n            this.boundaries[boundaryIndex].count++;\n        }\n        let partId = '1';\n        for (let i = 0; i <= boundaryIndex; i++) {\n            if (i === 0) partId = this.boundaries[i].count.toString();\n            else partId += '.' + this.boundaries[i].count.toString();\n        }\n        return partId;\n    }\n\n    getAddressesHTML(value) {\n        let formatSingleLevel = addresses =>\n            addresses\n                .map(address => {\n                    let str = '<span class=\"mp_address_group\">';\n                    if (address.name) {\n                        str += '<span class=\"mp_address_name\">' + he.encode(address.name) + (address.group ? ': ' : '') + '</span>';\n                    }\n                    if (address.address) {\n                        let link = '<a href=\"mailto:' + he.encode(address.address) + '\" class=\"mp_address_email\">' + he.encode(address.address) + '</a>';\n                        if (address.name) {\n                            str += ' &lt;' + link + '&gt;';\n                        } else {\n                            str += link;\n                        }\n                    }\n                    if (address.group) {\n                        str += formatSingleLevel(address.group) + ';';\n                    }\n                    return str + '</span>';\n                })\n                .join(', ');\n        return formatSingleLevel([].concat(value || []));\n    }\n\n    getAddressesText(value) {\n        let formatSingleLevel = addresses =>\n            addresses\n                .map(address => {\n                    let str = '';\n                    if (address.name) {\n                        str += `\"${address.name}\"` + (address.group ? ': ' : '');\n                    }\n                    if (address.address) {\n                        let link = address.address;\n                        if (address.name) {\n                            str += ' <' + link + '>';\n                        } else {\n                            str += link;\n                        }\n                    }\n                    if (address.group) {\n                        str += formatSingleLevel(address.group) + ';';\n                    }\n                    return str;\n                })\n                .join(', ');\n        return formatSingleLevel([].concat(value || []));\n    }\n\n    updateImageLinks(replaceCallback, done) {\n        if (!this.html) {\n            return setImmediate(() => done(null, false));\n        }\n\n        let cids = new Map();\n        let html = (this.html || '').toString();\n\n        if (this.options.skipImageLinks) {\n            return done(null, html);\n        }\n\n        html.replace(/\\bcid:([^'\"\\s]{1,256})/g, (match, cid) => {\n            for (let i = 0, len = this.attachmentList.length; i < len; i++) {\n                if (this.attachmentList[i].cid === cid && /^image\\/[\\w]+$/i.test(this.attachmentList[i].contentType)) {\n                    cids.set(cid, {\n                        attachment: this.attachmentList[i]\n                    });\n                    break;\n                }\n            }\n            return match;\n        });\n\n        let cidList = [];\n        cids.forEach(entry => {\n            cidList.push(entry);\n        });\n\n        let pos = 0;\n        let processNext = () => {\n            if (pos >= cidList.length) {\n                html = html.replace(/\\bcid:([^'\"\\s]{1,256})/g, (match, cid) => {\n                    if (cids.has(cid) && cids.get(cid).url) {\n                        return cids.get(cid).url;\n                    }\n                    return match;\n                });\n\n                return done(null, html);\n            }\n            let entry = cidList[pos++];\n            replaceCallback(entry.attachment, (err, url) => {\n                if (err) {\n                    return setImmediate(() => done(err));\n                }\n                entry.url = url;\n                setImmediate(processNext);\n            });\n        };\n\n        setImmediate(processNext);\n    }\n\n    textToHtml(str) {\n        if (this.options.skipTextToHtml) {\n            return '';\n        }\n        str = (str || '').toString();\n        let encoded;\n\n        let linkified = false;\n        if (!this.options.skipTextLinks) {\n            try {\n                if (linkify.pretest(str)) {\n                    linkified = true;\n                    let links = linkify.match(str) || [];\n                    let result = [];\n                    let last = 0;\n\n                    links.forEach(link => {\n                        if (last < link.index) {\n                            let textPart = he\n                                // encode special chars\n                                .encode(str.slice(last, link.index), {\n                                    useNamedReferences: true\n                                });\n                            result.push(textPart);\n                        }\n\n                        result.push(`<a href=\"${link.url}\">${link.text}</a>`);\n\n                        last = link.lastIndex;\n                    });\n\n                    let textPart = he\n                        // encode special chars\n                        .encode(str.slice(last), {\n                            useNamedReferences: true\n                        });\n                    result.push(textPart);\n\n                    encoded = result.join('');\n                }\n            } catch (E) {\n                // failed, don't linkify\n            }\n        }\n\n        if (!linkified) {\n            encoded = he\n                // encode special chars\n                .encode(str, {\n                    useNamedReferences: true\n                });\n        }\n\n        let text =\n            '<p>' +\n            encoded\n                .replace(/\\r?\\n/g, '\\n')\n                .trim() // normalize line endings\n                .replace(/[ \\t]+$/gm, '')\n                .trim() // trim empty line endings\n                .replace(/\\n\\n+/g, '</p><p>')\n                .trim() // insert <p> to multiple linebreaks\n                .replace(/\\n/g, '<br/>') + // insert <br> to single linebreaks\n            '</p>';\n\n        return text;\n    }\n}\n\nmodule.exports = MailParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL21haWxwYXJzZXIvbGliL21haWwtcGFyc2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGtCQUFrQixtQkFBTyxDQUFDLDZFQUFvQjtBQUM5QyxnQkFBZ0IsbUJBQU8sQ0FBQyw2REFBUztBQUNqQyxzQkFBc0IsbUJBQU8sQ0FBQyx5SEFBOEI7QUFDNUQsa0JBQWtCLHVEQUEyQjtBQUM3QztBQUNBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsc0VBQWE7QUFDdEMsc0JBQXNCLG1CQUFPLENBQUMsNkdBQXVDO0FBQ3JFLG1CQUFtQixtQkFBTyxDQUFDLDBFQUFlO0FBQzFDLGNBQWMsbUJBQU8sQ0FBQyx5RkFBWTtBQUNsQyxRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLDZFQUFjO0FBQzdDLFdBQVcsbUJBQU8sQ0FBQywwQ0FBSTtBQUN2QixnQkFBZ0IsbUJBQU8sQ0FBQyx1RUFBWTtBQUNwQyxhQUFhLG1CQUFPLENBQUMsbURBQU07QUFDM0IseUJBQXlCLG1CQUFPLENBQUMsK0VBQW1COztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrREFBa0Q7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwREFBMEQsS0FBSztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQsNkNBQTZDLDJCQUEyQjtBQUN4RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLHNGQUFzRix5QkFBeUI7QUFDL0c7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnQ0FBZ0M7QUFDbkU7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pELDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsYUFBYTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyxNQUFNO0FBQzNDLDhEQUE4RCxTQUFTO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsTUFBTTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUEsZ0RBQWdELFNBQVMsSUFBSSxVQUFVOztBQUV2RTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxrZnJ5dFxcLmdlbWluaVxcYW50aWdyYXZpdHlcXHNjcmF0Y2hcXGRyX2thbHNfdmlydHVhbF9ob3NwaXRhbFxcbm9kZV9tb2R1bGVzXFxtYWlscGFyc2VyXFxsaWJcXG1haWwtcGFyc2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgbWFpbHNwbGl0ID0gcmVxdWlyZSgnQHpvbmUtZXUvbWFpbHNwbGl0Jyk7XG5jb25zdCBsaWJtaW1lID0gcmVxdWlyZSgnbGlibWltZScpO1xuY29uc3QgYWRkcmVzc3BhcnNlciA9IHJlcXVpcmUoJ25vZGVtYWlsZXIvbGliL2FkZHJlc3NwYXJzZXInKTtcbmNvbnN0IFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3N0cmVhbScpLlRyYW5zZm9ybTtcbmNvbnN0IFNwbGl0dGVyID0gbWFpbHNwbGl0LlNwbGl0dGVyO1xuY29uc3QgQ2h1bmtlZFBhc3N0aHJvdWdoID0gbWFpbHNwbGl0LkNodW5rZWRQYXNzdGhyb3VnaDtcbmNvbnN0IHB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUuanMnKTtcbmNvbnN0IEZsb3dlZERlY29kZXIgPSByZXF1aXJlKCdAem9uZS1ldS9tYWlsc3BsaXQvbGliL2Zsb3dlZC1kZWNvZGVyJyk7XG5jb25zdCBTdHJlYW1IYXNoID0gcmVxdWlyZSgnLi9zdHJlYW0taGFzaCcpO1xuY29uc3QgaWNvbnYgPSByZXF1aXJlKCdpY29udi1saXRlJyk7XG5jb25zdCB7IGh0bWxUb1RleHQgfSA9IHJlcXVpcmUoJ2h0bWwtdG8tdGV4dCcpO1xuY29uc3QgaGUgPSByZXF1aXJlKCdoZScpO1xuY29uc3QgbGlua2lmeSA9IHJlcXVpcmUoJ2xpbmtpZnktaXQnKSgpO1xuY29uc3QgdGxkcyA9IHJlcXVpcmUoJ3RsZHMnKTtcbmNvbnN0IGVuY29kaW5nSmFwYW5lc2UgPSByZXF1aXJlKCdlbmNvZGluZy1qYXBhbmVzZScpO1xuXG5saW5raWZ5XG4gICAgLnRsZHModGxkcykgLy8gUmVsb2FkIHdpdGggZnVsbCB0bGRzIGxpc3RcbiAgICAudGxkcygnb25pb24nLCB0cnVlKSAvLyBBZGQgdW5vZmZpY2lhbCBgLm9uaW9uYCBkb21haW5cbiAgICAuYWRkKCdnaXQ6JywgJ2h0dHA6JykgLy8gQWRkIGBnaXQ6YCBwdG90b2NvbCBhcyBcImFsaWFzXCJcbiAgICAuYWRkKCdmdHA6JywgbnVsbCkgLy8gRGlzYWJsZSBgZnRwOmAgcHRvdG9jb2xcbiAgICAuc2V0KHsgZnV6enlJUDogdHJ1ZSwgZnV6enlMaW5rOiB0cnVlLCBmdXp6eUVtYWlsOiB0cnVlIH0pO1xuXG4vLyB0d2l0dGVyIGxpbmtpZmllciBmcm9tXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbGlua2lmeS1pdCNleGFtcGxlLTItYWRkLXR3aXR0ZXItbWVudGlvbnMtaGFuZGxlclxubGlua2lmeS5hZGQoJ0AnLCB7XG4gICAgdmFsaWRhdGUodGV4dCwgcG9zLCBzZWxmKSB7XG4gICAgICAgIGxldCB0YWlsID0gdGV4dC5zbGljZShwb3MpO1xuXG4gICAgICAgIGlmICghc2VsZi5yZS50d2l0dGVyKSB7XG4gICAgICAgICAgICBzZWxmLnJlLnR3aXR0ZXIgPSBuZXcgUmVnRXhwKCdeKFthLXpBLVowLTlfXSl7MSwxNX0oPyFfKSg/PSR8JyArIHNlbGYucmUuc3JjX1pQQ2MgKyAnKScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLnJlLnR3aXR0ZXIudGVzdCh0YWlsKSkge1xuICAgICAgICAgICAgLy8gTGlua2lmaWVyIGFsbG93cyBwdW5jdHVhdGlvbiBjaGFycyBiZWZvcmUgcHJlZml4LFxuICAgICAgICAgICAgLy8gYnV0IHdlIGFkZGl0aW9uYWxseSBkaXNhYmxlIGBAYCAoXCJAQG1lbnRpb25cIiBpcyBpbnZhbGlkKVxuICAgICAgICAgICAgaWYgKHBvcyA+PSAyICYmIHRhaWxbcG9zIC0gMl0gPT09ICdAJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YWlsLm1hdGNoKHNlbGYucmUudHdpdHRlcilbMF0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgbm9ybWFsaXplKG1hdGNoKSB7XG4gICAgICAgIG1hdGNoLnVybCA9ICdodHRwczovL3R3aXR0ZXIuY29tLycgKyBtYXRjaC51cmwucmVwbGFjZSgvXkAvLCAnJyk7XG4gICAgfVxufSk7XG5cbmNsYXNzIEljb252RGVjb2RlciBleHRlbmRzIFRyYW5zZm9ybSB7XG4gICAgY29uc3RydWN0b3IoSWNvbnYsIGNoYXJzZXQpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBJY29udiB0aHJvd3MgZXJyb3Igb24ga3NfY181NjAxLTE5ODcgd2hlbiBpdCBpcyBtYXBwZWQgdG8gRVVDLUtSXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ibm9vcmRodWlzL25vZGUtaWNvbnYvaXNzdWVzLzE2OVxuICAgICAgICBpZiAoY2hhcnNldC50b0xvd2VyQ2FzZSgpID09PSAna3NfY181NjAxLTE5ODcnKSB7XG4gICAgICAgICAgICBjaGFyc2V0ID0gJ0NQOTQ5JztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0cmVhbSA9IG5ldyBJY29udihjaGFyc2V0LCAnVVRGLTgvL1RSQU5TTElULy9JR05PUkUnKTtcblxuICAgICAgICB0aGlzLmlucHV0RW5kZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbmRDYiA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuc3RyZWFtLm9uKCdlcnJvcicsIGVyciA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLm9uKCdkYXRhJywgY2h1bmsgPT4gdGhpcy5wdXNoKGNodW5rKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlucHV0RW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmVuZENiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRDYigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgZG9uZSkge1xuICAgICAgICB0aGlzLnN0cmVhbS53cml0ZShjaHVuayk7XG4gICAgICAgIGRvbmUoKTtcbiAgICB9XG5cbiAgICBfZmx1c2goZG9uZSkge1xuICAgICAgICB0aGlzLmVuZENiID0gZG9uZTtcbiAgICAgICAgdGhpcy5zdHJlYW0uZW5kKCk7XG4gICAgfVxufVxuXG5jbGFzcyBKUERlY29kZXIgZXh0ZW5kcyBUcmFuc2Zvcm0ge1xuICAgIGNvbnN0cnVjdG9yKGNoYXJzZXQpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLmNoYXJzZXQgPSBjaGFyc2V0O1xuICAgICAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgICAgICB0aGlzLmNodW5rbGVuID0gMDtcbiAgICB9XG5cbiAgICBfdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgZG9uZSkge1xuICAgICAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG4gICAgICAgIHRoaXMuY2h1bmtsZW4gKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICBkb25lKCk7XG4gICAgfVxuXG4gICAgX2ZsdXNoKGRvbmUpIHtcbiAgICAgICAgbGV0IGlucHV0ID0gQnVmZmVyLmNvbmNhdCh0aGlzLmNodW5rcywgdGhpcy5jaHVua2xlbik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgb3V0cHV0ID0gZW5jb2RpbmdKYXBhbmVzZS5jb252ZXJ0KGlucHV0LCB7XG4gICAgICAgICAgICAgICAgdG86ICdVTklDT0RFJywgLy8gdG9fZW5jb2RpbmdcbiAgICAgICAgICAgICAgICBmcm9tOiB0aGlzLmNoYXJzZXQsIC8vIGZyb21fZW5jb2RpbmdcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG91dHB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBCdWZmZXIuZnJvbShvdXRwdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wdXNoKG91dHB1dCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8ga2VlcCBhcyBpcyBvbiBlcnJvcnNcbiAgICAgICAgICAgIHRoaXMucHVzaChpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICBkb25lKCk7XG4gICAgfVxufVxuXG5jbGFzcyBNYWlsUGFyc2VyIGV4dGVuZHMgVHJhbnNmb3JtIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgcmVhZGFibGVPYmplY3RNb2RlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGVPYmplY3RNb2RlOiBmYWxzZVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcgfHwge307XG4gICAgICAgIHRoaXMuY2h1bmtlZFBhc3N0aHJvdWdoID0gbmV3IENodW5rZWRQYXNzdGhyb3VnaCgpO1xuICAgICAgICB0aGlzLnNwbGl0dGVyID0gbmV3IFNwbGl0dGVyKGNvbmZpZyk7XG5cbiAgICAgICAgdGhpcy5jaHVua2VkUGFzc3Rocm91Z2gucGlwZSh0aGlzLnNwbGl0dGVyKTtcblxuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMud2FpdGluZ0VuZCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuaGVhZGVycyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhlYWRlckxpbmVzID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5lbmRSZWNlaXZlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNGYWlsZWQgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLnRyZWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJub2RlID0gZmFsc2U7XG4gICAgICAgIHRoaXMud2FpdFVudGlsQXR0YWNobWVudEVuZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmF0dGFjaG1lbnRDYWxsYmFjayA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuaGFzSHRtbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc1RleHQgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLnRleHQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5odG1sID0gZmFsc2U7XG4gICAgICAgIHRoaXMudGV4dEFzSHRtbCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuYXR0YWNobWVudExpc3QgPSBbXTtcblxuICAgICAgICB0aGlzLmJvdW5kYXJpZXMgPSBbXTtcblxuICAgICAgICB0aGlzLnRleHRUeXBlcyA9IFsndGV4dC9wbGFpbicsICd0ZXh0L2h0bWwnXS5jb25jYXQoIXRoaXMub3B0aW9ucy5rZWVwRGVsaXZlcnlTdGF0dXMgPyAnbWVzc2FnZS9kZWxpdmVyeS1zdGF0dXMnIDogW10pO1xuXG4gICAgICAgIHRoaXMuZGVjb2RlciA9IHRoaXMuZ2V0RGVjb2RlcigpO1xuXG4gICAgICAgIHRoaXMuY2h1bmtlZFBhc3N0aHJvdWdoLm9uKCdlcnJvcicsIGVyciA9PiB7XG4gICAgICAgICAgICB0aGlzLnNwbGl0dGVyLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5zcGxpdHRlci5vbigncmVhZGFibGUnLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWFkRGF0YSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnNwbGl0dGVyLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVuZFJlY2VpdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5yZWFkaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRTdHJlYW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5zcGxpdHRlci5vbignZXJyb3InLCBlcnIgPT4ge1xuICAgICAgICAgICAgdGhpcy5oYXNGYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLndhaXRpbmdFbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53YWl0aW5nRW5kKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5saWJtaW1lID0gbmV3IGxpYm1pbWUuTGlibWltZSh7IEljb252OiB0aGlzLm9wdGlvbnMuSWNvbnYgfSk7XG4gICAgfVxuXG4gICAgZ2V0RGVjb2RlcigpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5JY29udikge1xuICAgICAgICAgICAgY29uc3QgSWNvbnYgPSB0aGlzLm9wdGlvbnMuSWNvbnY7XG4gICAgICAgICAgICAvLyBjcmVhdGUgd3JhcHBlclxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVTdHJlYW0oY2hhcnNldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEljb252RGVjb2RlcihJY29udiwgY2hhcnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGVjb2RlU3RyZWFtKGNoYXJzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnNldCA9IChjaGFyc2V0IHx8ICdhc2NpaScpLnRvU3RyaW5nKCkudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgvXmppc3xeaXNvLT8yMDIyLT9qcHxeRVVDSlAvaS50ZXN0KGNoYXJzZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2Ugbm90IHN1cHBvcnRlZCBieSBpY29udi1saXRlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEpQRGVjb2RlcihjaGFyc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpY29udi5kZWNvZGVTdHJlYW0oY2hhcnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlYWREYXRhKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNGYWlsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlYWRpbmcgPSB0cnVlO1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuc3BsaXR0ZXIucmVhZCgpO1xuICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5lbmRSZWNlaXZlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kU3RyZWFtKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByb2Nlc3NDaHVuayhkYXRhLCBlcnIgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy53YWl0aW5nRW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndhaXRpbmdFbmQoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMucmVhZERhdGEoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGVuZFN0cmVhbSgpIHtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKHRoaXMuY3Vybm9kZSAmJiB0aGlzLmN1cm5vZGUuZGVjb2Rlcikge1xuICAgICAgICAgICAgdGhpcy5jdXJub2RlLmRlY29kZXIuZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLndhaXRpbmdFbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMud2FpdGluZ0VuZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3RyYW5zZm9ybShjaHVuaywgZW5jb2RpbmcsIGRvbmUpIHtcbiAgICAgICAgaWYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY2h1bmtlZFBhc3N0aHJvdWdoLndyaXRlKGNodW5rKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNodW5rZWRQYXNzdGhyb3VnaC5vbmNlKCdkcmFpbicsICgpID0+IHtcbiAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZmx1c2goZG9uZSkge1xuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5jaHVua2VkUGFzc3Rocm91Z2guZW5kKCkpO1xuICAgICAgICBpZiAodGhpcy5maW5pc2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xlYW51cChkb25lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndhaXRpbmdFbmQgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNsZWFudXAoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGNsZWFudXAoZG9uZSkge1xuICAgICAgICBsZXQgZmluaXNoID0gKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgdCA9IHRoaXMuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2godCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodGhpcy5jdXJub2RlICYmIHRoaXMuY3Vybm9kZS5kZWNvZGVyICYmIHRoaXMuY3Vybm9kZS5kZWNvZGVyLnJlYWRhYmxlICYmICF0aGlzLmRlY29kZXJFbmRlZCkge1xuICAgICAgICAgICAgKHRoaXMuY3Vybm9kZS5jb250ZW50U3RyZWFtIHx8IHRoaXMuY3Vybm9kZS5kZWNvZGVyKS5vbmNlKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZmluaXNoKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuY3Vybm9kZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBmaW5pc2goKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvY2Vzc0hlYWRlcnMobGluZXMpIHtcbiAgICAgICAgbGV0IGhlYWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIChsaW5lcyB8fCBbXSkuZm9yRWFjaChsaW5lID0+IHtcbiAgICAgICAgICAgIGxldCBrZXkgPSBsaW5lLmtleTtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9ICgodGhpcy5saWJtaW1lLmRlY29kZUhlYWRlcihsaW5lLmxpbmUpIHx8IHt9KS52YWx1ZSB8fCAnJykudG9TdHJpbmcoKS50cmltKCk7XG4gICAgICAgICAgICB2YWx1ZSA9IEJ1ZmZlci5mcm9tKHZhbHVlLCAnYmluYXJ5JykudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY29udGVudC10eXBlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjb250ZW50LWRpc3Bvc2l0aW9uJzpcbiAgICAgICAgICAgICAgICBjYXNlICdka2ltLXNpZ25hdHVyZSc6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5saWJtaW1lLnBhcnNlSGVhZGVyVmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnZhbHVlID0gdGhpcy5saWJtaW1lLmRlY29kZVdvcmRzKHZhbHVlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cygodmFsdWUgJiYgdmFsdWUucGFyYW1zKSB8fCB7fSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5wYXJhbXNba2V5XSA9IHRoaXMubGlibWltZS5kZWNvZGVXb3Jkcyh2YWx1ZS5wYXJhbXNba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlLCBrZWVwIGFzIGlzXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkYXRlJzoge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGF0ZVZhbHVlID0gbmV3IERhdGUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4oZGF0ZVZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGF0ZSBwYXJzaW5nIGZhaWxlZCA6U1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZVZhbHVlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGRhdGVWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ3N1YmplY3QnOlxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmxpYm1pbWUuZGVjb2RlV29yZHModmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUsIGtlZXAgYXMgaXNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdyZWZlcmVuY2VzJzpcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5saWJtaW1lLmRlY29kZVdvcmRzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgvXFxzKy8pLm1hcCh0aGlzLmVuc3VyZU1lc3NhZ2VJREZvcm1hdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ21lc3NhZ2UtaWQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2luLXJlcGx5LXRvJzpcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5saWJtaW1lLmRlY29kZVdvcmRzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmVuc3VyZU1lc3NhZ2VJREZvcm1hdCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3ByaW9yaXR5JzpcbiAgICAgICAgICAgICAgICBjYXNlICd4LXByaW9yaXR5JzpcbiAgICAgICAgICAgICAgICBjYXNlICd4LW1zbWFpbC1wcmlvcml0eSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnaW1wb3J0YW5jZSc6XG4gICAgICAgICAgICAgICAgICAgIGtleSA9ICdwcmlvcml0eSc7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJzZVByaW9yaXR5KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZnJvbSc6XG4gICAgICAgICAgICAgICAgY2FzZSAndG8nOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2NjJzpcbiAgICAgICAgICAgICAgICBjYXNlICdiY2MnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3NlbmRlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAncmVwbHktdG8nOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2RlbGl2ZXJlZC10byc6XG4gICAgICAgICAgICAgICAgY2FzZSAncmV0dXJuLXBhdGgnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Rpc3Bvc2l0aW9uLW5vdGlmaWNhdGlvbi10byc6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYWRkcmVzc3BhcnNlcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlQWRkcmVzc2VzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHRoaXMuZ2V0QWRkcmVzc2VzSFRNTCh2YWx1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0aGlzLmdldEFkZHJlc3Nlc1RleHQodmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBoYW5kbGUgbGlzdC0qIGtleXNcbiAgICAgICAgICAgIGlmIChrZXkuc3Vic3RyKDAsIDUpID09PSAnbGlzdC0nKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlTGlzdEhlYWRlcihrZXkuc3Vic3RyKDUpLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAga2V5ID0gJ2xpc3QnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWhlYWRlcnMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVycy5zZXQoa2V5LCBbXS5jb25jYXQodmFsdWUgfHwgW10pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMuc2V0KGtleSwgaGVhZGVycy5nZXQoa2V5KS5jb25jYXQodmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzLmdldChrZXkpLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8ga2VlcCBvbmx5IHRoZSBmaXJzdCB2YWx1ZVxuICAgICAgICBsZXQgc2luZ2xlS2V5cyA9IFtcbiAgICAgICAgICAgICdtZXNzYWdlLWlkJyxcbiAgICAgICAgICAgICdjb250ZW50LWlkJyxcbiAgICAgICAgICAgICdmcm9tJyxcbiAgICAgICAgICAgICdzZW5kZXInLFxuICAgICAgICAgICAgJ2luLXJlcGx5LXRvJyxcbiAgICAgICAgICAgICdyZXBseS10bycsXG4gICAgICAgICAgICAnc3ViamVjdCcsXG4gICAgICAgICAgICAnZGF0ZScsXG4gICAgICAgICAgICAnY29udGVudC1kaXNwb3NpdGlvbicsXG4gICAgICAgICAgICAnY29udGVudC10eXBlJyxcbiAgICAgICAgICAgICdjb250ZW50LXRyYW5zZmVyLWVuY29kaW5nJyxcbiAgICAgICAgICAgICdwcmlvcml0eScsXG4gICAgICAgICAgICAnbWltZS12ZXJzaW9uJyxcbiAgICAgICAgICAgICdjb250ZW50LWRlc2NyaXB0aW9uJyxcbiAgICAgICAgICAgICdwcmVjZWRlbmNlJyxcbiAgICAgICAgICAgICdlcnJvcnMtdG8nLFxuICAgICAgICAgICAgJ2Rpc3Bvc2l0aW9uLW5vdGlmaWNhdGlvbi10bydcbiAgICAgICAgXTtcblxuICAgICAgICBoZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmIChzaW5nbGVLZXlzLmluY2x1ZGVzKGtleSkgJiYgdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMuc2V0KGtleSwgdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMuc2V0KGtleSwgdmFsdWVbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2xpc3QnKSB7XG4gICAgICAgICAgICAgICAgLy8gbm9ybWFsaXplIExpc3QtKiBoZWFkZXJzXG4gICAgICAgICAgICAgICAgbGV0IGxpc3RWYWx1ZSA9IHt9O1xuICAgICAgICAgICAgICAgIFtdLmNvbmNhdCh2YWx1ZSB8fCBbXSkuZm9yRWFjaCh2YWwgPT4ge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh2YWwgfHwge30pLmZvckVhY2gobGlzdEtleSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0VmFsdWVbbGlzdEtleV0gPSB2YWxbbGlzdEtleV07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGhlYWRlcnMuc2V0KGtleSwgbGlzdFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuXG4gICAgcGFyc2VMaXN0SGVhZGVyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgbGV0IGFkZHJlc3NlcyA9IGFkZHJlc3NwYXJzZXIodmFsdWUpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSB7fTtcbiAgICAgICAgbGV0IGRhdGEgPSBhZGRyZXNzZXNcbiAgICAgICAgICAgIC5tYXAoYWRkcmVzcyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKC9eaHR0cHM/Oi9pLnRlc3QoYWRkcmVzcy5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS51cmwgPSBhZGRyZXNzLm5hbWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhZGRyZXNzLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UubmFtZSA9IGFkZHJlc3MubmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKC9ebWFpbHRvOi8udGVzdChhZGRyZXNzLmFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLm1haWwgPSBhZGRyZXNzLmFkZHJlc3Muc3Vic3RyKDcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWRkcmVzcy5hZGRyZXNzICYmIGFkZHJlc3MuYWRkcmVzcy5pbmRleE9mKCdAJykgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmlkID0gYWRkcmVzcy5hZGRyZXNzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWRkcmVzcy5hZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLm1haWwgPSBhZGRyZXNzLmFkZHJlc3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhyZXNwb25zZSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoYWRkcmVzcyA9PiBhZGRyZXNzKTtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIFtrZXldOiByZXNwb25zZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcGFyc2VQcmlvcml0eSh2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgICAgICBpZiAoIWlzTmFOKHBhcnNlSW50KHZhbHVlLCAxMCkpKSB7XG4gICAgICAgICAgICAvLyBzdXBwb3J0IFwiWC1Qcmlvcml0eTogMSAoSGlnaGVzdClcIlxuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUludCh2YWx1ZSwgMTApIHx8IDA7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ25vcm1hbCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID4gMykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnbG93JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWdoJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdub24tdXJnZW50JzpcbiAgICAgICAgICAgICAgICBjYXNlICdsb3cnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2xvdyc7XG4gICAgICAgICAgICAgICAgY2FzZSAndXJnZW50JzpcbiAgICAgICAgICAgICAgICBjYXNlICdoaWdoJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdoaWdoJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ25vcm1hbCc7XG4gICAgfVxuXG4gICAgZW5zdXJlTWVzc2FnZUlERm9ybWF0KHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUuY2hhckF0KDApICE9PSAnPCcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gJzwnICsgdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUuY2hhckF0KHZhbHVlLmxlbmd0aCAtIDEpICE9PSAnPicpIHtcbiAgICAgICAgICAgIHZhbHVlICs9ICc+JztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBkZWNvZGVBZGRyZXNzZXMoYWRkcmVzc2VzKSB7XG4gICAgICAgIGxldCBwcm9jZXNzZWRBZGRyZXNzID0gbmV3IFdlYWtTZXQoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZGRyZXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBhZGRyZXNzID0gYWRkcmVzc2VzW2ldO1xuICAgICAgICAgICAgYWRkcmVzcy5uYW1lID0gKGFkZHJlc3MubmFtZSB8fCAnJykudG9TdHJpbmcoKS50cmltKCk7XG5cbiAgICAgICAgICAgIGlmICghYWRkcmVzcy5hZGRyZXNzICYmIC9eKD1cXD8oW14/XSspXFw/W0JiXVxcP1teP10qXFw/PSkoXFxzKj1cXD8oW14/XSspXFw/W0JiXVxcP1teP10qXFw/PSkqJC8udGVzdChhZGRyZXNzLm5hbWUpICYmICFwcm9jZXNzZWRBZGRyZXNzLmhhcyhhZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgIGxldCBwYXJzZWQgPSBhZGRyZXNzcGFyc2VyKHRoaXMubGlibWltZS5kZWNvZGVXb3JkcyhhZGRyZXNzLm5hbWUpKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWRBZGRyZXNzLmFkZChlbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzZXMucHVzaChlbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBjdXJyZW50IGVsZW1lbnRcbiAgICAgICAgICAgICAgICBhZGRyZXNzZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFkZHJlc3MubmFtZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3MubmFtZSA9IHRoaXMubGlibWltZS5kZWNvZGVXb3JkcyhhZGRyZXNzLm5hbWUpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKEUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9pZ25vcmUsIGtlZXAgYXMgaXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoL0B4bi0tLy50ZXN0KGFkZHJlc3MuYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLmFkZHJlc3MgPVxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzcy5hZGRyZXNzLnN1YnN0cigwLCBhZGRyZXNzLmFkZHJlc3MubGFzdEluZGV4T2YoJ0AnKSArIDEpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1bnljb2RlLnRvVW5pY29kZShhZGRyZXNzLmFkZHJlc3Muc3Vic3RyKGFkZHJlc3MuYWRkcmVzcy5sYXN0SW5kZXhPZignQCcpICsgMSkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKEUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90IGEgdmFsaWQgcHVueWNvZGUgc3RyaW5nOyBrZWVwIGFzIGlzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFkZHJlc3MuZ3JvdXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29kZUFkZHJlc3NlcyhhZGRyZXNzLmdyb3VwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNyZWF0ZU5vZGUobm9kZSkge1xuICAgICAgICBsZXQgY29udGVudFR5cGUgPSBub2RlLmNvbnRlbnRUeXBlO1xuICAgICAgICBsZXQgZGlzcG9zaXRpb24gPSBub2RlLmRpc3Bvc2l0aW9uO1xuICAgICAgICBsZXQgZW5jb2RpbmcgPSBub2RlLmVuY29kaW5nO1xuICAgICAgICBsZXQgY2hhcnNldCA9IG5vZGUuY2hhcnNldDtcblxuICAgICAgICBpZiAoIWNvbnRlbnRUeXBlICYmIG5vZGUucm9vdCkge1xuICAgICAgICAgICAgY29udGVudFR5cGUgPSAndGV4dC9wbGFpbic7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbmV3Tm9kZSA9IHtcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICBoZWFkZXJMaW5lczogbm9kZS5oZWFkZXJzLmxpbmVzLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5wcm9jZXNzSGVhZGVycyhub2RlLmhlYWRlcnMuZ2V0TGlzdCgpKSxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlLFxuICAgICAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCEvXm11bHRpcGFydFxcLy9pLnRlc3QoY29udGVudFR5cGUpKSB7XG4gICAgICAgICAgICBpZiAoZGlzcG9zaXRpb24gJiYgIVsnYXR0YWNobWVudCcsICdpbmxpbmUnXS5pbmNsdWRlcyhkaXNwb3NpdGlvbikpIHtcbiAgICAgICAgICAgICAgICBkaXNwb3NpdGlvbiA9ICdhdHRhY2htZW50JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFkaXNwb3NpdGlvbiAmJiAhdGhpcy50ZXh0VHlwZXMuaW5jbHVkZXMoY29udGVudFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgbmV3Tm9kZS5kaXNwb3NpdGlvbiA9ICdhdHRhY2htZW50JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3Tm9kZS5kaXNwb3NpdGlvbiA9IGRpc3Bvc2l0aW9uIHx8ICdpbmxpbmUnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBuZXdOb2RlLmlzQXR0YWNobWVudCA9ICF0aGlzLnRleHRUeXBlcy5pbmNsdWRlcyhjb250ZW50VHlwZSkgfHwgbmV3Tm9kZS5kaXNwb3NpdGlvbiAhPT0gJ2lubGluZSc7XG5cbiAgICAgICAgICAgIG5ld05vZGUuZW5jb2RpbmcgPSBbJ3F1b3RlZC1wcmludGFibGUnLCAnYmFzZTY0J10uaW5jbHVkZXMoZW5jb2RpbmcpID8gZW5jb2RpbmcgOiAnYmluYXJ5JztcblxuICAgICAgICAgICAgaWYgKGNoYXJzZXQpIHtcbiAgICAgICAgICAgICAgICBuZXdOb2RlLmNoYXJzZXQgPSBjaGFyc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgZGVjb2RlciA9IG5vZGUuZ2V0RGVjb2RlcigpO1xuICAgICAgICAgICAgZGVjb2Rlci5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlckVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmV3Tm9kZS5kZWNvZGVyID0gZGVjb2RlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlLnJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycyA9IG5ld05vZGUuaGVhZGVycztcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyTGluZXMgPSBuZXdOb2RlLmhlYWRlckxpbmVzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluZCBsb2NhdGlvbiBpbiB0cmVlXG5cbiAgICAgICAgaWYgKCF0aGlzLnRyZWUpIHtcbiAgICAgICAgICAgIG5ld05vZGUucm9vdCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmN1cm5vZGUgPSB0aGlzLnRyZWUgPSBuZXdOb2RlO1xuICAgICAgICAgICAgcmV0dXJuIG5ld05vZGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbW1lZGlhdGUgY2hpbGQgb2Ygcm9vdCBub2RlXG4gICAgICAgIGlmICghdGhpcy5jdXJub2RlLnBhcmVudCkge1xuICAgICAgICAgICAgbmV3Tm9kZS5wYXJlbnQgPSB0aGlzLmN1cm5vZGU7XG4gICAgICAgICAgICB0aGlzLmN1cm5vZGUuY2hpbGRyZW4ucHVzaChuZXdOb2RlKTtcbiAgICAgICAgICAgIHRoaXMuY3Vybm9kZSA9IG5ld05vZGU7XG4gICAgICAgICAgICByZXR1cm4gbmV3Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNpYmxpbmdzXG4gICAgICAgIGlmICh0aGlzLmN1cm5vZGUucGFyZW50Lm5vZGUgPT09IG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgbmV3Tm9kZS5wYXJlbnQgPSB0aGlzLmN1cm5vZGUucGFyZW50O1xuICAgICAgICAgICAgdGhpcy5jdXJub2RlLnBhcmVudC5jaGlsZHJlbi5wdXNoKG5ld05vZGUpO1xuICAgICAgICAgICAgdGhpcy5jdXJub2RlID0gbmV3Tm9kZTtcbiAgICAgICAgICAgIHJldHVybiBuZXdOb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlyc3QgY2hpbGRcbiAgICAgICAgaWYgKHRoaXMuY3Vybm9kZS5ub2RlID09PSBub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIG5ld05vZGUucGFyZW50ID0gdGhpcy5jdXJub2RlO1xuICAgICAgICAgICAgdGhpcy5jdXJub2RlLmNoaWxkcmVuLnB1c2gobmV3Tm9kZSk7XG4gICAgICAgICAgICB0aGlzLmN1cm5vZGUgPSBuZXdOb2RlO1xuICAgICAgICAgICAgcmV0dXJuIG5ld05vZGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtb3ZlIHVwXG4gICAgICAgIGxldCBwYXJlbnROb2RlID0gdGhpcy5jdXJub2RlO1xuICAgICAgICB3aGlsZSAoKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnROb2RlLm5vZGUgPT09IG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIG5ld05vZGUucGFyZW50ID0gcGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmNoaWxkcmVuLnB1c2gobmV3Tm9kZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJub2RlID0gbmV3Tm9kZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNob3VsZCBuZXZlciBoYXBwZW4sIGNhbid0IGRldGVjdCBwYXJlbnRcbiAgICAgICAgdGhpcy5jdXJub2RlID0gbmV3Tm9kZTtcbiAgICAgICAgcmV0dXJuIG5ld05vZGU7XG4gICAgfVxuXG4gICAgZ2V0VGV4dENvbnRlbnQoKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gW107XG4gICAgICAgIGxldCBodG1sID0gW107XG4gICAgICAgIGxldCBwcm9jZXNzTm9kZSA9IChhbHRlcm5hdGl2ZSwgbGV2ZWwsIG5vZGUpID0+IHtcbiAgICAgICAgICAgIGlmIChub2RlLnNob3dNZXRhKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1ldGEgPSBbJ0Zyb20nLCAnU3ViamVjdCcsICdEYXRlJywgJ1RvJywgJ0NjJywgJ0JjYyddXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZmtleSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQga2V5ID0gZmtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLmhlYWRlcnMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBub2RlLmhlYWRlcnMuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGZrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gOiB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihlbnRyeSA9PiBlbnRyeSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzSHRtbCkge1xuICAgICAgICAgICAgICAgICAgICBodG1sLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICAnPHRhYmxlIGNsYXNzPVwibXBfaGVhZFwiPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChlbnRyeSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBlbnRyeS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZW50cnkua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnRnJvbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnVG8nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0NjJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdCY2MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmh0bWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0RhdGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMub3B0aW9ucy5mb3JtYXREYXRlU3RyaW5nID8gdGhpcy5vcHRpb25zLmZvcm1hdERhdGVTdHJpbmcodmFsdWUpIDogdmFsdWUudG9VVENTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnU3ViamVjdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJzxzdHJvbmc+JyArIGhlLmVuY29kZSh2YWx1ZSkgKyAnPC9zdHJvbmc+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBoZS5lbmNvZGUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzx0cj48dGQgY2xhc3M9XCJtcF9oZWFkX2tleVwiPicgKyBoZS5lbmNvZGUoZW50cnkua2V5KSArICc6PC90ZD48dGQgY2xhc3M9XCJtcF9oZWFkX3ZhbHVlXCI+JyArIHZhbHVlICsgJzx0ZD48L3RyPic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCdcXG4nKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzx0YWJsZT4nXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc1RleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dC5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChlbnRyeSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBlbnRyeS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZW50cnkua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnRnJvbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnVG8nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0NjJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdCY2MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0RhdGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMub3B0aW9ucy5mb3JtYXREYXRlU3RyaW5nID8gdGhpcy5vcHRpb25zLmZvcm1hdERhdGVTdHJpbmcodmFsdWUpIDogdmFsdWUudG9VVENTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW50cnkua2V5ICsgJzogJyArIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuam9pbignXFxuJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcXG4nXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUudGV4dENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5jb250ZW50VHlwZSA9PT0gJ3RleHQvcGxhaW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQucHVzaChub2RlLnRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbHRlcm5hdGl2ZSAmJiB0aGlzLmhhc0h0bWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwucHVzaCh0aGlzLnRleHRUb0h0bWwobm9kZS50ZXh0Q29udGVudCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmNvbnRlbnRUeXBlID09PSAnbWVzc2FnZS9kZWxpdmVyeS1zdGF0dXMnICYmICF0aGlzLm9wdGlvbnMua2VlcERlbGl2ZXJ5U3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQucHVzaChub2RlLnRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbHRlcm5hdGl2ZSAmJiB0aGlzLmhhc0h0bWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwucHVzaCh0aGlzLnRleHRUb0h0bWwobm9kZS50ZXh0Q29udGVudCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmNvbnRlbnRUeXBlID09PSAndGV4dC9odG1sJykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmFpbGVkVG9QYXJzZUh0bWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCghYWx0ZXJuYXRpdmUgJiYgdGhpcy5oYXNUZXh0KSB8fCAobm9kZS5yb290ICYmICF0aGlzLmhhc1RleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNraXBIdG1sVG9UZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dC5wdXNoKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS50ZXh0Q29udGVudC5sZW5ndGggPiB0aGlzLm9wdGlvbnMubWF4SHRtbExlbmd0aFRvUGFyc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKGBIVE1MIHRvbyBsb25nIGZvciBwYXJzaW5nICR7bm9kZS50ZXh0Q29udGVudC5sZW5ndGh9IGJ5dGVzYCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQucHVzaCgnSW52YWxpZCBIVE1MIGNvbnRlbnQgKHRvbyBsb25nKScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWxlZFRvUGFyc2VIdG1sID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dC5wdXNoKGh0bWxUb1RleHQobm9kZS50ZXh0Q29udGVudCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdGYWlsZWQgdG8gcGFyc2UgSFRNTCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dC5wdXNoKCdJbnZhbGlkIEhUTUwgY29udGVudCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsZWRUb1BhcnNlSHRtbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghZmFpbGVkVG9QYXJzZUh0bWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwucHVzaChub2RlLnRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFsdGVybmF0aXZlID0gYWx0ZXJuYXRpdmUgfHwgbm9kZS5jb250ZW50VHlwZSA9PT0gJ211bHRpcGFydC9hbHRlcm5hdGl2ZSc7XG4gICAgICAgICAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChzdWJOb2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc05vZGUoYWx0ZXJuYXRpdmUsIGxldmVsICsgMSwgc3ViTm9kZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcHJvY2Vzc05vZGUoZmFsc2UsIDAsIHRoaXMudHJlZSk7XG5cbiAgICAgICAgbGV0IHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgdHlwZTogJ3RleHQnXG4gICAgICAgIH07XG4gICAgICAgIGlmIChodG1sLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5odG1sID0gcmVzcG9uc2UuaHRtbCA9IGh0bWwuam9pbignPGJyLz5cXG4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dCA9IHJlc3BvbnNlLnRleHQgPSB0ZXh0LmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgdGhpcy50ZXh0QXNIdG1sID0gcmVzcG9uc2UudGV4dEFzSHRtbCA9IHRleHQubWFwKHBhcnQgPT4gdGhpcy50ZXh0VG9IdG1sKHBhcnQpKS5qb2luKCc8YnIvPlxcbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG5cbiAgICBwcm9jZXNzQ2h1bmsoZGF0YSwgZG9uZSkge1xuICAgICAgICBsZXQgcGFydElkID0gbnVsbDtcbiAgICAgICAgaWYgKGRhdGEuX3BhcmVudEJvdW5kYXJ5KSB7XG4gICAgICAgICAgICBwYXJ0SWQgPSB0aGlzLl9nZXRQYXJ0SWQoZGF0YS5fcGFyZW50Qm91bmRhcnkpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZGF0YS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdub2RlJzoge1xuICAgICAgICAgICAgICAgIGxldCBub2RlID0gdGhpcy5jcmVhdGVOb2RlKGRhdGEpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlID09PSB0aGlzLnRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgWydzdWJqZWN0JywgJ3JlZmVyZW5jZXMnLCAnZGF0ZScsICd0bycsICdmcm9tJywgJ3RvJywgJ2NjJywgJ2JjYycsICdtZXNzYWdlLWlkJywgJ2luLXJlcGx5LXRvJywgJ3JlcGx5LXRvJ10uZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaGVhZGVycy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5LnJlcGxhY2UoLy0oW2Etel0pL2csIChtLCBjKSA9PiBjLnRvVXBwZXJDYXNlKCkpXSA9IG5vZGUuaGVhZGVycy5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnaGVhZGVycycsIG5vZGUuaGVhZGVycyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaGVhZGVyTGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnaGVhZGVyTGluZXMnLCBub2RlLmhlYWRlckxpbmVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChkYXRhLmNvbnRlbnRUeXBlID09PSAnbWVzc2FnZS9yZmM4MjInICYmIGRhdGEubWVzc2FnZU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEucGFyZW50Tm9kZSAmJiBkYXRhLnBhcmVudE5vZGUuY29udGVudFR5cGUgPT09ICdtZXNzYWdlL3JmYzgyMicpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zaG93TWV0YSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuaXNBdHRhY2htZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb250ZW50VHlwZSA9IG5vZGUuY29udGVudFR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyAmJiBkYXRhLmZpbGVuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZSA9IHRoaXMubGlibWltZS5kZXRlY3RNaW1lVHlwZShkYXRhLmZpbGVuYW1lKSB8fCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxldCBhdHRhY2htZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2F0dGFjaG1lbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVsZWFzZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnQucmVsZWFzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMud2FpdFVudGlsQXR0YWNobWVudEVuZCAmJiB0eXBlb2YgdGhpcy5hdHRhY2htZW50Q2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKHRoaXMuYXR0YWNobWVudENhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRhY2htZW50Q2FsbGJhY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndhaXRVbnRpbEF0dGFjaG1lbnRFbmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBsZXQgYWxnbyA9IHRoaXMub3B0aW9ucy5jaGVja3N1bUFsZ28gfHwgJ21kNSc7XG4gICAgICAgICAgICAgICAgICAgIGxldCBoYXNoZXIgPSBuZXcgU3RyZWFtSGFzaChhdHRhY2htZW50LCBhbGdvKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5kZWNvZGVyLm9uKCdlcnJvcicsIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNoZXIuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBub2RlLmRlY29kZXIub24oJ3JlYWRhYmxlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNodW5rO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGNodW5rID0gbm9kZS5kZWNvZGVyLnJlYWQoKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNoZXIud3JpdGUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBub2RlLmRlY29kZXIub25jZSgnZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzaGVyLmVuZCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvL25vZGUuZGVjb2Rlci5waXBlKGhhc2hlcik7XG4gICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnQuY29udGVudCA9IGhhc2hlcjtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLndhaXRVbnRpbEF0dGFjaG1lbnRFbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5kaXNwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNobWVudC5jb250ZW50RGlzcG9zaXRpb24gPSBkYXRhLmRpc3Bvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuZmlsZW5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnQuZmlsZW5hbWUgPSBkYXRhLmZpbGVuYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaGVhZGVycy5oYXMoJ2NvbnRlbnQtaWQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNobWVudC5jb250ZW50SWQgPSBbXS5jb25jYXQobm9kZS5oZWFkZXJzLmdldCgnY29udGVudC1pZCcpIHx8IFtdKS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNobWVudC5jaWQgPSBhdHRhY2htZW50LmNvbnRlbnRJZC50cmltKCkucmVwbGFjZSgvXjx8PiQvZywgJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBhdHRhY2htZW50IGlzIFwicmVsYXRlZFwiIHRvIHRleHQgY29udGVudCBsaWtlIGFuIGVtYmVkZGVkIGltYWdlIGV0Y1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBhcmVudE5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUuY29udGVudFR5cGUgPT09ICdtdWx0aXBhcnQvcmVsYXRlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNobWVudC5yZWxhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBhdHRhY2htZW50LmhlYWRlcnMgPSBub2RlLmhlYWRlcnM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaChhdHRhY2htZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRhY2htZW50TGlzdC5wdXNoKGF0dGFjaG1lbnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5kaXNwb3NpdGlvbiA9PT0gJ2lubGluZScpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNodW5rcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2h1bmtsZW4gPSAwO1xuICAgICAgICAgICAgICAgICAgICBub2RlLmNvbnRlbnRTdHJlYW0gPSBub2RlLmRlY29kZXI7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuY29udGVudFR5cGUgPT09ICd0ZXh0L3BsYWluJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYXNUZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmNvbnRlbnRUeXBlID09PSAndGV4dC9odG1sJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYXNIdG1sID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmNvbnRlbnRUeXBlID09PSAnbWVzc2FnZS9kZWxpdmVyeS1zdGF0dXMnICYmICF0aGlzLm9wdGlvbnMua2VlcERlbGl2ZXJ5U3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhc1RleHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZS5mbG93ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb250ZW50U3RyZWFtID0gbm9kZS5jb250ZW50U3RyZWFtO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZsb3dEZWNvZGVyID0gbmV3IEZsb3dlZERlY29kZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbFNwOiBub2RlLm5vZGUuZGVsU3BcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFN0cmVhbS5vbignZXJyb3InLCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb3dEZWNvZGVyLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFN0cmVhbS5waXBlKGZsb3dEZWNvZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY29udGVudFN0cmVhbSA9IGZsb3dEZWNvZGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGNoYXJzZXQgPSBub2RlLmNoYXJzZXQgfHwgJ3V0Zi04JztcbiAgICAgICAgICAgICAgICAgICAgLy9jaGFyc2V0ID0gY2hhcnNldCB8fCAnd2luZG93cy0xMjU3JztcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIVsnYXNjaWknLCAndXNhc2NpaScsICd1dGY4J10uaW5jbHVkZXMoY2hhcnNldC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1teYS16MC05XSsvZywgJycpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29udGVudFN0cmVhbSA9IG5vZGUuY29udGVudFN0cmVhbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGVjb2RlU3RyZWFtID0gdGhpcy5kZWNvZGVyLmRlY29kZVN0cmVhbShjaGFyc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50U3RyZWFtLm9uKCdlcnJvcicsIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZVN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFN0cmVhbS5waXBlKGRlY29kZVN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5jb250ZW50U3RyZWFtID0gZGVjb2RlU3RyZWFtO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBkZWNvZGUgY2hhcnNldFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jb250ZW50U3RyZWFtLm9uKCdyZWFkYWJsZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoY2h1bmsgPSBub2RlLmNvbnRlbnRTdHJlYW0ucmVhZCgpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVua3MucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtsZW4gKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBub2RlLmNvbnRlbnRTdHJlYW0ub25jZSgnZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS50ZXh0Q29udGVudCA9IEJ1ZmZlci5jb25jYXQoY2h1bmtzLCBjaHVua2xlbikudG9TdHJpbmcoKS5yZXBsYWNlKC9cXHI/XFxuL2csICdcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jb250ZW50U3RyZWFtLm9uY2UoJ2Vycm9yJywgZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnZGF0YSc6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3Vybm9kZSAmJiB0aGlzLmN1cm5vZGUuZGVjb2Rlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cm5vZGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy53YWl0VW50aWxBdHRhY2htZW50RW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNobWVudENhbGxiYWNrID0gZG9uZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG11bHRpcGFydCBtZXNzYWdlIHN0cnVjdHVyZVxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IHJlbGF0ZWQgdG8gYW55IHNwZWNpZmljICdub2RlJyBibG9jayBhcyBpdCBpbmNsdWRlc1xuICAgICAgICAgICAgICAgIC8vIGV2ZXJ5dGhpbmcgYmV0d2VlbiB0aGUgZW5kIG9mIHNvbWUgbm9kZSBib2R5IGFuZCBiZXR3ZWVuIHRoZSBuZXh0IGhlYWRlclxuICAgICAgICAgICAgICAgIC8vcHJvY2Vzcy5zdGRvdXQud3JpdGUoZGF0YS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cm5vZGUgJiYgdGhpcy5jdXJub2RlLmRlY29kZXIgJiYgdGhpcy5jdXJub2RlLmRlY29kZXIud3JpdGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY3Vybm9kZS5kZWNvZGVyLndyaXRlKGRhdGEudmFsdWUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3Vybm9kZS5kZWNvZGVyLm9uY2UoJ2RyYWluJywgZG9uZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBMZWFmIGVsZW1lbnQgYm9keS4gSW5jbHVkZXMgdGhlIGJvZHkgZm9yIHRoZSBsYXN0ICdub2RlJyBibG9jay4gWW91IG1pZ2h0XG4gICAgICAgICAgICAgICAgLy8gaGF2ZSBzZXZlcmFsICdib2R5JyBjYWxscyBmb3IgYSBzaW5nbGUgJ25vZGUnIGJsb2NrXG4gICAgICAgICAgICAgICAgLy9wcm9jZXNzLnN0ZG91dC53cml0ZShkYXRhLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHNldEltbWVkaWF0ZShkb25lKTtcbiAgICB9XG5cbiAgICBfZ2V0UGFydElkKHBhcmVudEJvdW5kYXJ5KSB7XG4gICAgICAgIGxldCBib3VuZGFyeUluZGV4ID0gdGhpcy5ib3VuZGFyaWVzLmZpbmRJbmRleChpdGVtID0+IGl0ZW0ubmFtZSA9PT0gcGFyZW50Qm91bmRhcnkpO1xuICAgICAgICBpZiAoYm91bmRhcnlJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuYm91bmRhcmllcy5wdXNoKHsgbmFtZTogcGFyZW50Qm91bmRhcnksIGNvdW50OiAxIH0pO1xuICAgICAgICAgICAgYm91bmRhcnlJbmRleCA9IHRoaXMuYm91bmRhcmllcy5sZW5ndGggLSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ib3VuZGFyaWVzW2JvdW5kYXJ5SW5kZXhdLmNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcnRJZCA9ICcxJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gYm91bmRhcnlJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkgcGFydElkID0gdGhpcy5ib3VuZGFyaWVzW2ldLmNvdW50LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBlbHNlIHBhcnRJZCArPSAnLicgKyB0aGlzLmJvdW5kYXJpZXNbaV0uY291bnQudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFydElkO1xuICAgIH1cblxuICAgIGdldEFkZHJlc3Nlc0hUTUwodmFsdWUpIHtcbiAgICAgICAgbGV0IGZvcm1hdFNpbmdsZUxldmVsID0gYWRkcmVzc2VzID0+XG4gICAgICAgICAgICBhZGRyZXNzZXNcbiAgICAgICAgICAgICAgICAubWFwKGFkZHJlc3MgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3RyID0gJzxzcGFuIGNsYXNzPVwibXBfYWRkcmVzc19ncm91cFwiPic7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGRyZXNzLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnPHNwYW4gY2xhc3M9XCJtcF9hZGRyZXNzX25hbWVcIj4nICsgaGUuZW5jb2RlKGFkZHJlc3MubmFtZSkgKyAoYWRkcmVzcy5ncm91cCA/ICc6ICcgOiAnJykgKyAnPC9zcGFuPic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MuYWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmsgPSAnPGEgaHJlZj1cIm1haWx0bzonICsgaGUuZW5jb2RlKGFkZHJlc3MuYWRkcmVzcykgKyAnXCIgY2xhc3M9XCJtcF9hZGRyZXNzX2VtYWlsXCI+JyArIGhlLmVuY29kZShhZGRyZXNzLmFkZHJlc3MpICsgJzwvYT4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnICZsdDsnICsgbGluayArICcmZ3Q7JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGxpbms7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MuZ3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBmb3JtYXRTaW5nbGVMZXZlbChhZGRyZXNzLmdyb3VwKSArICc7JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyICsgJzwvc3Bhbj4nO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgICAgIHJldHVybiBmb3JtYXRTaW5nbGVMZXZlbChbXS5jb25jYXQodmFsdWUgfHwgW10pKTtcbiAgICB9XG5cbiAgICBnZXRBZGRyZXNzZXNUZXh0KHZhbHVlKSB7XG4gICAgICAgIGxldCBmb3JtYXRTaW5nbGVMZXZlbCA9IGFkZHJlc3NlcyA9PlxuICAgICAgICAgICAgYWRkcmVzc2VzXG4gICAgICAgICAgICAgICAgLm1hcChhZGRyZXNzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0ciA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkcmVzcy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gYFwiJHthZGRyZXNzLm5hbWV9XCJgICsgKGFkZHJlc3MuZ3JvdXAgPyAnOiAnIDogJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGRyZXNzLmFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsaW5rID0gYWRkcmVzcy5hZGRyZXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnIDwnICsgbGluayArICc+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGxpbms7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MuZ3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBmb3JtYXRTaW5nbGVMZXZlbChhZGRyZXNzLmdyb3VwKSArICc7JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgICAgIHJldHVybiBmb3JtYXRTaW5nbGVMZXZlbChbXS5jb25jYXQodmFsdWUgfHwgW10pKTtcbiAgICB9XG5cbiAgICB1cGRhdGVJbWFnZUxpbmtzKHJlcGxhY2VDYWxsYmFjaywgZG9uZSkge1xuICAgICAgICBpZiAoIXRoaXMuaHRtbCkge1xuICAgICAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZSgoKSA9PiBkb25lKG51bGwsIGZhbHNlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY2lkcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgbGV0IGh0bWwgPSAodGhpcy5odG1sIHx8ICcnKS50b1N0cmluZygpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2tpcEltYWdlTGlua3MpIHtcbiAgICAgICAgICAgIHJldHVybiBkb25lKG51bGwsIGh0bWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaHRtbC5yZXBsYWNlKC9cXGJjaWQ6KFteJ1wiXFxzXXsxLDI1Nn0pL2csIChtYXRjaCwgY2lkKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5hdHRhY2htZW50TGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dGFjaG1lbnRMaXN0W2ldLmNpZCA9PT0gY2lkICYmIC9eaW1hZ2VcXC9bXFx3XSskL2kudGVzdCh0aGlzLmF0dGFjaG1lbnRMaXN0W2ldLmNvbnRlbnRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBjaWRzLnNldChjaWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnQ6IHRoaXMuYXR0YWNobWVudExpc3RbaV1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IGNpZExpc3QgPSBbXTtcbiAgICAgICAgY2lkcy5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgICAgICAgIGNpZExpc3QucHVzaChlbnRyeSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICBsZXQgcHJvY2Vzc05leHQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocG9zID49IGNpZExpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaHRtbCA9IGh0bWwucmVwbGFjZSgvXFxiY2lkOihbXidcIlxcc117MSwyNTZ9KS9nLCAobWF0Y2gsIGNpZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2lkcy5oYXMoY2lkKSAmJiBjaWRzLmdldChjaWQpLnVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNpZHMuZ2V0KGNpZCkudXJsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBkb25lKG51bGwsIGh0bWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGVudHJ5ID0gY2lkTGlzdFtwb3MrK107XG4gICAgICAgICAgICByZXBsYWNlQ2FsbGJhY2soZW50cnkuYXR0YWNobWVudCwgKGVyciwgdXJsKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0SW1tZWRpYXRlKCgpID0+IGRvbmUoZXJyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVudHJ5LnVybCA9IHVybDtcbiAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUocHJvY2Vzc05leHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2V0SW1tZWRpYXRlKHByb2Nlc3NOZXh0KTtcbiAgICB9XG5cbiAgICB0ZXh0VG9IdG1sKHN0cikge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNraXBUZXh0VG9IdG1sKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgc3RyID0gKHN0ciB8fCAnJykudG9TdHJpbmcoKTtcbiAgICAgICAgbGV0IGVuY29kZWQ7XG5cbiAgICAgICAgbGV0IGxpbmtpZmllZCA9IGZhbHNlO1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5za2lwVGV4dExpbmtzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChsaW5raWZ5LnByZXRlc3Qoc3RyKSkge1xuICAgICAgICAgICAgICAgICAgICBsaW5raWZpZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGlua3MgPSBsaW5raWZ5Lm1hdGNoKHN0cikgfHwgW107XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhc3QgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIGxpbmtzLmZvckVhY2gobGluayA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdCA8IGxpbmsuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGV4dFBhcnQgPSBoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbmNvZGUgc3BlY2lhbCBjaGFyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZW5jb2RlKHN0ci5zbGljZShsYXN0LCBsaW5rLmluZGV4KSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlTmFtZWRSZWZlcmVuY2VzOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRleHRQYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYDxhIGhyZWY9XCIke2xpbmsudXJsfVwiPiR7bGluay50ZXh0fTwvYT5gKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdCA9IGxpbmsubGFzdEluZGV4O1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBsZXQgdGV4dFBhcnQgPSBoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5jb2RlIHNwZWNpYWwgY2hhcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5lbmNvZGUoc3RyLnNsaWNlKGxhc3QpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlTmFtZWRSZWZlcmVuY2VzOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGV4dFBhcnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGVuY29kZWQgPSByZXN1bHQuam9pbignJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoRSkge1xuICAgICAgICAgICAgICAgIC8vIGZhaWxlZCwgZG9uJ3QgbGlua2lmeVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFsaW5raWZpZWQpIHtcbiAgICAgICAgICAgIGVuY29kZWQgPSBoZVxuICAgICAgICAgICAgICAgIC8vIGVuY29kZSBzcGVjaWFsIGNoYXJzXG4gICAgICAgICAgICAgICAgLmVuY29kZShzdHIsIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlTmFtZWRSZWZlcmVuY2VzOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdGV4dCA9XG4gICAgICAgICAgICAnPHA+JyArXG4gICAgICAgICAgICBlbmNvZGVkXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xccj9cXG4vZywgJ1xcbicpXG4gICAgICAgICAgICAgICAgLnRyaW0oKSAvLyBub3JtYWxpemUgbGluZSBlbmRpbmdzXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1sgXFx0XSskL2dtLCAnJylcbiAgICAgICAgICAgICAgICAudHJpbSgpIC8vIHRyaW0gZW1wdHkgbGluZSBlbmRpbmdzXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcblxcbisvZywgJzwvcD48cD4nKVxuICAgICAgICAgICAgICAgIC50cmltKCkgLy8gaW5zZXJ0IDxwPiB0byBtdWx0aXBsZSBsaW5lYnJlYWtzXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcbi9nLCAnPGJyLz4nKSArIC8vIGluc2VydCA8YnI+IHRvIHNpbmdsZSBsaW5lYnJlYWtzXG4gICAgICAgICAgICAnPC9wPic7XG5cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1haWxQYXJzZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/mailparser/lib/mail-parser.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/mailparser/lib/simple-parser.js":
/*!*******************************************************!*\
  !*** ../node_modules/mailparser/lib/simple-parser.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst MailParser = __webpack_require__(/*! ./mail-parser.js */ \"(rsc)/../node_modules/mailparser/lib/mail-parser.js\");\n\nmodule.exports = (input, options, callback) => {\n    if (input === null || input === undefined) {\n        throw new TypeError('Input cannot be null or undefined.');\n    }\n\n    if (!callback && typeof options === 'function') {\n        callback = options;\n        options = false;\n    }\n\n    let promise;\n    if (!callback) {\n        promise = new Promise((resolve, reject) => {\n            callback = callbackPromise(resolve, reject);\n        });\n    }\n\n    options = options || {};\n    let keepCidLinks = !!options.keepCidLinks;\n\n    let mail = {\n        attachments: []\n    };\n\n    let parser = new MailParser(options);\n\n    parser.on('error', err => {\n        callback(err);\n    });\n\n    parser.on('headers', headers => {\n        mail.headers = headers;\n        mail.headerLines = parser.headerLines;\n    });\n\n    let reading = false;\n    let reader = () => {\n        reading = true;\n\n        let data = parser.read();\n\n        if (data === null) {\n            reading = false;\n            return;\n        }\n\n        if (data.type === 'text') {\n            Object.keys(data).forEach(key => {\n                if (['text', 'html', 'textAsHtml'].includes(key)) {\n                    mail[key] = data[key];\n                }\n            });\n        }\n\n        if (data.type === 'attachment') {\n            mail.attachments.push(data);\n\n            let chunks = [];\n            let chunklen = 0;\n            data.content.on('readable', () => {\n                let chunk;\n                while ((chunk = data.content.read()) !== null) {\n                    chunks.push(chunk);\n                    chunklen += chunk.length;\n                }\n            });\n\n            data.content.on('end', () => {\n                data.content = Buffer.concat(chunks, chunklen);\n                data.release();\n                reader();\n            });\n        } else {\n            reader();\n        }\n    };\n\n    parser.on('readable', () => {\n        if (!reading) {\n            reader();\n        }\n    });\n\n    parser.on('end', () => {\n        ['subject', 'references', 'date', 'to', 'from', 'to', 'cc', 'bcc', 'message-id', 'in-reply-to', 'reply-to'].forEach(key => {\n            if (mail.headers && mail.headers.has(key)) {\n                mail[key.replace(/-([a-z])/g, (m, c) => c.toUpperCase())] = mail.headers.get(key);\n            }\n        });\n\n        if (keepCidLinks) {\n            return callback(null, mail);\n        }\n        parser.updateImageLinks(\n            (attachment, done) => done(false, 'data:' + attachment.contentType + ';base64,' + attachment.content.toString('base64')),\n            (err, html) => {\n                if (err) {\n                    return callback(err);\n                }\n                mail.html = html;\n\n                callback(null, mail);\n            }\n        );\n    });\n\n    if (typeof input === 'string') {\n        parser.end(Buffer.from(input));\n    } else if (Buffer.isBuffer(input)) {\n        parser.end(input);\n    } else {\n        input\n            .once('error', err => {\n                input.destroy();\n                parser.destroy();\n                callback(err);\n            })\n            .pipe(parser);\n    }\n\n    return promise;\n};\n\nfunction callbackPromise(resolve, reject) {\n    return function (...args) {\n        let err = args.shift();\n        if (err) {\n            reject(err);\n        } else {\n            resolve(...args);\n        }\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL21haWxwYXJzZXIvbGliL3NpbXBsZS1wYXJzZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsbUJBQW1CLG1CQUFPLENBQUMsNkVBQWtCOztBQUU3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxrZnJ5dFxcLmdlbWluaVxcYW50aWdyYXZpdHlcXHNjcmF0Y2hcXGRyX2thbHNfdmlydHVhbF9ob3NwaXRhbFxcbm9kZV9tb2R1bGVzXFxtYWlscGFyc2VyXFxsaWJcXHNpbXBsZS1wYXJzZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNYWlsUGFyc2VyID0gcmVxdWlyZSgnLi9tYWlsLXBhcnNlci5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChpbnB1dCwgb3B0aW9ucywgY2FsbGJhY2spID0+IHtcbiAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgaW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnB1dCBjYW5ub3QgYmUgbnVsbCBvciB1bmRlZmluZWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKCFjYWxsYmFjayAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgcHJvbWlzZTtcbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrUHJvbWlzZShyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBsZXQga2VlcENpZExpbmtzID0gISFvcHRpb25zLmtlZXBDaWRMaW5rcztcblxuICAgIGxldCBtYWlsID0ge1xuICAgICAgICBhdHRhY2htZW50czogW11cbiAgICB9O1xuXG4gICAgbGV0IHBhcnNlciA9IG5ldyBNYWlsUGFyc2VyKG9wdGlvbnMpO1xuXG4gICAgcGFyc2VyLm9uKCdlcnJvcicsIGVyciA9PiB7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfSk7XG5cbiAgICBwYXJzZXIub24oJ2hlYWRlcnMnLCBoZWFkZXJzID0+IHtcbiAgICAgICAgbWFpbC5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgbWFpbC5oZWFkZXJMaW5lcyA9IHBhcnNlci5oZWFkZXJMaW5lcztcbiAgICB9KTtcblxuICAgIGxldCByZWFkaW5nID0gZmFsc2U7XG4gICAgbGV0IHJlYWRlciA9ICgpID0+IHtcbiAgICAgICAgcmVhZGluZyA9IHRydWU7XG5cbiAgICAgICAgbGV0IGRhdGEgPSBwYXJzZXIucmVhZCgpO1xuXG4gICAgICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICByZWFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGRhdGEpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoWyd0ZXh0JywgJ2h0bWwnLCAndGV4dEFzSHRtbCddLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbFtrZXldID0gZGF0YVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ2F0dGFjaG1lbnQnKSB7XG4gICAgICAgICAgICBtYWlsLmF0dGFjaG1lbnRzLnB1c2goZGF0YSk7XG5cbiAgICAgICAgICAgIGxldCBjaHVua3MgPSBbXTtcbiAgICAgICAgICAgIGxldCBjaHVua2xlbiA9IDA7XG4gICAgICAgICAgICBkYXRhLmNvbnRlbnQub24oJ3JlYWRhYmxlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBjaHVuaztcbiAgICAgICAgICAgICAgICB3aGlsZSAoKGNodW5rID0gZGF0YS5jb250ZW50LnJlYWQoKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICBjaHVua2xlbiArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRhdGEuY29udGVudC5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRhdGEuY29udGVudCA9IEJ1ZmZlci5jb25jYXQoY2h1bmtzLCBjaHVua2xlbik7XG4gICAgICAgICAgICAgICAgZGF0YS5yZWxlYXNlKCk7XG4gICAgICAgICAgICAgICAgcmVhZGVyKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlYWRlcigpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHBhcnNlci5vbigncmVhZGFibGUnLCAoKSA9PiB7XG4gICAgICAgIGlmICghcmVhZGluZykge1xuICAgICAgICAgICAgcmVhZGVyKCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHBhcnNlci5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICBbJ3N1YmplY3QnLCAncmVmZXJlbmNlcycsICdkYXRlJywgJ3RvJywgJ2Zyb20nLCAndG8nLCAnY2MnLCAnYmNjJywgJ21lc3NhZ2UtaWQnLCAnaW4tcmVwbHktdG8nLCAncmVwbHktdG8nXS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBpZiAobWFpbC5oZWFkZXJzICYmIG1haWwuaGVhZGVycy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIG1haWxba2V5LnJlcGxhY2UoLy0oW2Etel0pL2csIChtLCBjKSA9PiBjLnRvVXBwZXJDYXNlKCkpXSA9IG1haWwuaGVhZGVycy5nZXQoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGtlZXBDaWRMaW5rcykge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIG1haWwpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlci51cGRhdGVJbWFnZUxpbmtzKFxuICAgICAgICAgICAgKGF0dGFjaG1lbnQsIGRvbmUpID0+IGRvbmUoZmFsc2UsICdkYXRhOicgKyBhdHRhY2htZW50LmNvbnRlbnRUeXBlICsgJztiYXNlNjQsJyArIGF0dGFjaG1lbnQuY29udGVudC50b1N0cmluZygnYmFzZTY0JykpLFxuICAgICAgICAgICAgKGVyciwgaHRtbCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1haWwuaHRtbCA9IGh0bWw7XG5cbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBtYWlsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9KTtcblxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhcnNlci5lbmQoQnVmZmVyLmZyb20oaW5wdXQpKTtcbiAgICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihpbnB1dCkpIHtcbiAgICAgICAgcGFyc2VyLmVuZChpbnB1dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXRcbiAgICAgICAgICAgIC5vbmNlKCdlcnJvcicsIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgaW5wdXQuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIHBhcnNlci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucGlwZShwYXJzZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xufTtcblxuZnVuY3Rpb24gY2FsbGJhY2tQcm9taXNlKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBsZXQgZXJyID0gYXJncy5zaGlmdCgpO1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/mailparser/lib/simple-parser.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/mailparser/lib/stream-hash.js":
/*!*****************************************************!*\
  !*** ../node_modules/mailparser/lib/stream-hash.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst Transform = (__webpack_require__(/*! stream */ \"stream\").Transform);\n\nclass StreamHash extends Transform {\n    constructor(attachment, algo) {\n        super();\n        this.attachment = attachment;\n        this.algo = (algo || 'md5').toLowerCase();\n        this.hash = crypto.createHash(algo);\n        this.byteCount = 0;\n    }\n\n    _transform(chunk, encoding, done) {\n        this.hash.update(chunk);\n        this.byteCount += chunk.length;\n        done(null, chunk);\n    }\n\n    _flush(done) {\n        this.attachment.checksum = this.hash.digest('hex');\n        this.attachment.size = this.byteCount;\n        done();\n    }\n}\n\nmodule.exports = StreamHash;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL21haWxwYXJzZXIvbGliL3N0cmVhbS1oYXNoLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixrQkFBa0IsdURBQTJCOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGtmcnl0XFwuZ2VtaW5pXFxhbnRpZ3Jhdml0eVxcc2NyYXRjaFxcZHJfa2Fsc192aXJ0dWFsX2hvc3BpdGFsXFxub2RlX21vZHVsZXNcXG1haWxwYXJzZXJcXGxpYlxcc3RyZWFtLWhhc2guanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbmNvbnN0IFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3N0cmVhbScpLlRyYW5zZm9ybTtcblxuY2xhc3MgU3RyZWFtSGFzaCBleHRlbmRzIFRyYW5zZm9ybSB7XG4gICAgY29uc3RydWN0b3IoYXR0YWNobWVudCwgYWxnbykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmF0dGFjaG1lbnQgPSBhdHRhY2htZW50O1xuICAgICAgICB0aGlzLmFsZ28gPSAoYWxnbyB8fCAnbWQ1JykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdGhpcy5oYXNoID0gY3J5cHRvLmNyZWF0ZUhhc2goYWxnbyk7XG4gICAgICAgIHRoaXMuYnl0ZUNvdW50ID0gMDtcbiAgICB9XG5cbiAgICBfdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgZG9uZSkge1xuICAgICAgICB0aGlzLmhhc2gudXBkYXRlKGNodW5rKTtcbiAgICAgICAgdGhpcy5ieXRlQ291bnQgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICBkb25lKG51bGwsIGNodW5rKTtcbiAgICB9XG5cbiAgICBfZmx1c2goZG9uZSkge1xuICAgICAgICB0aGlzLmF0dGFjaG1lbnQuY2hlY2tzdW0gPSB0aGlzLmhhc2guZGlnZXN0KCdoZXgnKTtcbiAgICAgICAgdGhpcy5hdHRhY2htZW50LnNpemUgPSB0aGlzLmJ5dGVDb3VudDtcbiAgICAgICAgZG9uZSgpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW1IYXNoO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/mailparser/lib/stream-hash.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/dbcs-codec.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/mailparser/node_modules/iconv-lite/encodings/dbcs-codec.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(rsc)/../node_modules/safer-buffer/safer.js\").Buffer)\n\n// Multibyte codec. In this scheme, a character is represented by 1 or more bytes.\n// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.\n// To save memory and loading time, we read table files only when requested.\n\nexports._dbcs = DBCSCodec\n\nvar UNASSIGNED = -1\nvar GB18030_CODE = -2\nvar SEQ_START = -10\nvar NODE_START = -1000\nvar UNASSIGNED_NODE = new Array(0x100)\nvar DEF_CHAR = -1\n\nfor (var i = 0; i < 0x100; i++) { UNASSIGNED_NODE[i] = UNASSIGNED }\n\n// Class DBCSCodec reads and initializes mapping tables.\nfunction DBCSCodec (codecOptions, iconv) {\n  this.encodingName = codecOptions.encodingName\n  if (!codecOptions) { throw new Error(\"DBCS codec is called without the data.\") }\n  if (!codecOptions.table) { throw new Error(\"Encoding '\" + this.encodingName + \"' has no data.\") }\n\n  // Load tables.\n  var mappingTable = codecOptions.table()\n\n  // Decode tables: MBCS -> Unicode.\n\n  // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.\n  // Trie root is decodeTables[0].\n  // Values: >=  0 -> unicode character code. can be > 0xFFFF\n  //         == UNASSIGNED -> unknown/unassigned sequence.\n  //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.\n  //         <= NODE_START -> index of the next node in our trie to process next byte.\n  //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.\n  this.decodeTables = []\n  this.decodeTables[0] = UNASSIGNED_NODE.slice(0) // Create root node.\n\n  // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here.\n  this.decodeTableSeq = []\n\n  // Actual mapping tables consist of chunks. Use them to fill up decode tables.\n  for (var i = 0; i < mappingTable.length; i++) { this._addDecodeChunk(mappingTable[i]) }\n\n  // Load & create GB18030 tables when needed.\n  if (typeof codecOptions.gb18030 === \"function\") {\n    this.gb18030 = codecOptions.gb18030() // Load GB18030 ranges.\n\n    // Add GB18030 common decode nodes.\n    var commonThirdByteNodeIdx = this.decodeTables.length\n    this.decodeTables.push(UNASSIGNED_NODE.slice(0))\n\n    var commonFourthByteNodeIdx = this.decodeTables.length\n    this.decodeTables.push(UNASSIGNED_NODE.slice(0))\n\n    // Fill out the tree\n    var firstByteNode = this.decodeTables[0]\n    for (var i = 0x81; i <= 0xFE; i++) {\n      var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i]]\n      for (var j = 0x30; j <= 0x39; j++) {\n        if (secondByteNode[j] === UNASSIGNED) {\n          secondByteNode[j] = NODE_START - commonThirdByteNodeIdx\n        } else if (secondByteNode[j] > NODE_START) {\n          throw new Error(\"gb18030 decode tables conflict at byte 2\")\n        }\n\n        var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]]\n        for (var k = 0x81; k <= 0xFE; k++) {\n          if (thirdByteNode[k] === UNASSIGNED) {\n            thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx\n          } else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) {\n            continue\n          } else if (thirdByteNode[k] > NODE_START) {\n            throw new Error(\"gb18030 decode tables conflict at byte 3\")\n          }\n\n          var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]]\n          for (var l = 0x30; l <= 0x39; l++) {\n            if (fourthByteNode[l] === UNASSIGNED) { fourthByteNode[l] = GB18030_CODE }\n          }\n        }\n      }\n    }\n  }\n\n  this.defaultCharUnicode = iconv.defaultCharUnicode\n\n  // Encode tables: Unicode -> DBCS.\n\n  // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.\n  // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.\n  // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).\n  //         == UNASSIGNED -> no conversion found. Output a default char.\n  //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.\n  this.encodeTable = []\n\n  // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of\n  // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key\n  // means end of sequence (needed when one sequence is a strict subsequence of another).\n  // Objects are kept separately from encodeTable to increase performance.\n  this.encodeTableSeq = []\n\n  // Some chars can be decoded, but need not be encoded.\n  var skipEncodeChars = {}\n  if (codecOptions.encodeSkipVals) {\n    for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {\n      var val = codecOptions.encodeSkipVals[i]\n      if (typeof val === \"number\") { skipEncodeChars[val] = true } else {\n        for (var j = val.from; j <= val.to; j++) { skipEncodeChars[j] = true }\n      }\n    }\n  }\n\n  // Use decode trie to recursively fill out encode tables.\n  this._fillEncodeTable(0, 0, skipEncodeChars)\n\n  // Add more encoding pairs when needed.\n  if (codecOptions.encodeAdd) {\n    for (var uChar in codecOptions.encodeAdd) {\n      if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar)) { this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]) }\n    }\n  }\n\n  this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)]\n  if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0][\"?\"]\n  if (this.defCharSB === UNASSIGNED) this.defCharSB = \"?\".charCodeAt(0)\n}\n\nDBCSCodec.prototype.encoder = DBCSEncoder\nDBCSCodec.prototype.decoder = DBCSDecoder\n\n// Decoder helpers\nDBCSCodec.prototype._getDecodeTrieNode = function (addr) {\n  var bytes = []\n  for (; addr > 0; addr >>>= 8) { bytes.push(addr & 0xFF) }\n  if (bytes.length == 0) { bytes.push(0) }\n\n  var node = this.decodeTables[0]\n  for (var i = bytes.length - 1; i > 0; i--) { // Traverse nodes deeper into the trie.\n    var val = node[bytes[i]]\n\n    if (val == UNASSIGNED) { // Create new node.\n      node[bytes[i]] = NODE_START - this.decodeTables.length\n      this.decodeTables.push(node = UNASSIGNED_NODE.slice(0))\n    } else if (val <= NODE_START) { // Existing node.\n      node = this.decodeTables[NODE_START - val]\n    } else { throw new Error(\"Overwrite byte in \" + this.encodingName + \", addr: \" + addr.toString(16)) }\n  }\n  return node\n}\n\nDBCSCodec.prototype._addDecodeChunk = function (chunk) {\n  // First element of chunk is the hex mbcs code where we start.\n  var curAddr = parseInt(chunk[0], 16)\n\n  // Choose the decoding node where we'll write our chars.\n  var writeTable = this._getDecodeTrieNode(curAddr)\n  curAddr = curAddr & 0xFF\n\n  // Write all other elements of the chunk to the table.\n  for (var k = 1; k < chunk.length; k++) {\n    var part = chunk[k]\n    if (typeof part === \"string\") { // String, write as-is.\n      for (var l = 0; l < part.length;) {\n        var code = part.charCodeAt(l++)\n        if (code >= 0xD800 && code < 0xDC00) { // Decode surrogate\n          var codeTrail = part.charCodeAt(l++)\n          if (codeTrail >= 0xDC00 && codeTrail < 0xE000) { writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00) } else { throw new Error(\"Incorrect surrogate pair in \" + this.encodingName + \" at chunk \" + chunk[0]) }\n        } else if (code > 0x0FF0 && code <= 0x0FFF) { // Character sequence (our own encoding used)\n          var len = 0xFFF - code + 2\n          var seq = []\n          for (var m = 0; m < len; m++) { seq.push(part.charCodeAt(l++)) } // Simple variation: don't support surrogates or subsequences in seq.\n\n          writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length\n          this.decodeTableSeq.push(seq)\n        } else { writeTable[curAddr++] = code } // Basic char\n      }\n    } else if (typeof part === \"number\") { // Integer, meaning increasing sequence starting with prev character.\n      var charCode = writeTable[curAddr - 1] + 1\n      for (var l = 0; l < part; l++) { writeTable[curAddr++] = charCode++ }\n    } else { throw new Error(\"Incorrect type '\" + typeof part + \"' given in \" + this.encodingName + \" at chunk \" + chunk[0]) }\n  }\n  if (curAddr > 0xFF) { throw new Error(\"Incorrect chunk in \" + this.encodingName + \" at addr \" + chunk[0] + \": too long\" + curAddr) }\n}\n\n// Encoder helpers\nDBCSCodec.prototype._getEncodeBucket = function (uCode) {\n  var high = uCode >> 8 // This could be > 0xFF because of astral characters.\n  if (this.encodeTable[high] === undefined) {\n    this.encodeTable[high] = UNASSIGNED_NODE.slice(0)\n  } // Create bucket on demand.\n  return this.encodeTable[high]\n}\n\nDBCSCodec.prototype._setEncodeChar = function (uCode, dbcsCode) {\n  var bucket = this._getEncodeBucket(uCode)\n  var low = uCode & 0xFF\n  if (bucket[low] <= SEQ_START) { this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode } // There's already a sequence, set a single-char subsequence of it.\n  else if (bucket[low] == UNASSIGNED) { bucket[low] = dbcsCode }\n}\n\nDBCSCodec.prototype._setEncodeSequence = function (seq, dbcsCode) {\n  // Get the root of character tree according to first character of the sequence.\n  var uCode = seq[0]\n  var bucket = this._getEncodeBucket(uCode)\n  var low = uCode & 0xFF\n\n  var node\n  if (bucket[low] <= SEQ_START) {\n    // There's already a sequence with  - use it.\n    node = this.encodeTableSeq[SEQ_START - bucket[low]]\n  } else {\n    // There was no sequence object - allocate a new one.\n    node = {}\n    if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low] // If a char was set before - make it a single-char subsequence.\n    bucket[low] = SEQ_START - this.encodeTableSeq.length\n    this.encodeTableSeq.push(node)\n  }\n\n  // Traverse the character tree, allocating new nodes as needed.\n  for (var j = 1; j < seq.length - 1; j++) {\n    var oldVal = node[uCode]\n    if (typeof oldVal === \"object\") { node = oldVal } else {\n      node = node[uCode] = {}\n      if (oldVal !== undefined) { node[DEF_CHAR] = oldVal }\n    }\n  }\n\n  // Set the leaf to given dbcsCode.\n  uCode = seq[seq.length - 1]\n  node[uCode] = dbcsCode\n}\n\nDBCSCodec.prototype._fillEncodeTable = function (nodeIdx, prefix, skipEncodeChars) {\n  var node = this.decodeTables[nodeIdx]\n  var hasValues = false\n  var subNodeEmpty = {}\n  for (var i = 0; i < 0x100; i++) {\n    var uCode = node[i]\n    var mbCode = prefix + i\n    if (skipEncodeChars[mbCode]) { continue }\n\n    if (uCode >= 0) {\n      this._setEncodeChar(uCode, mbCode)\n      hasValues = true\n    } else if (uCode <= NODE_START) {\n      var subNodeIdx = NODE_START - uCode\n      if (!subNodeEmpty[subNodeIdx]) {  // Skip empty subtrees (they are too large in gb18030).\n        var newPrefix = (mbCode << 8) >>> 0  // NOTE: '>>> 0' keeps 32-bit num positive.\n        if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars)) { hasValues = true } else { subNodeEmpty[subNodeIdx] = true }\n      }\n    } else if (uCode <= SEQ_START) {\n      this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode)\n      hasValues = true\n    }\n  }\n  return hasValues\n}\n\n// == Encoder ==================================================================\n\nfunction DBCSEncoder (options, codec) {\n  // Encoder state\n  this.leadSurrogate = -1\n  this.seqObj = undefined\n\n  // Static data\n  this.encodeTable = codec.encodeTable\n  this.encodeTableSeq = codec.encodeTableSeq\n  this.defaultCharSingleByte = codec.defCharSB\n  this.gb18030 = codec.gb18030\n}\n\nDBCSEncoder.prototype.write = function (str) {\n  var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3))\n  var leadSurrogate = this.leadSurrogate\n  var seqObj = this.seqObj\n  var nextChar = -1\n  var i = 0; var j = 0\n\n  while (true) {\n    // 0. Get next character.\n    if (nextChar === -1) {\n      if (i == str.length) break\n      var uCode = str.charCodeAt(i++)\n    } else {\n      var uCode = nextChar\n      nextChar = -1\n    }\n\n    // 1. Handle surrogates.\n    if (uCode >= 0xD800 && uCode < 0xE000) { // Char is one of surrogates.\n      if (uCode < 0xDC00) { // We've got lead surrogate.\n        if (leadSurrogate === -1) {\n          leadSurrogate = uCode\n          continue\n        } else {\n          leadSurrogate = uCode\n          // Double lead surrogate found.\n          uCode = UNASSIGNED\n        }\n      } else { // We've got trail surrogate.\n        if (leadSurrogate !== -1) {\n          uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00)\n          leadSurrogate = -1\n        } else {\n          // Incomplete surrogate pair - only trail surrogate found.\n          uCode = UNASSIGNED\n        }\n      }\n    } else if (leadSurrogate !== -1) {\n      // Incomplete surrogate pair - only lead surrogate found.\n      nextChar = uCode; uCode = UNASSIGNED // Write an error, then current char.\n      leadSurrogate = -1\n    }\n\n    // 2. Convert uCode character.\n    var dbcsCode = UNASSIGNED\n    if (seqObj !== undefined && uCode != UNASSIGNED) { // We are in the middle of the sequence\n      var resCode = seqObj[uCode]\n      if (typeof resCode === \"object\") { // Sequence continues.\n        seqObj = resCode\n        continue\n      } else if (typeof resCode === \"number\") { // Sequence finished. Write it.\n        dbcsCode = resCode\n      } else if (resCode == undefined) { // Current character is not part of the sequence.\n        // Try default character for this sequence\n        resCode = seqObj[DEF_CHAR]\n        if (resCode !== undefined) {\n          dbcsCode = resCode // Found. Write it.\n          nextChar = uCode // Current character will be written too in the next iteration.\n        } else {\n          // TODO: What if we have no default? (resCode == undefined)\n          // Then, we should write first char of the sequence as-is and try the rest recursively.\n          // Didn't do it for now because no encoding has this situation yet.\n          // Currently, just skip the sequence and write current char.\n        }\n      }\n      seqObj = undefined\n    } else if (uCode >= 0) {  // Regular character\n      var subtable = this.encodeTable[uCode >> 8]\n      if (subtable !== undefined) { dbcsCode = subtable[uCode & 0xFF] }\n\n      if (dbcsCode <= SEQ_START) { // Sequence start\n        seqObj = this.encodeTableSeq[SEQ_START - dbcsCode]\n        continue\n      }\n\n      if (dbcsCode == UNASSIGNED && this.gb18030) {\n        // Use GB18030 algorithm to find character(s) to write.\n        var idx = findIdx(this.gb18030.uChars, uCode)\n        if (idx != -1) {\n          var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx])\n          newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600); dbcsCode = dbcsCode % 12600\n          newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260); dbcsCode = dbcsCode % 1260\n          newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10); dbcsCode = dbcsCode % 10\n          newBuf[j++] = 0x30 + dbcsCode\n          continue\n        }\n      }\n    }\n\n    // 3. Write dbcsCode character.\n    if (dbcsCode === UNASSIGNED) { dbcsCode = this.defaultCharSingleByte }\n\n    if (dbcsCode < 0x100) {\n      newBuf[j++] = dbcsCode\n    } else if (dbcsCode < 0x10000) {\n      newBuf[j++] = dbcsCode >> 8   // high byte\n      newBuf[j++] = dbcsCode & 0xFF // low byte\n    } else if (dbcsCode < 0x1000000) {\n      newBuf[j++] = dbcsCode >> 16\n      newBuf[j++] = (dbcsCode >> 8) & 0xFF\n      newBuf[j++] = dbcsCode & 0xFF\n    } else {\n      newBuf[j++] = dbcsCode >>> 24\n      newBuf[j++] = (dbcsCode >>> 16) & 0xFF\n      newBuf[j++] = (dbcsCode >>> 8) & 0xFF\n      newBuf[j++] = dbcsCode & 0xFF\n    }\n  }\n\n  this.seqObj = seqObj\n  this.leadSurrogate = leadSurrogate\n  return newBuf.slice(0, j)\n}\n\nDBCSEncoder.prototype.end = function () {\n  if (this.leadSurrogate === -1 && this.seqObj === undefined) { return } // All clean. Most often case.\n\n  var newBuf = Buffer.alloc(10); var j = 0\n\n  if (this.seqObj) { // We're in the sequence.\n    var dbcsCode = this.seqObj[DEF_CHAR]\n    if (dbcsCode !== undefined) { // Write beginning of the sequence.\n      if (dbcsCode < 0x100) {\n        newBuf[j++] = dbcsCode\n      } else {\n        newBuf[j++] = dbcsCode >> 8   // high byte\n        newBuf[j++] = dbcsCode & 0xFF // low byte\n      }\n    } else {\n      // See todo above.\n    }\n    this.seqObj = undefined\n  }\n\n  if (this.leadSurrogate !== -1) {\n    // Incomplete surrogate pair - only lead surrogate found.\n    newBuf[j++] = this.defaultCharSingleByte\n    this.leadSurrogate = -1\n  }\n\n  return newBuf.slice(0, j)\n}\n\n// Export for testing\nDBCSEncoder.prototype.findIdx = findIdx\n\n// == Decoder ==================================================================\n\nfunction DBCSDecoder (options, codec) {\n  // Decoder state\n  this.nodeIdx = 0\n  this.prevBytes = []\n\n  // Static data\n  this.decodeTables = codec.decodeTables\n  this.decodeTableSeq = codec.decodeTableSeq\n  this.defaultCharUnicode = codec.defaultCharUnicode\n  this.gb18030 = codec.gb18030\n}\n\nDBCSDecoder.prototype.write = function (buf) {\n  var newBuf = Buffer.alloc(buf.length * 2)\n  var nodeIdx = this.nodeIdx\n  var prevBytes = this.prevBytes; var prevOffset = this.prevBytes.length\n  var seqStart = -this.prevBytes.length // idx of the start of current parsed sequence.\n  var uCode\n\n  for (var i = 0, j = 0; i < buf.length; i++) {\n    var curByte = (i >= 0) ? buf[i] : prevBytes[i + prevOffset]\n\n    // Lookup in current trie node.\n    var uCode = this.decodeTables[nodeIdx][curByte]\n\n    if (uCode >= 0) {\n      // Normal character, just use it.\n    } else if (uCode === UNASSIGNED) { // Unknown char.\n      // TODO: Callback with seq.\n      uCode = this.defaultCharUnicode.charCodeAt(0)\n      i = seqStart // Skip one byte ('i' will be incremented by the for loop) and try to parse again.\n    } else if (uCode === GB18030_CODE) {\n      if (i >= 3) {\n        var ptr = (buf[i - 3] - 0x81) * 12600 + (buf[i - 2] - 0x30) * 1260 + (buf[i - 1] - 0x81) * 10 + (curByte - 0x30)\n      } else {\n        var ptr = (prevBytes[i - 3 + prevOffset] - 0x81) * 12600 +\n                          (((i - 2 >= 0) ? buf[i - 2] : prevBytes[i - 2 + prevOffset]) - 0x30) * 1260 +\n                          (((i - 1 >= 0) ? buf[i - 1] : prevBytes[i - 1 + prevOffset]) - 0x81) * 10 +\n                          (curByte - 0x30)\n      }\n      var idx = findIdx(this.gb18030.gbChars, ptr)\n      uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx]\n    } else if (uCode <= NODE_START) { // Go to next trie node.\n      nodeIdx = NODE_START - uCode\n      continue\n    } else if (uCode <= SEQ_START) { // Output a sequence of chars.\n      var seq = this.decodeTableSeq[SEQ_START - uCode]\n      for (var k = 0; k < seq.length - 1; k++) {\n        uCode = seq[k]\n        newBuf[j++] = uCode & 0xFF\n        newBuf[j++] = uCode >> 8\n      }\n      uCode = seq[seq.length - 1]\n    } else { throw new Error(\"iconv-lite internal error: invalid decoding table value \" + uCode + \" at \" + nodeIdx + \"/\" + curByte) }\n\n    // Write the character to buffer, handling higher planes using surrogate pair.\n    if (uCode >= 0x10000) {\n      uCode -= 0x10000\n      var uCodeLead = 0xD800 | (uCode >> 10)\n      newBuf[j++] = uCodeLead & 0xFF\n      newBuf[j++] = uCodeLead >> 8\n\n      uCode = 0xDC00 | (uCode & 0x3FF)\n    }\n    newBuf[j++] = uCode & 0xFF\n    newBuf[j++] = uCode >> 8\n\n    // Reset trie node.\n    nodeIdx = 0; seqStart = i + 1\n  }\n\n  this.nodeIdx = nodeIdx\n  this.prevBytes = (seqStart >= 0)\n    ? Array.prototype.slice.call(buf, seqStart)\n    : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf))\n\n  return newBuf.slice(0, j).toString(\"ucs2\")\n}\n\nDBCSDecoder.prototype.end = function () {\n  var ret = \"\"\n\n  // Try to parse all remaining chars.\n  while (this.prevBytes.length > 0) {\n    // Skip 1 character in the buffer.\n    ret += this.defaultCharUnicode\n    var bytesArr = this.prevBytes.slice(1)\n\n    // Parse remaining as usual.\n    this.prevBytes = []\n    this.nodeIdx = 0\n    if (bytesArr.length > 0) { ret += this.write(bytesArr) }\n  }\n\n  this.prevBytes = []\n  this.nodeIdx = 0\n  return ret\n}\n\n// Binary search for GB18030. Returns largest i such that table[i] <= val.\nfunction findIdx (table, val) {\n  if (table[0] > val) { return -1 }\n\n  var l = 0; var r = table.length\n  while (l < r - 1) { // always table[l] <= val < table[r]\n    var mid = l + ((r - l + 1) >> 1)\n    if (table[mid] <= val) { l = mid } else { r = mid }\n  }\n  return l\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL21haWxwYXJzZXIvbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvZW5jb2RpbmdzL2RiY3MtY29kZWMuanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWixhQUFhLCtGQUE4Qjs7QUFFM0M7QUFDQTtBQUNBOztBQUVBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixXQUFXLE9BQU87O0FBRWxDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qiw2QkFBNkI7O0FBRTdCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IseUJBQXlCLE9BQU87O0FBRWxEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQSx5QkFBeUIsV0FBVztBQUNwQztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsV0FBVztBQUN0QztBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsV0FBVztBQUN4QyxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0NBQXdDO0FBQzVEO0FBQ0EscUNBQXFDLDhCQUE4QjtBQUNuRSwrQkFBK0IsYUFBYSxPQUFPO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUyxVQUFVLGVBQWU7QUFDbEMsMkJBQTJCOztBQUUzQjtBQUNBLGlDQUFpQyxPQUFPLE9BQU87QUFDL0M7O0FBRUEsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxNQUFNLDhCQUE4QjtBQUNwQztBQUNBLE1BQU0sT0FBTztBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBLG9DQUFvQztBQUNwQyxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0EsMkRBQTJELG1GQUFtRixPQUFPO0FBQ3JKLFVBQVUsNENBQTRDO0FBQ3REO0FBQ0E7QUFDQSwwQkFBMEIsU0FBUyxPQUFPLGlDQUFpQzs7QUFFM0U7QUFDQTtBQUNBLFVBQVUsT0FBTywrQkFBK0I7QUFDaEQ7QUFDQSxNQUFNLHFDQUFxQztBQUMzQztBQUNBLHNCQUFzQixVQUFVLE9BQU87QUFDdkMsTUFBTSxPQUFPO0FBQ2I7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxvRUFBb0U7QUFDdEcsd0NBQXdDO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBLHNDQUFzQyxnQkFBZ0I7QUFDdEQ7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHdDQUF3QztBQUN4QztBQUNBLDZFQUE2RSxtQkFBbUIsT0FBTztBQUN2RztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDO0FBQzdDLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLE9BQU87QUFDZjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSxRQUFRLHdDQUF3QztBQUNoRDtBQUNBLFFBQVEsaUNBQWlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHdCQUF3QjtBQUM5QjtBQUNBLG9DQUFvQzs7QUFFcEMsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdELDREQUE0RDtBQUM1RCwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnRUFBZ0UsU0FBUzs7QUFFekUsaUNBQWlDOztBQUVqQyxxQkFBcUI7QUFDckI7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBOztBQUVBLHlCQUF5QixnQkFBZ0I7QUFDekM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxpQ0FBaUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGdDQUFnQztBQUN0QztBQUNBO0FBQ0EsTUFBTSwrQkFBK0I7QUFDckM7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLE9BQU87O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4QixhQUFhO0FBQ2Isc0JBQXNCO0FBQ3RCO0FBQ0EsNkJBQTZCLFVBQVUsT0FBTztBQUM5QztBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xca2ZyeXRcXC5nZW1pbmlcXGFudGlncmF2aXR5XFxzY3JhdGNoXFxkcl9rYWxzX3ZpcnR1YWxfaG9zcGl0YWxcXG5vZGVfbW9kdWxlc1xcbWFpbHBhcnNlclxcbm9kZV9tb2R1bGVzXFxpY29udi1saXRlXFxlbmNvZGluZ3NcXGRiY3MtY29kZWMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCJcbnZhciBCdWZmZXIgPSByZXF1aXJlKFwic2FmZXItYnVmZmVyXCIpLkJ1ZmZlclxuXG4vLyBNdWx0aWJ5dGUgY29kZWMuIEluIHRoaXMgc2NoZW1lLCBhIGNoYXJhY3RlciBpcyByZXByZXNlbnRlZCBieSAxIG9yIG1vcmUgYnl0ZXMuXG4vLyBPdXIgY29kZWMgc3VwcG9ydHMgVVRGLTE2IHN1cnJvZ2F0ZXMsIGV4dGVuc2lvbnMgZm9yIEdCMTgwMzAgYW5kIHVuaWNvZGUgc2VxdWVuY2VzLlxuLy8gVG8gc2F2ZSBtZW1vcnkgYW5kIGxvYWRpbmcgdGltZSwgd2UgcmVhZCB0YWJsZSBmaWxlcyBvbmx5IHdoZW4gcmVxdWVzdGVkLlxuXG5leHBvcnRzLl9kYmNzID0gREJDU0NvZGVjXG5cbnZhciBVTkFTU0lHTkVEID0gLTFcbnZhciBHQjE4MDMwX0NPREUgPSAtMlxudmFyIFNFUV9TVEFSVCA9IC0xMFxudmFyIE5PREVfU1RBUlQgPSAtMTAwMFxudmFyIFVOQVNTSUdORURfTk9ERSA9IG5ldyBBcnJheSgweDEwMClcbnZhciBERUZfQ0hBUiA9IC0xXG5cbmZvciAodmFyIGkgPSAwOyBpIDwgMHgxMDA7IGkrKykgeyBVTkFTU0lHTkVEX05PREVbaV0gPSBVTkFTU0lHTkVEIH1cblxuLy8gQ2xhc3MgREJDU0NvZGVjIHJlYWRzIGFuZCBpbml0aWFsaXplcyBtYXBwaW5nIHRhYmxlcy5cbmZ1bmN0aW9uIERCQ1NDb2RlYyAoY29kZWNPcHRpb25zLCBpY29udikge1xuICB0aGlzLmVuY29kaW5nTmFtZSA9IGNvZGVjT3B0aW9ucy5lbmNvZGluZ05hbWVcbiAgaWYgKCFjb2RlY09wdGlvbnMpIHsgdGhyb3cgbmV3IEVycm9yKFwiREJDUyBjb2RlYyBpcyBjYWxsZWQgd2l0aG91dCB0aGUgZGF0YS5cIikgfVxuICBpZiAoIWNvZGVjT3B0aW9ucy50YWJsZSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJFbmNvZGluZyAnXCIgKyB0aGlzLmVuY29kaW5nTmFtZSArIFwiJyBoYXMgbm8gZGF0YS5cIikgfVxuXG4gIC8vIExvYWQgdGFibGVzLlxuICB2YXIgbWFwcGluZ1RhYmxlID0gY29kZWNPcHRpb25zLnRhYmxlKClcblxuICAvLyBEZWNvZGUgdGFibGVzOiBNQkNTIC0+IFVuaWNvZGUuXG5cbiAgLy8gZGVjb2RlVGFibGVzIGlzIGEgdHJpZSwgZW5jb2RlZCBhcyBhbiBhcnJheSBvZiBhcnJheXMgb2YgaW50ZWdlcnMuIEludGVybmFsIGFycmF5cyBhcmUgdHJpZSBub2RlcyBhbmQgYWxsIGhhdmUgbGVuID0gMjU2LlxuICAvLyBUcmllIHJvb3QgaXMgZGVjb2RlVGFibGVzWzBdLlxuICAvLyBWYWx1ZXM6ID49ICAwIC0+IHVuaWNvZGUgY2hhcmFjdGVyIGNvZGUuIGNhbiBiZSA+IDB4RkZGRlxuICAvLyAgICAgICAgID09IFVOQVNTSUdORUQgLT4gdW5rbm93bi91bmFzc2lnbmVkIHNlcXVlbmNlLlxuICAvLyAgICAgICAgID09IEdCMTgwMzBfQ09ERSAtPiB0aGlzIGlzIHRoZSBlbmQgb2YgYSBHQjE4MDMwIDQtYnl0ZSBzZXF1ZW5jZS5cbiAgLy8gICAgICAgICA8PSBOT0RFX1NUQVJUIC0+IGluZGV4IG9mIHRoZSBuZXh0IG5vZGUgaW4gb3VyIHRyaWUgdG8gcHJvY2VzcyBuZXh0IGJ5dGUuXG4gIC8vICAgICAgICAgPD0gU0VRX1NUQVJUICAtPiBpbmRleCBvZiB0aGUgc3RhcnQgb2YgYSBjaGFyYWN0ZXIgY29kZSBzZXF1ZW5jZSwgaW4gZGVjb2RlVGFibGVTZXEuXG4gIHRoaXMuZGVjb2RlVGFibGVzID0gW11cbiAgdGhpcy5kZWNvZGVUYWJsZXNbMF0gPSBVTkFTU0lHTkVEX05PREUuc2xpY2UoMCkgLy8gQ3JlYXRlIHJvb3Qgbm9kZS5cblxuICAvLyBTb21ldGltZXMgYSBNQkNTIGNoYXIgY29ycmVzcG9uZHMgdG8gYSBzZXF1ZW5jZSBvZiB1bmljb2RlIGNoYXJzLiBXZSBzdG9yZSB0aGVtIGFzIGFycmF5cyBvZiBpbnRlZ2VycyBoZXJlLlxuICB0aGlzLmRlY29kZVRhYmxlU2VxID0gW11cblxuICAvLyBBY3R1YWwgbWFwcGluZyB0YWJsZXMgY29uc2lzdCBvZiBjaHVua3MuIFVzZSB0aGVtIHRvIGZpbGwgdXAgZGVjb2RlIHRhYmxlcy5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXBwaW5nVGFibGUubGVuZ3RoOyBpKyspIHsgdGhpcy5fYWRkRGVjb2RlQ2h1bmsobWFwcGluZ1RhYmxlW2ldKSB9XG5cbiAgLy8gTG9hZCAmIGNyZWF0ZSBHQjE4MDMwIHRhYmxlcyB3aGVuIG5lZWRlZC5cbiAgaWYgKHR5cGVvZiBjb2RlY09wdGlvbnMuZ2IxODAzMCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhpcy5nYjE4MDMwID0gY29kZWNPcHRpb25zLmdiMTgwMzAoKSAvLyBMb2FkIEdCMTgwMzAgcmFuZ2VzLlxuXG4gICAgLy8gQWRkIEdCMTgwMzAgY29tbW9uIGRlY29kZSBub2Rlcy5cbiAgICB2YXIgY29tbW9uVGhpcmRCeXRlTm9kZUlkeCA9IHRoaXMuZGVjb2RlVGFibGVzLmxlbmd0aFxuICAgIHRoaXMuZGVjb2RlVGFibGVzLnB1c2goVU5BU1NJR05FRF9OT0RFLnNsaWNlKDApKVxuXG4gICAgdmFyIGNvbW1vbkZvdXJ0aEJ5dGVOb2RlSWR4ID0gdGhpcy5kZWNvZGVUYWJsZXMubGVuZ3RoXG4gICAgdGhpcy5kZWNvZGVUYWJsZXMucHVzaChVTkFTU0lHTkVEX05PREUuc2xpY2UoMCkpXG5cbiAgICAvLyBGaWxsIG91dCB0aGUgdHJlZVxuICAgIHZhciBmaXJzdEJ5dGVOb2RlID0gdGhpcy5kZWNvZGVUYWJsZXNbMF1cbiAgICBmb3IgKHZhciBpID0gMHg4MTsgaSA8PSAweEZFOyBpKyspIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlTm9kZSA9IHRoaXMuZGVjb2RlVGFibGVzW05PREVfU1RBUlQgLSBmaXJzdEJ5dGVOb2RlW2ldXVxuICAgICAgZm9yICh2YXIgaiA9IDB4MzA7IGogPD0gMHgzOTsgaisrKSB7XG4gICAgICAgIGlmIChzZWNvbmRCeXRlTm9kZVtqXSA9PT0gVU5BU1NJR05FRCkge1xuICAgICAgICAgIHNlY29uZEJ5dGVOb2RlW2pdID0gTk9ERV9TVEFSVCAtIGNvbW1vblRoaXJkQnl0ZU5vZGVJZHhcbiAgICAgICAgfSBlbHNlIGlmIChzZWNvbmRCeXRlTm9kZVtqXSA+IE5PREVfU1RBUlQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnYjE4MDMwIGRlY29kZSB0YWJsZXMgY29uZmxpY3QgYXQgYnl0ZSAyXCIpXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGhpcmRCeXRlTm9kZSA9IHRoaXMuZGVjb2RlVGFibGVzW05PREVfU1RBUlQgLSBzZWNvbmRCeXRlTm9kZVtqXV1cbiAgICAgICAgZm9yICh2YXIgayA9IDB4ODE7IGsgPD0gMHhGRTsgaysrKSB7XG4gICAgICAgICAgaWYgKHRoaXJkQnl0ZU5vZGVba10gPT09IFVOQVNTSUdORUQpIHtcbiAgICAgICAgICAgIHRoaXJkQnl0ZU5vZGVba10gPSBOT0RFX1NUQVJUIC0gY29tbW9uRm91cnRoQnl0ZU5vZGVJZHhcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXJkQnl0ZU5vZGVba10gPT09IE5PREVfU1RBUlQgLSBjb21tb25Gb3VydGhCeXRlTm9kZUlkeCkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXJkQnl0ZU5vZGVba10gPiBOT0RFX1NUQVJUKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnYjE4MDMwIGRlY29kZSB0YWJsZXMgY29uZmxpY3QgYXQgYnl0ZSAzXCIpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGZvdXJ0aEJ5dGVOb2RlID0gdGhpcy5kZWNvZGVUYWJsZXNbTk9ERV9TVEFSVCAtIHRoaXJkQnl0ZU5vZGVba11dXG4gICAgICAgICAgZm9yICh2YXIgbCA9IDB4MzA7IGwgPD0gMHgzOTsgbCsrKSB7XG4gICAgICAgICAgICBpZiAoZm91cnRoQnl0ZU5vZGVbbF0gPT09IFVOQVNTSUdORUQpIHsgZm91cnRoQnl0ZU5vZGVbbF0gPSBHQjE4MDMwX0NPREUgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuZGVmYXVsdENoYXJVbmljb2RlID0gaWNvbnYuZGVmYXVsdENoYXJVbmljb2RlXG5cbiAgLy8gRW5jb2RlIHRhYmxlczogVW5pY29kZSAtPiBEQkNTLlxuXG4gIC8vIGBlbmNvZGVUYWJsZWAgaXMgYXJyYXkgbWFwcGluZyBmcm9tIHVuaWNvZGUgY2hhciB0byBlbmNvZGVkIGNoYXIuIEFsbCBpdHMgdmFsdWVzIGFyZSBpbnRlZ2VycyBmb3IgcGVyZm9ybWFuY2UuXG4gIC8vIEJlY2F1c2UgaXQgY2FuIGJlIHNwYXJzZSwgaXQgaXMgcmVwcmVzZW50ZWQgYXMgYXJyYXkgb2YgYnVja2V0cyBieSAyNTYgY2hhcnMgZWFjaC4gQnVja2V0IGNhbiBiZSBudWxsLlxuICAvLyBWYWx1ZXM6ID49ICAwIC0+IGl0IGlzIGEgbm9ybWFsIGNoYXIuIFdyaXRlIHRoZSB2YWx1ZSAoaWYgPD0yNTYgdGhlbiAxIGJ5dGUsIGlmIDw9NjU1MzYgdGhlbiAyIGJ5dGVzLCBldGMuKS5cbiAgLy8gICAgICAgICA9PSBVTkFTU0lHTkVEIC0+IG5vIGNvbnZlcnNpb24gZm91bmQuIE91dHB1dCBhIGRlZmF1bHQgY2hhci5cbiAgLy8gICAgICAgICA8PSBTRVFfU1RBUlQgIC0+IGl0J3MgYW4gaW5kZXggaW4gZW5jb2RlVGFibGVTZXEsIHNlZSBiZWxvdy4gVGhlIGNoYXJhY3RlciBzdGFydHMgYSBzZXF1ZW5jZS5cbiAgdGhpcy5lbmNvZGVUYWJsZSA9IFtdXG5cbiAgLy8gYGVuY29kZVRhYmxlU2VxYCBpcyB1c2VkIHdoZW4gYSBzZXF1ZW5jZSBvZiB1bmljb2RlIGNoYXJhY3RlcnMgaXMgZW5jb2RlZCBhcyBhIHNpbmdsZSBjb2RlLiBXZSB1c2UgYSB0cmVlIG9mXG4gIC8vIG9iamVjdHMgd2hlcmUga2V5cyBjb3JyZXNwb25kIHRvIGNoYXJhY3RlcnMgaW4gc2VxdWVuY2UgYW5kIGxlYWZzIGFyZSB0aGUgZW5jb2RlZCBkYmNzIHZhbHVlcy4gQSBzcGVjaWFsIERFRl9DSEFSIGtleVxuICAvLyBtZWFucyBlbmQgb2Ygc2VxdWVuY2UgKG5lZWRlZCB3aGVuIG9uZSBzZXF1ZW5jZSBpcyBhIHN0cmljdCBzdWJzZXF1ZW5jZSBvZiBhbm90aGVyKS5cbiAgLy8gT2JqZWN0cyBhcmUga2VwdCBzZXBhcmF0ZWx5IGZyb20gZW5jb2RlVGFibGUgdG8gaW5jcmVhc2UgcGVyZm9ybWFuY2UuXG4gIHRoaXMuZW5jb2RlVGFibGVTZXEgPSBbXVxuXG4gIC8vIFNvbWUgY2hhcnMgY2FuIGJlIGRlY29kZWQsIGJ1dCBuZWVkIG5vdCBiZSBlbmNvZGVkLlxuICB2YXIgc2tpcEVuY29kZUNoYXJzID0ge31cbiAgaWYgKGNvZGVjT3B0aW9ucy5lbmNvZGVTa2lwVmFscykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29kZWNPcHRpb25zLmVuY29kZVNraXBWYWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsID0gY29kZWNPcHRpb25zLmVuY29kZVNraXBWYWxzW2ldXG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIikgeyBza2lwRW5jb2RlQ2hhcnNbdmFsXSA9IHRydWUgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IHZhbC5mcm9tOyBqIDw9IHZhbC50bzsgaisrKSB7IHNraXBFbmNvZGVDaGFyc1tqXSA9IHRydWUgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFVzZSBkZWNvZGUgdHJpZSB0byByZWN1cnNpdmVseSBmaWxsIG91dCBlbmNvZGUgdGFibGVzLlxuICB0aGlzLl9maWxsRW5jb2RlVGFibGUoMCwgMCwgc2tpcEVuY29kZUNoYXJzKVxuXG4gIC8vIEFkZCBtb3JlIGVuY29kaW5nIHBhaXJzIHdoZW4gbmVlZGVkLlxuICBpZiAoY29kZWNPcHRpb25zLmVuY29kZUFkZCkge1xuICAgIGZvciAodmFyIHVDaGFyIGluIGNvZGVjT3B0aW9ucy5lbmNvZGVBZGQpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29kZWNPcHRpb25zLmVuY29kZUFkZCwgdUNoYXIpKSB7IHRoaXMuX3NldEVuY29kZUNoYXIodUNoYXIuY2hhckNvZGVBdCgwKSwgY29kZWNPcHRpb25zLmVuY29kZUFkZFt1Q2hhcl0pIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLmRlZkNoYXJTQiA9IHRoaXMuZW5jb2RlVGFibGVbMF1baWNvbnYuZGVmYXVsdENoYXJTaW5nbGVCeXRlLmNoYXJDb2RlQXQoMCldXG4gIGlmICh0aGlzLmRlZkNoYXJTQiA9PT0gVU5BU1NJR05FRCkgdGhpcy5kZWZDaGFyU0IgPSB0aGlzLmVuY29kZVRhYmxlWzBdW1wiP1wiXVxuICBpZiAodGhpcy5kZWZDaGFyU0IgPT09IFVOQVNTSUdORUQpIHRoaXMuZGVmQ2hhclNCID0gXCI/XCIuY2hhckNvZGVBdCgwKVxufVxuXG5EQkNTQ29kZWMucHJvdG90eXBlLmVuY29kZXIgPSBEQkNTRW5jb2RlclxuREJDU0NvZGVjLnByb3RvdHlwZS5kZWNvZGVyID0gREJDU0RlY29kZXJcblxuLy8gRGVjb2RlciBoZWxwZXJzXG5EQkNTQ29kZWMucHJvdG90eXBlLl9nZXREZWNvZGVUcmllTm9kZSA9IGZ1bmN0aW9uIChhZGRyKSB7XG4gIHZhciBieXRlcyA9IFtdXG4gIGZvciAoOyBhZGRyID4gMDsgYWRkciA+Pj49IDgpIHsgYnl0ZXMucHVzaChhZGRyICYgMHhGRikgfVxuICBpZiAoYnl0ZXMubGVuZ3RoID09IDApIHsgYnl0ZXMucHVzaCgwKSB9XG5cbiAgdmFyIG5vZGUgPSB0aGlzLmRlY29kZVRhYmxlc1swXVxuICBmb3IgKHZhciBpID0gYnl0ZXMubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkgeyAvLyBUcmF2ZXJzZSBub2RlcyBkZWVwZXIgaW50byB0aGUgdHJpZS5cbiAgICB2YXIgdmFsID0gbm9kZVtieXRlc1tpXV1cblxuICAgIGlmICh2YWwgPT0gVU5BU1NJR05FRCkgeyAvLyBDcmVhdGUgbmV3IG5vZGUuXG4gICAgICBub2RlW2J5dGVzW2ldXSA9IE5PREVfU1RBUlQgLSB0aGlzLmRlY29kZVRhYmxlcy5sZW5ndGhcbiAgICAgIHRoaXMuZGVjb2RlVGFibGVzLnB1c2gobm9kZSA9IFVOQVNTSUdORURfTk9ERS5zbGljZSgwKSlcbiAgICB9IGVsc2UgaWYgKHZhbCA8PSBOT0RFX1NUQVJUKSB7IC8vIEV4aXN0aW5nIG5vZGUuXG4gICAgICBub2RlID0gdGhpcy5kZWNvZGVUYWJsZXNbTk9ERV9TVEFSVCAtIHZhbF1cbiAgICB9IGVsc2UgeyB0aHJvdyBuZXcgRXJyb3IoXCJPdmVyd3JpdGUgYnl0ZSBpbiBcIiArIHRoaXMuZW5jb2RpbmdOYW1lICsgXCIsIGFkZHI6IFwiICsgYWRkci50b1N0cmluZygxNikpIH1cbiAgfVxuICByZXR1cm4gbm9kZVxufVxuXG5EQkNTQ29kZWMucHJvdG90eXBlLl9hZGREZWNvZGVDaHVuayA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAvLyBGaXJzdCBlbGVtZW50IG9mIGNodW5rIGlzIHRoZSBoZXggbWJjcyBjb2RlIHdoZXJlIHdlIHN0YXJ0LlxuICB2YXIgY3VyQWRkciA9IHBhcnNlSW50KGNodW5rWzBdLCAxNilcblxuICAvLyBDaG9vc2UgdGhlIGRlY29kaW5nIG5vZGUgd2hlcmUgd2UnbGwgd3JpdGUgb3VyIGNoYXJzLlxuICB2YXIgd3JpdGVUYWJsZSA9IHRoaXMuX2dldERlY29kZVRyaWVOb2RlKGN1ckFkZHIpXG4gIGN1ckFkZHIgPSBjdXJBZGRyICYgMHhGRlxuXG4gIC8vIFdyaXRlIGFsbCBvdGhlciBlbGVtZW50cyBvZiB0aGUgY2h1bmsgdG8gdGhlIHRhYmxlLlxuICBmb3IgKHZhciBrID0gMTsgayA8IGNodW5rLmxlbmd0aDsgaysrKSB7XG4gICAgdmFyIHBhcnQgPSBjaHVua1trXVxuICAgIGlmICh0eXBlb2YgcGFydCA9PT0gXCJzdHJpbmdcIikgeyAvLyBTdHJpbmcsIHdyaXRlIGFzLWlzLlxuICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBwYXJ0Lmxlbmd0aDspIHtcbiAgICAgICAgdmFyIGNvZGUgPSBwYXJ0LmNoYXJDb2RlQXQobCsrKVxuICAgICAgICBpZiAoY29kZSA+PSAweEQ4MDAgJiYgY29kZSA8IDB4REMwMCkgeyAvLyBEZWNvZGUgc3Vycm9nYXRlXG4gICAgICAgICAgdmFyIGNvZGVUcmFpbCA9IHBhcnQuY2hhckNvZGVBdChsKyspXG4gICAgICAgICAgaWYgKGNvZGVUcmFpbCA+PSAweERDMDAgJiYgY29kZVRyYWlsIDwgMHhFMDAwKSB7IHdyaXRlVGFibGVbY3VyQWRkcisrXSA9IDB4MTAwMDAgKyAoY29kZSAtIDB4RDgwMCkgKiAweDQwMCArIChjb2RlVHJhaWwgLSAweERDMDApIH0gZWxzZSB7IHRocm93IG5ldyBFcnJvcihcIkluY29ycmVjdCBzdXJyb2dhdGUgcGFpciBpbiBcIiArIHRoaXMuZW5jb2RpbmdOYW1lICsgXCIgYXQgY2h1bmsgXCIgKyBjaHVua1swXSkgfVxuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPiAweDBGRjAgJiYgY29kZSA8PSAweDBGRkYpIHsgLy8gQ2hhcmFjdGVyIHNlcXVlbmNlIChvdXIgb3duIGVuY29kaW5nIHVzZWQpXG4gICAgICAgICAgdmFyIGxlbiA9IDB4RkZGIC0gY29kZSArIDJcbiAgICAgICAgICB2YXIgc2VxID0gW11cbiAgICAgICAgICBmb3IgKHZhciBtID0gMDsgbSA8IGxlbjsgbSsrKSB7IHNlcS5wdXNoKHBhcnQuY2hhckNvZGVBdChsKyspKSB9IC8vIFNpbXBsZSB2YXJpYXRpb246IGRvbid0IHN1cHBvcnQgc3Vycm9nYXRlcyBvciBzdWJzZXF1ZW5jZXMgaW4gc2VxLlxuXG4gICAgICAgICAgd3JpdGVUYWJsZVtjdXJBZGRyKytdID0gU0VRX1NUQVJUIC0gdGhpcy5kZWNvZGVUYWJsZVNlcS5sZW5ndGhcbiAgICAgICAgICB0aGlzLmRlY29kZVRhYmxlU2VxLnB1c2goc2VxKVxuICAgICAgICB9IGVsc2UgeyB3cml0ZVRhYmxlW2N1ckFkZHIrK10gPSBjb2RlIH0gLy8gQmFzaWMgY2hhclxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcnQgPT09IFwibnVtYmVyXCIpIHsgLy8gSW50ZWdlciwgbWVhbmluZyBpbmNyZWFzaW5nIHNlcXVlbmNlIHN0YXJ0aW5nIHdpdGggcHJldiBjaGFyYWN0ZXIuXG4gICAgICB2YXIgY2hhckNvZGUgPSB3cml0ZVRhYmxlW2N1ckFkZHIgLSAxXSArIDFcbiAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgcGFydDsgbCsrKSB7IHdyaXRlVGFibGVbY3VyQWRkcisrXSA9IGNoYXJDb2RlKysgfVxuICAgIH0gZWxzZSB7IHRocm93IG5ldyBFcnJvcihcIkluY29ycmVjdCB0eXBlICdcIiArIHR5cGVvZiBwYXJ0ICsgXCInIGdpdmVuIGluIFwiICsgdGhpcy5lbmNvZGluZ05hbWUgKyBcIiBhdCBjaHVuayBcIiArIGNodW5rWzBdKSB9XG4gIH1cbiAgaWYgKGN1ckFkZHIgPiAweEZGKSB7IHRocm93IG5ldyBFcnJvcihcIkluY29ycmVjdCBjaHVuayBpbiBcIiArIHRoaXMuZW5jb2RpbmdOYW1lICsgXCIgYXQgYWRkciBcIiArIGNodW5rWzBdICsgXCI6IHRvbyBsb25nXCIgKyBjdXJBZGRyKSB9XG59XG5cbi8vIEVuY29kZXIgaGVscGVyc1xuREJDU0NvZGVjLnByb3RvdHlwZS5fZ2V0RW5jb2RlQnVja2V0ID0gZnVuY3Rpb24gKHVDb2RlKSB7XG4gIHZhciBoaWdoID0gdUNvZGUgPj4gOCAvLyBUaGlzIGNvdWxkIGJlID4gMHhGRiBiZWNhdXNlIG9mIGFzdHJhbCBjaGFyYWN0ZXJzLlxuICBpZiAodGhpcy5lbmNvZGVUYWJsZVtoaWdoXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5lbmNvZGVUYWJsZVtoaWdoXSA9IFVOQVNTSUdORURfTk9ERS5zbGljZSgwKVxuICB9IC8vIENyZWF0ZSBidWNrZXQgb24gZGVtYW5kLlxuICByZXR1cm4gdGhpcy5lbmNvZGVUYWJsZVtoaWdoXVxufVxuXG5EQkNTQ29kZWMucHJvdG90eXBlLl9zZXRFbmNvZGVDaGFyID0gZnVuY3Rpb24gKHVDb2RlLCBkYmNzQ29kZSkge1xuICB2YXIgYnVja2V0ID0gdGhpcy5fZ2V0RW5jb2RlQnVja2V0KHVDb2RlKVxuICB2YXIgbG93ID0gdUNvZGUgJiAweEZGXG4gIGlmIChidWNrZXRbbG93XSA8PSBTRVFfU1RBUlQpIHsgdGhpcy5lbmNvZGVUYWJsZVNlcVtTRVFfU1RBUlQgLSBidWNrZXRbbG93XV1bREVGX0NIQVJdID0gZGJjc0NvZGUgfSAvLyBUaGVyZSdzIGFscmVhZHkgYSBzZXF1ZW5jZSwgc2V0IGEgc2luZ2xlLWNoYXIgc3Vic2VxdWVuY2Ugb2YgaXQuXG4gIGVsc2UgaWYgKGJ1Y2tldFtsb3ddID09IFVOQVNTSUdORUQpIHsgYnVja2V0W2xvd10gPSBkYmNzQ29kZSB9XG59XG5cbkRCQ1NDb2RlYy5wcm90b3R5cGUuX3NldEVuY29kZVNlcXVlbmNlID0gZnVuY3Rpb24gKHNlcSwgZGJjc0NvZGUpIHtcbiAgLy8gR2V0IHRoZSByb290IG9mIGNoYXJhY3RlciB0cmVlIGFjY29yZGluZyB0byBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlIHNlcXVlbmNlLlxuICB2YXIgdUNvZGUgPSBzZXFbMF1cbiAgdmFyIGJ1Y2tldCA9IHRoaXMuX2dldEVuY29kZUJ1Y2tldCh1Q29kZSlcbiAgdmFyIGxvdyA9IHVDb2RlICYgMHhGRlxuXG4gIHZhciBub2RlXG4gIGlmIChidWNrZXRbbG93XSA8PSBTRVFfU1RBUlQpIHtcbiAgICAvLyBUaGVyZSdzIGFscmVhZHkgYSBzZXF1ZW5jZSB3aXRoICAtIHVzZSBpdC5cbiAgICBub2RlID0gdGhpcy5lbmNvZGVUYWJsZVNlcVtTRVFfU1RBUlQgLSBidWNrZXRbbG93XV1cbiAgfSBlbHNlIHtcbiAgICAvLyBUaGVyZSB3YXMgbm8gc2VxdWVuY2Ugb2JqZWN0IC0gYWxsb2NhdGUgYSBuZXcgb25lLlxuICAgIG5vZGUgPSB7fVxuICAgIGlmIChidWNrZXRbbG93XSAhPT0gVU5BU1NJR05FRCkgbm9kZVtERUZfQ0hBUl0gPSBidWNrZXRbbG93XSAvLyBJZiBhIGNoYXIgd2FzIHNldCBiZWZvcmUgLSBtYWtlIGl0IGEgc2luZ2xlLWNoYXIgc3Vic2VxdWVuY2UuXG4gICAgYnVja2V0W2xvd10gPSBTRVFfU1RBUlQgLSB0aGlzLmVuY29kZVRhYmxlU2VxLmxlbmd0aFxuICAgIHRoaXMuZW5jb2RlVGFibGVTZXEucHVzaChub2RlKVxuICB9XG5cbiAgLy8gVHJhdmVyc2UgdGhlIGNoYXJhY3RlciB0cmVlLCBhbGxvY2F0aW5nIG5ldyBub2RlcyBhcyBuZWVkZWQuXG4gIGZvciAodmFyIGogPSAxOyBqIDwgc2VxLmxlbmd0aCAtIDE7IGorKykge1xuICAgIHZhciBvbGRWYWwgPSBub2RlW3VDb2RlXVxuICAgIGlmICh0eXBlb2Ygb2xkVmFsID09PSBcIm9iamVjdFwiKSB7IG5vZGUgPSBvbGRWYWwgfSBlbHNlIHtcbiAgICAgIG5vZGUgPSBub2RlW3VDb2RlXSA9IHt9XG4gICAgICBpZiAob2xkVmFsICE9PSB1bmRlZmluZWQpIHsgbm9kZVtERUZfQ0hBUl0gPSBvbGRWYWwgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFNldCB0aGUgbGVhZiB0byBnaXZlbiBkYmNzQ29kZS5cbiAgdUNvZGUgPSBzZXFbc2VxLmxlbmd0aCAtIDFdXG4gIG5vZGVbdUNvZGVdID0gZGJjc0NvZGVcbn1cblxuREJDU0NvZGVjLnByb3RvdHlwZS5fZmlsbEVuY29kZVRhYmxlID0gZnVuY3Rpb24gKG5vZGVJZHgsIHByZWZpeCwgc2tpcEVuY29kZUNoYXJzKSB7XG4gIHZhciBub2RlID0gdGhpcy5kZWNvZGVUYWJsZXNbbm9kZUlkeF1cbiAgdmFyIGhhc1ZhbHVlcyA9IGZhbHNlXG4gIHZhciBzdWJOb2RlRW1wdHkgPSB7fVxuICBmb3IgKHZhciBpID0gMDsgaSA8IDB4MTAwOyBpKyspIHtcbiAgICB2YXIgdUNvZGUgPSBub2RlW2ldXG4gICAgdmFyIG1iQ29kZSA9IHByZWZpeCArIGlcbiAgICBpZiAoc2tpcEVuY29kZUNoYXJzW21iQ29kZV0pIHsgY29udGludWUgfVxuXG4gICAgaWYgKHVDb2RlID49IDApIHtcbiAgICAgIHRoaXMuX3NldEVuY29kZUNoYXIodUNvZGUsIG1iQ29kZSlcbiAgICAgIGhhc1ZhbHVlcyA9IHRydWVcbiAgICB9IGVsc2UgaWYgKHVDb2RlIDw9IE5PREVfU1RBUlQpIHtcbiAgICAgIHZhciBzdWJOb2RlSWR4ID0gTk9ERV9TVEFSVCAtIHVDb2RlXG4gICAgICBpZiAoIXN1Yk5vZGVFbXB0eVtzdWJOb2RlSWR4XSkgeyAgLy8gU2tpcCBlbXB0eSBzdWJ0cmVlcyAodGhleSBhcmUgdG9vIGxhcmdlIGluIGdiMTgwMzApLlxuICAgICAgICB2YXIgbmV3UHJlZml4ID0gKG1iQ29kZSA8PCA4KSA+Pj4gMCAgLy8gTk9URTogJz4+PiAwJyBrZWVwcyAzMi1iaXQgbnVtIHBvc2l0aXZlLlxuICAgICAgICBpZiAodGhpcy5fZmlsbEVuY29kZVRhYmxlKHN1Yk5vZGVJZHgsIG5ld1ByZWZpeCwgc2tpcEVuY29kZUNoYXJzKSkgeyBoYXNWYWx1ZXMgPSB0cnVlIH0gZWxzZSB7IHN1Yk5vZGVFbXB0eVtzdWJOb2RlSWR4XSA9IHRydWUgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodUNvZGUgPD0gU0VRX1NUQVJUKSB7XG4gICAgICB0aGlzLl9zZXRFbmNvZGVTZXF1ZW5jZSh0aGlzLmRlY29kZVRhYmxlU2VxW1NFUV9TVEFSVCAtIHVDb2RlXSwgbWJDb2RlKVxuICAgICAgaGFzVmFsdWVzID0gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gaGFzVmFsdWVzXG59XG5cbi8vID09IEVuY29kZXIgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmZ1bmN0aW9uIERCQ1NFbmNvZGVyIChvcHRpb25zLCBjb2RlYykge1xuICAvLyBFbmNvZGVyIHN0YXRlXG4gIHRoaXMubGVhZFN1cnJvZ2F0ZSA9IC0xXG4gIHRoaXMuc2VxT2JqID0gdW5kZWZpbmVkXG5cbiAgLy8gU3RhdGljIGRhdGFcbiAgdGhpcy5lbmNvZGVUYWJsZSA9IGNvZGVjLmVuY29kZVRhYmxlXG4gIHRoaXMuZW5jb2RlVGFibGVTZXEgPSBjb2RlYy5lbmNvZGVUYWJsZVNlcVxuICB0aGlzLmRlZmF1bHRDaGFyU2luZ2xlQnl0ZSA9IGNvZGVjLmRlZkNoYXJTQlxuICB0aGlzLmdiMTgwMzAgPSBjb2RlYy5nYjE4MDMwXG59XG5cbkRCQ1NFbmNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdmFyIG5ld0J1ZiA9IEJ1ZmZlci5hbGxvYyhzdHIubGVuZ3RoICogKHRoaXMuZ2IxODAzMCA/IDQgOiAzKSlcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSB0aGlzLmxlYWRTdXJyb2dhdGVcbiAgdmFyIHNlcU9iaiA9IHRoaXMuc2VxT2JqXG4gIHZhciBuZXh0Q2hhciA9IC0xXG4gIHZhciBpID0gMDsgdmFyIGogPSAwXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICAvLyAwLiBHZXQgbmV4dCBjaGFyYWN0ZXIuXG4gICAgaWYgKG5leHRDaGFyID09PSAtMSkge1xuICAgICAgaWYgKGkgPT0gc3RyLmxlbmd0aCkgYnJlYWtcbiAgICAgIHZhciB1Q29kZSA9IHN0ci5jaGFyQ29kZUF0KGkrKylcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHVDb2RlID0gbmV4dENoYXJcbiAgICAgIG5leHRDaGFyID0gLTFcbiAgICB9XG5cbiAgICAvLyAxLiBIYW5kbGUgc3Vycm9nYXRlcy5cbiAgICBpZiAodUNvZGUgPj0gMHhEODAwICYmIHVDb2RlIDwgMHhFMDAwKSB7IC8vIENoYXIgaXMgb25lIG9mIHN1cnJvZ2F0ZXMuXG4gICAgICBpZiAodUNvZGUgPCAweERDMDApIHsgLy8gV2UndmUgZ290IGxlYWQgc3Vycm9nYXRlLlxuICAgICAgICBpZiAobGVhZFN1cnJvZ2F0ZSA9PT0gLTEpIHtcbiAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gdUNvZGVcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxlYWRTdXJyb2dhdGUgPSB1Q29kZVxuICAgICAgICAgIC8vIERvdWJsZSBsZWFkIHN1cnJvZ2F0ZSBmb3VuZC5cbiAgICAgICAgICB1Q29kZSA9IFVOQVNTSUdORURcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHsgLy8gV2UndmUgZ290IHRyYWlsIHN1cnJvZ2F0ZS5cbiAgICAgICAgaWYgKGxlYWRTdXJyb2dhdGUgIT09IC0xKSB7XG4gICAgICAgICAgdUNvZGUgPSAweDEwMDAwICsgKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDApICogMHg0MDAgKyAodUNvZGUgLSAweERDMDApXG4gICAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IC0xXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSW5jb21wbGV0ZSBzdXJyb2dhdGUgcGFpciAtIG9ubHkgdHJhaWwgc3Vycm9nYXRlIGZvdW5kLlxuICAgICAgICAgIHVDb2RlID0gVU5BU1NJR05FRFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlICE9PSAtMSkge1xuICAgICAgLy8gSW5jb21wbGV0ZSBzdXJyb2dhdGUgcGFpciAtIG9ubHkgbGVhZCBzdXJyb2dhdGUgZm91bmQuXG4gICAgICBuZXh0Q2hhciA9IHVDb2RlOyB1Q29kZSA9IFVOQVNTSUdORUQgLy8gV3JpdGUgYW4gZXJyb3IsIHRoZW4gY3VycmVudCBjaGFyLlxuICAgICAgbGVhZFN1cnJvZ2F0ZSA9IC0xXG4gICAgfVxuXG4gICAgLy8gMi4gQ29udmVydCB1Q29kZSBjaGFyYWN0ZXIuXG4gICAgdmFyIGRiY3NDb2RlID0gVU5BU1NJR05FRFxuICAgIGlmIChzZXFPYmogIT09IHVuZGVmaW5lZCAmJiB1Q29kZSAhPSBVTkFTU0lHTkVEKSB7IC8vIFdlIGFyZSBpbiB0aGUgbWlkZGxlIG9mIHRoZSBzZXF1ZW5jZVxuICAgICAgdmFyIHJlc0NvZGUgPSBzZXFPYmpbdUNvZGVdXG4gICAgICBpZiAodHlwZW9mIHJlc0NvZGUgPT09IFwib2JqZWN0XCIpIHsgLy8gU2VxdWVuY2UgY29udGludWVzLlxuICAgICAgICBzZXFPYmogPSByZXNDb2RlXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXNDb2RlID09PSBcIm51bWJlclwiKSB7IC8vIFNlcXVlbmNlIGZpbmlzaGVkLiBXcml0ZSBpdC5cbiAgICAgICAgZGJjc0NvZGUgPSByZXNDb2RlXG4gICAgICB9IGVsc2UgaWYgKHJlc0NvZGUgPT0gdW5kZWZpbmVkKSB7IC8vIEN1cnJlbnQgY2hhcmFjdGVyIGlzIG5vdCBwYXJ0IG9mIHRoZSBzZXF1ZW5jZS5cbiAgICAgICAgLy8gVHJ5IGRlZmF1bHQgY2hhcmFjdGVyIGZvciB0aGlzIHNlcXVlbmNlXG4gICAgICAgIHJlc0NvZGUgPSBzZXFPYmpbREVGX0NIQVJdXG4gICAgICAgIGlmIChyZXNDb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkYmNzQ29kZSA9IHJlc0NvZGUgLy8gRm91bmQuIFdyaXRlIGl0LlxuICAgICAgICAgIG5leHRDaGFyID0gdUNvZGUgLy8gQ3VycmVudCBjaGFyYWN0ZXIgd2lsbCBiZSB3cml0dGVuIHRvbyBpbiB0aGUgbmV4dCBpdGVyYXRpb24uXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVE9ETzogV2hhdCBpZiB3ZSBoYXZlIG5vIGRlZmF1bHQ/IChyZXNDb2RlID09IHVuZGVmaW5lZClcbiAgICAgICAgICAvLyBUaGVuLCB3ZSBzaG91bGQgd3JpdGUgZmlyc3QgY2hhciBvZiB0aGUgc2VxdWVuY2UgYXMtaXMgYW5kIHRyeSB0aGUgcmVzdCByZWN1cnNpdmVseS5cbiAgICAgICAgICAvLyBEaWRuJ3QgZG8gaXQgZm9yIG5vdyBiZWNhdXNlIG5vIGVuY29kaW5nIGhhcyB0aGlzIHNpdHVhdGlvbiB5ZXQuXG4gICAgICAgICAgLy8gQ3VycmVudGx5LCBqdXN0IHNraXAgdGhlIHNlcXVlbmNlIGFuZCB3cml0ZSBjdXJyZW50IGNoYXIuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNlcU9iaiA9IHVuZGVmaW5lZFxuICAgIH0gZWxzZSBpZiAodUNvZGUgPj0gMCkgeyAgLy8gUmVndWxhciBjaGFyYWN0ZXJcbiAgICAgIHZhciBzdWJ0YWJsZSA9IHRoaXMuZW5jb2RlVGFibGVbdUNvZGUgPj4gOF1cbiAgICAgIGlmIChzdWJ0YWJsZSAhPT0gdW5kZWZpbmVkKSB7IGRiY3NDb2RlID0gc3VidGFibGVbdUNvZGUgJiAweEZGXSB9XG5cbiAgICAgIGlmIChkYmNzQ29kZSA8PSBTRVFfU1RBUlQpIHsgLy8gU2VxdWVuY2Ugc3RhcnRcbiAgICAgICAgc2VxT2JqID0gdGhpcy5lbmNvZGVUYWJsZVNlcVtTRVFfU1RBUlQgLSBkYmNzQ29kZV1cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgaWYgKGRiY3NDb2RlID09IFVOQVNTSUdORUQgJiYgdGhpcy5nYjE4MDMwKSB7XG4gICAgICAgIC8vIFVzZSBHQjE4MDMwIGFsZ29yaXRobSB0byBmaW5kIGNoYXJhY3RlcihzKSB0byB3cml0ZS5cbiAgICAgICAgdmFyIGlkeCA9IGZpbmRJZHgodGhpcy5nYjE4MDMwLnVDaGFycywgdUNvZGUpXG4gICAgICAgIGlmIChpZHggIT0gLTEpIHtcbiAgICAgICAgICB2YXIgZGJjc0NvZGUgPSB0aGlzLmdiMTgwMzAuZ2JDaGFyc1tpZHhdICsgKHVDb2RlIC0gdGhpcy5nYjE4MDMwLnVDaGFyc1tpZHhdKVxuICAgICAgICAgIG5ld0J1ZltqKytdID0gMHg4MSArIE1hdGguZmxvb3IoZGJjc0NvZGUgLyAxMjYwMCk7IGRiY3NDb2RlID0gZGJjc0NvZGUgJSAxMjYwMFxuICAgICAgICAgIG5ld0J1ZltqKytdID0gMHgzMCArIE1hdGguZmxvb3IoZGJjc0NvZGUgLyAxMjYwKTsgZGJjc0NvZGUgPSBkYmNzQ29kZSAlIDEyNjBcbiAgICAgICAgICBuZXdCdWZbaisrXSA9IDB4ODEgKyBNYXRoLmZsb29yKGRiY3NDb2RlIC8gMTApOyBkYmNzQ29kZSA9IGRiY3NDb2RlICUgMTBcbiAgICAgICAgICBuZXdCdWZbaisrXSA9IDB4MzAgKyBkYmNzQ29kZVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAzLiBXcml0ZSBkYmNzQ29kZSBjaGFyYWN0ZXIuXG4gICAgaWYgKGRiY3NDb2RlID09PSBVTkFTU0lHTkVEKSB7IGRiY3NDb2RlID0gdGhpcy5kZWZhdWx0Q2hhclNpbmdsZUJ5dGUgfVxuXG4gICAgaWYgKGRiY3NDb2RlIDwgMHgxMDApIHtcbiAgICAgIG5ld0J1ZltqKytdID0gZGJjc0NvZGVcbiAgICB9IGVsc2UgaWYgKGRiY3NDb2RlIDwgMHgxMDAwMCkge1xuICAgICAgbmV3QnVmW2orK10gPSBkYmNzQ29kZSA+PiA4ICAgLy8gaGlnaCBieXRlXG4gICAgICBuZXdCdWZbaisrXSA9IGRiY3NDb2RlICYgMHhGRiAvLyBsb3cgYnl0ZVxuICAgIH0gZWxzZSBpZiAoZGJjc0NvZGUgPCAweDEwMDAwMDApIHtcbiAgICAgIG5ld0J1ZltqKytdID0gZGJjc0NvZGUgPj4gMTZcbiAgICAgIG5ld0J1ZltqKytdID0gKGRiY3NDb2RlID4+IDgpICYgMHhGRlxuICAgICAgbmV3QnVmW2orK10gPSBkYmNzQ29kZSAmIDB4RkZcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3QnVmW2orK10gPSBkYmNzQ29kZSA+Pj4gMjRcbiAgICAgIG5ld0J1ZltqKytdID0gKGRiY3NDb2RlID4+PiAxNikgJiAweEZGXG4gICAgICBuZXdCdWZbaisrXSA9IChkYmNzQ29kZSA+Pj4gOCkgJiAweEZGXG4gICAgICBuZXdCdWZbaisrXSA9IGRiY3NDb2RlICYgMHhGRlxuICAgIH1cbiAgfVxuXG4gIHRoaXMuc2VxT2JqID0gc2VxT2JqXG4gIHRoaXMubGVhZFN1cnJvZ2F0ZSA9IGxlYWRTdXJyb2dhdGVcbiAgcmV0dXJuIG5ld0J1Zi5zbGljZSgwLCBqKVxufVxuXG5EQkNTRW5jb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5sZWFkU3Vycm9nYXRlID09PSAtMSAmJiB0aGlzLnNlcU9iaiA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB9IC8vIEFsbCBjbGVhbi4gTW9zdCBvZnRlbiBjYXNlLlxuXG4gIHZhciBuZXdCdWYgPSBCdWZmZXIuYWxsb2MoMTApOyB2YXIgaiA9IDBcblxuICBpZiAodGhpcy5zZXFPYmopIHsgLy8gV2UncmUgaW4gdGhlIHNlcXVlbmNlLlxuICAgIHZhciBkYmNzQ29kZSA9IHRoaXMuc2VxT2JqW0RFRl9DSEFSXVxuICAgIGlmIChkYmNzQ29kZSAhPT0gdW5kZWZpbmVkKSB7IC8vIFdyaXRlIGJlZ2lubmluZyBvZiB0aGUgc2VxdWVuY2UuXG4gICAgICBpZiAoZGJjc0NvZGUgPCAweDEwMCkge1xuICAgICAgICBuZXdCdWZbaisrXSA9IGRiY3NDb2RlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdCdWZbaisrXSA9IGRiY3NDb2RlID4+IDggICAvLyBoaWdoIGJ5dGVcbiAgICAgICAgbmV3QnVmW2orK10gPSBkYmNzQ29kZSAmIDB4RkYgLy8gbG93IGJ5dGVcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2VlIHRvZG8gYWJvdmUuXG4gICAgfVxuICAgIHRoaXMuc2VxT2JqID0gdW5kZWZpbmVkXG4gIH1cblxuICBpZiAodGhpcy5sZWFkU3Vycm9nYXRlICE9PSAtMSkge1xuICAgIC8vIEluY29tcGxldGUgc3Vycm9nYXRlIHBhaXIgLSBvbmx5IGxlYWQgc3Vycm9nYXRlIGZvdW5kLlxuICAgIG5ld0J1ZltqKytdID0gdGhpcy5kZWZhdWx0Q2hhclNpbmdsZUJ5dGVcbiAgICB0aGlzLmxlYWRTdXJyb2dhdGUgPSAtMVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1Zi5zbGljZSgwLCBqKVxufVxuXG4vLyBFeHBvcnQgZm9yIHRlc3RpbmdcbkRCQ1NFbmNvZGVyLnByb3RvdHlwZS5maW5kSWR4ID0gZmluZElkeFxuXG4vLyA9PSBEZWNvZGVyID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBEQkNTRGVjb2RlciAob3B0aW9ucywgY29kZWMpIHtcbiAgLy8gRGVjb2RlciBzdGF0ZVxuICB0aGlzLm5vZGVJZHggPSAwXG4gIHRoaXMucHJldkJ5dGVzID0gW11cblxuICAvLyBTdGF0aWMgZGF0YVxuICB0aGlzLmRlY29kZVRhYmxlcyA9IGNvZGVjLmRlY29kZVRhYmxlc1xuICB0aGlzLmRlY29kZVRhYmxlU2VxID0gY29kZWMuZGVjb2RlVGFibGVTZXFcbiAgdGhpcy5kZWZhdWx0Q2hhclVuaWNvZGUgPSBjb2RlYy5kZWZhdWx0Q2hhclVuaWNvZGVcbiAgdGhpcy5nYjE4MDMwID0gY29kZWMuZ2IxODAzMFxufVxuXG5EQkNTRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIHZhciBuZXdCdWYgPSBCdWZmZXIuYWxsb2MoYnVmLmxlbmd0aCAqIDIpXG4gIHZhciBub2RlSWR4ID0gdGhpcy5ub2RlSWR4XG4gIHZhciBwcmV2Qnl0ZXMgPSB0aGlzLnByZXZCeXRlczsgdmFyIHByZXZPZmZzZXQgPSB0aGlzLnByZXZCeXRlcy5sZW5ndGhcbiAgdmFyIHNlcVN0YXJ0ID0gLXRoaXMucHJldkJ5dGVzLmxlbmd0aCAvLyBpZHggb2YgdGhlIHN0YXJ0IG9mIGN1cnJlbnQgcGFyc2VkIHNlcXVlbmNlLlxuICB2YXIgdUNvZGVcblxuICBmb3IgKHZhciBpID0gMCwgaiA9IDA7IGkgPCBidWYubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY3VyQnl0ZSA9IChpID49IDApID8gYnVmW2ldIDogcHJldkJ5dGVzW2kgKyBwcmV2T2Zmc2V0XVxuXG4gICAgLy8gTG9va3VwIGluIGN1cnJlbnQgdHJpZSBub2RlLlxuICAgIHZhciB1Q29kZSA9IHRoaXMuZGVjb2RlVGFibGVzW25vZGVJZHhdW2N1ckJ5dGVdXG5cbiAgICBpZiAodUNvZGUgPj0gMCkge1xuICAgICAgLy8gTm9ybWFsIGNoYXJhY3RlciwganVzdCB1c2UgaXQuXG4gICAgfSBlbHNlIGlmICh1Q29kZSA9PT0gVU5BU1NJR05FRCkgeyAvLyBVbmtub3duIGNoYXIuXG4gICAgICAvLyBUT0RPOiBDYWxsYmFjayB3aXRoIHNlcS5cbiAgICAgIHVDb2RlID0gdGhpcy5kZWZhdWx0Q2hhclVuaWNvZGUuY2hhckNvZGVBdCgwKVxuICAgICAgaSA9IHNlcVN0YXJ0IC8vIFNraXAgb25lIGJ5dGUgKCdpJyB3aWxsIGJlIGluY3JlbWVudGVkIGJ5IHRoZSBmb3IgbG9vcCkgYW5kIHRyeSB0byBwYXJzZSBhZ2Fpbi5cbiAgICB9IGVsc2UgaWYgKHVDb2RlID09PSBHQjE4MDMwX0NPREUpIHtcbiAgICAgIGlmIChpID49IDMpIHtcbiAgICAgICAgdmFyIHB0ciA9IChidWZbaSAtIDNdIC0gMHg4MSkgKiAxMjYwMCArIChidWZbaSAtIDJdIC0gMHgzMCkgKiAxMjYwICsgKGJ1ZltpIC0gMV0gLSAweDgxKSAqIDEwICsgKGN1ckJ5dGUgLSAweDMwKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHB0ciA9IChwcmV2Qnl0ZXNbaSAtIDMgKyBwcmV2T2Zmc2V0XSAtIDB4ODEpICogMTI2MDAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAoKChpIC0gMiA+PSAwKSA/IGJ1ZltpIC0gMl0gOiBwcmV2Qnl0ZXNbaSAtIDIgKyBwcmV2T2Zmc2V0XSkgLSAweDMwKSAqIDEyNjAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAoKChpIC0gMSA+PSAwKSA/IGJ1ZltpIC0gMV0gOiBwcmV2Qnl0ZXNbaSAtIDEgKyBwcmV2T2Zmc2V0XSkgLSAweDgxKSAqIDEwICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKGN1ckJ5dGUgLSAweDMwKVxuICAgICAgfVxuICAgICAgdmFyIGlkeCA9IGZpbmRJZHgodGhpcy5nYjE4MDMwLmdiQ2hhcnMsIHB0cilcbiAgICAgIHVDb2RlID0gdGhpcy5nYjE4MDMwLnVDaGFyc1tpZHhdICsgcHRyIC0gdGhpcy5nYjE4MDMwLmdiQ2hhcnNbaWR4XVxuICAgIH0gZWxzZSBpZiAodUNvZGUgPD0gTk9ERV9TVEFSVCkgeyAvLyBHbyB0byBuZXh0IHRyaWUgbm9kZS5cbiAgICAgIG5vZGVJZHggPSBOT0RFX1NUQVJUIC0gdUNvZGVcbiAgICAgIGNvbnRpbnVlXG4gICAgfSBlbHNlIGlmICh1Q29kZSA8PSBTRVFfU1RBUlQpIHsgLy8gT3V0cHV0IGEgc2VxdWVuY2Ugb2YgY2hhcnMuXG4gICAgICB2YXIgc2VxID0gdGhpcy5kZWNvZGVUYWJsZVNlcVtTRVFfU1RBUlQgLSB1Q29kZV1cbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgc2VxLmxlbmd0aCAtIDE7IGsrKykge1xuICAgICAgICB1Q29kZSA9IHNlcVtrXVxuICAgICAgICBuZXdCdWZbaisrXSA9IHVDb2RlICYgMHhGRlxuICAgICAgICBuZXdCdWZbaisrXSA9IHVDb2RlID4+IDhcbiAgICAgIH1cbiAgICAgIHVDb2RlID0gc2VxW3NlcS5sZW5ndGggLSAxXVxuICAgIH0gZWxzZSB7IHRocm93IG5ldyBFcnJvcihcImljb252LWxpdGUgaW50ZXJuYWwgZXJyb3I6IGludmFsaWQgZGVjb2RpbmcgdGFibGUgdmFsdWUgXCIgKyB1Q29kZSArIFwiIGF0IFwiICsgbm9kZUlkeCArIFwiL1wiICsgY3VyQnl0ZSkgfVxuXG4gICAgLy8gV3JpdGUgdGhlIGNoYXJhY3RlciB0byBidWZmZXIsIGhhbmRsaW5nIGhpZ2hlciBwbGFuZXMgdXNpbmcgc3Vycm9nYXRlIHBhaXIuXG4gICAgaWYgKHVDb2RlID49IDB4MTAwMDApIHtcbiAgICAgIHVDb2RlIC09IDB4MTAwMDBcbiAgICAgIHZhciB1Q29kZUxlYWQgPSAweEQ4MDAgfCAodUNvZGUgPj4gMTApXG4gICAgICBuZXdCdWZbaisrXSA9IHVDb2RlTGVhZCAmIDB4RkZcbiAgICAgIG5ld0J1ZltqKytdID0gdUNvZGVMZWFkID4+IDhcblxuICAgICAgdUNvZGUgPSAweERDMDAgfCAodUNvZGUgJiAweDNGRilcbiAgICB9XG4gICAgbmV3QnVmW2orK10gPSB1Q29kZSAmIDB4RkZcbiAgICBuZXdCdWZbaisrXSA9IHVDb2RlID4+IDhcblxuICAgIC8vIFJlc2V0IHRyaWUgbm9kZS5cbiAgICBub2RlSWR4ID0gMDsgc2VxU3RhcnQgPSBpICsgMVxuICB9XG5cbiAgdGhpcy5ub2RlSWR4ID0gbm9kZUlkeFxuICB0aGlzLnByZXZCeXRlcyA9IChzZXFTdGFydCA+PSAwKVxuICAgID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYnVmLCBzZXFTdGFydClcbiAgICA6IHByZXZCeXRlcy5zbGljZShzZXFTdGFydCArIHByZXZPZmZzZXQpLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChidWYpKVxuXG4gIHJldHVybiBuZXdCdWYuc2xpY2UoMCwgaikudG9TdHJpbmcoXCJ1Y3MyXCIpXG59XG5cbkRCQ1NEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByZXQgPSBcIlwiXG5cbiAgLy8gVHJ5IHRvIHBhcnNlIGFsbCByZW1haW5pbmcgY2hhcnMuXG4gIHdoaWxlICh0aGlzLnByZXZCeXRlcy5sZW5ndGggPiAwKSB7XG4gICAgLy8gU2tpcCAxIGNoYXJhY3RlciBpbiB0aGUgYnVmZmVyLlxuICAgIHJldCArPSB0aGlzLmRlZmF1bHRDaGFyVW5pY29kZVxuICAgIHZhciBieXRlc0FyciA9IHRoaXMucHJldkJ5dGVzLnNsaWNlKDEpXG5cbiAgICAvLyBQYXJzZSByZW1haW5pbmcgYXMgdXN1YWwuXG4gICAgdGhpcy5wcmV2Qnl0ZXMgPSBbXVxuICAgIHRoaXMubm9kZUlkeCA9IDBcbiAgICBpZiAoYnl0ZXNBcnIubGVuZ3RoID4gMCkgeyByZXQgKz0gdGhpcy53cml0ZShieXRlc0FycikgfVxuICB9XG5cbiAgdGhpcy5wcmV2Qnl0ZXMgPSBbXVxuICB0aGlzLm5vZGVJZHggPSAwXG4gIHJldHVybiByZXRcbn1cblxuLy8gQmluYXJ5IHNlYXJjaCBmb3IgR0IxODAzMC4gUmV0dXJucyBsYXJnZXN0IGkgc3VjaCB0aGF0IHRhYmxlW2ldIDw9IHZhbC5cbmZ1bmN0aW9uIGZpbmRJZHggKHRhYmxlLCB2YWwpIHtcbiAgaWYgKHRhYmxlWzBdID4gdmFsKSB7IHJldHVybiAtMSB9XG5cbiAgdmFyIGwgPSAwOyB2YXIgciA9IHRhYmxlLmxlbmd0aFxuICB3aGlsZSAobCA8IHIgLSAxKSB7IC8vIGFsd2F5cyB0YWJsZVtsXSA8PSB2YWwgPCB0YWJsZVtyXVxuICAgIHZhciBtaWQgPSBsICsgKChyIC0gbCArIDEpID4+IDEpXG4gICAgaWYgKHRhYmxlW21pZF0gPD0gdmFsKSB7IGwgPSBtaWQgfSBlbHNlIHsgciA9IG1pZCB9XG4gIH1cbiAgcmV0dXJuIGxcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/dbcs-codec.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/dbcs-data.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/mailparser/node_modules/iconv-lite/encodings/dbcs-data.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n// Description of supported double byte encodings and aliases.\n// Tables are not require()-d until they are needed to speed up library load.\n// require()-s are direct to support Browserify.\n\nmodule.exports = {\n\n  // == Japanese/ShiftJIS ====================================================\n  // All japanese encodings are based on JIS X set of standards:\n  // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.\n  // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes.\n  //              Has several variations in 1978, 1983, 1990 and 1997.\n  // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.\n  // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.\n  //              2 planes, first is superset of 0208, second - revised 0212.\n  //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)\n\n  // Byte encodings are:\n  //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte\n  //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.\n  //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.\n  //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.\n  //               0x00-0x7F       - lower part of 0201\n  //               0x8E, 0xA1-0xDF - upper part of 0201\n  //               (0xA1-0xFE)x2   - 0208 plane (94x94).\n  //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).\n  //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.\n  //               Used as-is in ISO2022 family.\n  //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII,\n  //                0201-1976 Roman, 0208-1978, 0208-1983.\n  //  * ISO2022-JP-1: Adds esc seq for 0212-1990.\n  //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.\n  //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.\n  //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.\n  //\n  // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.\n  //\n  // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html\n\n  shiftjis: {\n    type: \"_dbcs\",\n    table: function () { return __webpack_require__(/*! ./tables/shiftjis.json */ \"(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/tables/shiftjis.json\") },\n    encodeAdd: { \"\\u00a5\": 0x5C, \"\\u203E\": 0x7E },\n    encodeSkipVals: [{ from: 0xED40, to: 0xF940 }]\n  },\n  csshiftjis: \"shiftjis\",\n  mskanji: \"shiftjis\",\n  sjis: \"shiftjis\",\n  windows31j: \"shiftjis\",\n  ms31j: \"shiftjis\",\n  xsjis: \"shiftjis\",\n  windows932: \"shiftjis\",\n  ms932: \"shiftjis\",\n  932: \"shiftjis\",\n  cp932: \"shiftjis\",\n\n  eucjp: {\n    type: \"_dbcs\",\n    table: function () { return __webpack_require__(/*! ./tables/eucjp.json */ \"(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/tables/eucjp.json\") },\n    encodeAdd: { \"\\u00a5\": 0x5C, \"\\u203E\": 0x7E }\n  },\n\n  // TODO: KDDI extension to Shift_JIS\n  // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.\n  // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.\n\n  // == Chinese/GBK ==========================================================\n  // http://en.wikipedia.org/wiki/GBK\n  // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder\n\n  // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936\n  gb2312: \"cp936\",\n  gb231280: \"cp936\",\n  gb23121980: \"cp936\",\n  csgb2312: \"cp936\",\n  csiso58gb231280: \"cp936\",\n  euccn: \"cp936\",\n\n  // Microsoft's CP936 is a subset and approximation of GBK.\n  windows936: \"cp936\",\n  ms936: \"cp936\",\n  936: \"cp936\",\n  cp936: {\n    type: \"_dbcs\",\n    table: function () { return __webpack_require__(/*! ./tables/cp936.json */ \"(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/tables/cp936.json\") }\n  },\n\n  // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.\n  gbk: {\n    type: \"_dbcs\",\n    table: function () { return (__webpack_require__(/*! ./tables/cp936.json */ \"(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/tables/cp936.json\").concat)(__webpack_require__(/*! ./tables/gbk-added.json */ \"(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/tables/gbk-added.json\")) }\n  },\n  xgbk: \"gbk\",\n  isoir58: \"gbk\",\n\n  // GB18030 is an algorithmic extension of GBK.\n  // Main source: https://www.w3.org/TR/encoding/#gbk-encoder\n  // http://icu-project.org/docs/papers/gb18030.html\n  // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml\n  // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0\n  gb18030: {\n    type: \"_dbcs\",\n    table: function () { return (__webpack_require__(/*! ./tables/cp936.json */ \"(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/tables/cp936.json\").concat)(__webpack_require__(/*! ./tables/gbk-added.json */ \"(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/tables/gbk-added.json\")) },\n    gb18030: function () { return __webpack_require__(/*! ./tables/gb18030-ranges.json */ \"(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/tables/gb18030-ranges.json\") },\n    encodeSkipVals: [0x80],\n    encodeAdd: { \"\": 0xA2E3 }\n  },\n\n  chinese: \"gb18030\",\n\n  // == Korean ===============================================================\n  // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.\n  windows949: \"cp949\",\n  ms949: \"cp949\",\n  949: \"cp949\",\n  cp949: {\n    type: \"_dbcs\",\n    table: function () { return __webpack_require__(/*! ./tables/cp949.json */ \"(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/tables/cp949.json\") }\n  },\n\n  cseuckr: \"cp949\",\n  csksc56011987: \"cp949\",\n  euckr: \"cp949\",\n  isoir149: \"cp949\",\n  korean: \"cp949\",\n  ksc56011987: \"cp949\",\n  ksc56011989: \"cp949\",\n  ksc5601: \"cp949\",\n\n  // == Big5/Taiwan/Hong Kong ================================================\n  // There are lots of tables for Big5 and cp950. Please see the following links for history:\n  // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html\n  // Variations, in roughly number of defined chars:\n  //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT\n  //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/\n  //  * Big5-2003 (Taiwan standard) almost superset of cp950.\n  //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.\n  //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard.\n  //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.\n  //    Plus, it has 4 combining sequences.\n  //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299\n  //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.\n  //    Implementations are not consistent within browsers; sometimes labeled as just big5.\n  //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.\n  //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31\n  //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.\n  //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt\n  //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt\n  //\n  // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder\n  // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.\n\n  windows950: \"cp950\",\n  ms950: \"cp950\",\n  950: \"cp950\",\n  cp950: {\n    type: \"_dbcs\",\n    table: function () { return __webpack_require__(/*! ./tables/cp950.json */ \"(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/tables/cp950.json\") }\n  },\n\n  // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.\n  big5: \"big5hkscs\",\n  big5hkscs: {\n    type: \"_dbcs\",\n    table: function () { return (__webpack_require__(/*! ./tables/cp950.json */ \"(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/tables/cp950.json\").concat)(__webpack_require__(/*! ./tables/big5-added.json */ \"(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/tables/big5-added.json\")) },\n    encodeSkipVals: [\n      // Although Encoding Standard says we should avoid encoding to HKSCS area (See Step 1 of\n      // https://encoding.spec.whatwg.org/#index-big5-pointer), we still do it to increase compatibility with ICU.\n      // But if a single unicode point can be encoded both as HKSCS and regular Big5, we prefer the latter.\n      0x8e69, 0x8e6f, 0x8e7e, 0x8eab, 0x8eb4, 0x8ecd, 0x8ed0, 0x8f57, 0x8f69, 0x8f6e, 0x8fcb, 0x8ffe,\n      0x906d, 0x907a, 0x90c4, 0x90dc, 0x90f1, 0x91bf, 0x92af, 0x92b0, 0x92b1, 0x92b2, 0x92d1, 0x9447, 0x94ca,\n      0x95d9, 0x96fc, 0x9975, 0x9b76, 0x9b78, 0x9b7b, 0x9bc6, 0x9bde, 0x9bec, 0x9bf6, 0x9c42, 0x9c53, 0x9c62,\n      0x9c68, 0x9c6b, 0x9c77, 0x9cbc, 0x9cbd, 0x9cd0, 0x9d57, 0x9d5a, 0x9dc4, 0x9def, 0x9dfb, 0x9ea9, 0x9eef,\n      0x9efd, 0x9f60, 0x9fcb, 0xa077, 0xa0dc, 0xa0df, 0x8fcc, 0x92c8, 0x9644, 0x96ed,\n\n      // Step 2 of https://encoding.spec.whatwg.org/#index-big5-pointer: Use last pointer for U+2550, U+255E, U+2561, U+256A, U+5341, or U+5345\n      0xa2a4, 0xa2a5, 0xa2a7, 0xa2a6, 0xa2cc, 0xa2ce\n    ]\n  },\n\n  cnbig5: \"big5hkscs\",\n  csbig5: \"big5hkscs\",\n  xxbig5: \"big5hkscs\"\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL21haWxwYXJzZXIvbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvZW5jb2RpbmdzL2RiY3MtZGF0YS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTyxtQkFBTyxDQUFDLHVIQUF3QixHQUFHO0FBQ25FLGlCQUFpQixnQ0FBZ0M7QUFDakQsdUJBQXVCLDBCQUEwQjtBQUNqRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QixPQUFPLG1CQUFPLENBQUMsaUhBQXFCLEdBQUc7QUFDaEUsaUJBQWlCO0FBQ2pCLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTyxtQkFBTyxDQUFDLGlIQUFxQjtBQUM3RCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixPQUFPLCtJQUFxQyxDQUFDLG1CQUFPLENBQUMseUhBQXlCO0FBQ3ZHLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU8sK0lBQXFDLENBQUMsbUJBQU8sQ0FBQyx5SEFBeUIsSUFBSTtBQUMzRywyQkFBMkIsT0FBTyxtQkFBTyxDQUFDLG1JQUE4QixHQUFHO0FBQzNFO0FBQ0EsaUJBQWlCO0FBQ2pCLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTyxtQkFBTyxDQUFDLGlIQUFxQjtBQUM3RCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU8sbUJBQU8sQ0FBQyxpSEFBcUI7QUFDN0QsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixPQUFPLCtJQUFxQyxDQUFDLG1CQUFPLENBQUMsMkhBQTBCLElBQUk7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xca2ZyeXRcXC5nZW1pbmlcXGFudGlncmF2aXR5XFxzY3JhdGNoXFxkcl9rYWxzX3ZpcnR1YWxfaG9zcGl0YWxcXG5vZGVfbW9kdWxlc1xcbWFpbHBhcnNlclxcbm9kZV9tb2R1bGVzXFxpY29udi1saXRlXFxlbmNvZGluZ3NcXGRiY3MtZGF0YS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxuXG4vLyBEZXNjcmlwdGlvbiBvZiBzdXBwb3J0ZWQgZG91YmxlIGJ5dGUgZW5jb2RpbmdzIGFuZCBhbGlhc2VzLlxuLy8gVGFibGVzIGFyZSBub3QgcmVxdWlyZSgpLWQgdW50aWwgdGhleSBhcmUgbmVlZGVkIHRvIHNwZWVkIHVwIGxpYnJhcnkgbG9hZC5cbi8vIHJlcXVpcmUoKS1zIGFyZSBkaXJlY3QgdG8gc3VwcG9ydCBCcm93c2VyaWZ5LlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAvLyA9PSBKYXBhbmVzZS9TaGlmdEpJUyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIEFsbCBqYXBhbmVzZSBlbmNvZGluZ3MgYXJlIGJhc2VkIG9uIEpJUyBYIHNldCBvZiBzdGFuZGFyZHM6XG4gIC8vIEpJUyBYIDAyMDEgLSBTaW5nbGUtYnl0ZSBlbmNvZGluZyBvZiBBU0NJSSArIMKlICsgS2FuYSBjaGFycyBhdCAweEExLTB4REYuXG4gIC8vIEpJUyBYIDAyMDggLSBNYWluIHNldCBvZiA2ODc5IGNoYXJhY3RlcnMsIHBsYWNlZCBpbiA5NHg5NCBwbGFuZSwgdG8gYmUgZW5jb2RlZCBieSAyIGJ5dGVzLlxuICAvLyAgICAgICAgICAgICAgSGFzIHNldmVyYWwgdmFyaWF0aW9ucyBpbiAxOTc4LCAxOTgzLCAxOTkwIGFuZCAxOTk3LlxuICAvLyBKSVMgWCAwMjEyIC0gU3VwcGxlbWVudGFyeSBwbGFuZSBvZiA2MDY3IGNoYXJzIGluIDk0eDk0IHBsYW5lLiAxOTkwLiBFZmZlY3RpdmVseSBkZWFkLlxuICAvLyBKSVMgWCAwMjEzIC0gRXh0ZW5zaW9uIGFuZCBtb2Rlcm4gcmVwbGFjZW1lbnQgb2YgMDIwOCBhbmQgMDIxMi4gVG90YWwgY2hhcnM6IDExMjMzLlxuICAvLyAgICAgICAgICAgICAgMiBwbGFuZXMsIGZpcnN0IGlzIHN1cGVyc2V0IG9mIDAyMDgsIHNlY29uZCAtIHJldmlzZWQgMDIxMi5cbiAgLy8gICAgICAgICAgICAgIEludHJvZHVjZWQgaW4gMjAwMCwgcmV2aXNlZCAyMDA0LiBTb21lIGNoYXJhY3RlcnMgYXJlIGluIFVuaWNvZGUgUGxhbmUgMiAoMHgyeHh4eClcblxuICAvLyBCeXRlIGVuY29kaW5ncyBhcmU6XG4gIC8vICAqIFNoaWZ0X0pJUzogQ29tcGF0aWJsZSB3aXRoIDAyMDEsIHVzZXMgbm90IGRlZmluZWQgY2hhcnMgaW4gdG9wIGhhbGYgYXMgbGVhZCBieXRlcyBmb3IgZG91YmxlLWJ5dGVcbiAgLy8gICAgICAgICAgICAgICBlbmNvZGluZyBvZiAwMjA4LiBMZWFkIGJ5dGUgcmFuZ2VzOiAweDgxLTB4OUYsIDB4RTAtMHhFRjsgVHJhaWwgYnl0ZSByYW5nZXM6IDB4NDAtMHg3RSwgMHg4MC0weDlFLCAweDlGLTB4RkMuXG4gIC8vICAgICAgICAgICAgICAgV2luZG93cyBDUDkzMiBpcyBhIHN1cGVyc2V0IG9mIFNoaWZ0X0pJUy4gU29tZSBjb21wYW5pZXMgYWRkZWQgbW9yZSBjaGFycywgbm90YWJseSBLRERJLlxuICAvLyAgKiBFVUMtSlA6ICAgIFVwIHRvIDMgYnl0ZXMgcGVyIGNoYXJhY3Rlci4gVXNlZCBtb3N0bHkgb24gKm5peGVzLlxuICAvLyAgICAgICAgICAgICAgIDB4MDAtMHg3RiAgICAgICAtIGxvd2VyIHBhcnQgb2YgMDIwMVxuICAvLyAgICAgICAgICAgICAgIDB4OEUsIDB4QTEtMHhERiAtIHVwcGVyIHBhcnQgb2YgMDIwMVxuICAvLyAgICAgICAgICAgICAgICgweEExLTB4RkUpeDIgICAtIDAyMDggcGxhbmUgKDk0eDk0KS5cbiAgLy8gICAgICAgICAgICAgICAweDhGLCAoMHhBMS0weEZFKXgyIC0gMDIxMiBwbGFuZSAoOTR4OTQpLlxuICAvLyAgKiBKSVMgWCAyMDg6IDctYml0LCBkaXJlY3QgZW5jb2Rpbmcgb2YgMDIwOC4gQnl0ZSByYW5nZXM6IDB4MjEtMHg3RSAoOTQgdmFsdWVzKS4gVW5jb21tb24uXG4gIC8vICAgICAgICAgICAgICAgVXNlZCBhcy1pcyBpbiBJU08yMDIyIGZhbWlseS5cbiAgLy8gICogSVNPMjAyMi1KUDogU3RhdGVmdWwgZW5jb2RpbmcsIHdpdGggZXNjYXBlIHNlcXVlbmNlcyB0byBzd2l0Y2ggYmV0d2VlbiBBU0NJSSxcbiAgLy8gICAgICAgICAgICAgICAgMDIwMS0xOTc2IFJvbWFuLCAwMjA4LTE5NzgsIDAyMDgtMTk4My5cbiAgLy8gICogSVNPMjAyMi1KUC0xOiBBZGRzIGVzYyBzZXEgZm9yIDAyMTItMTk5MC5cbiAgLy8gICogSVNPMjAyMi1KUC0yOiBBZGRzIGVzYyBzZXEgZm9yIEdCMjMxMy0xOTgwLCBLU1gxMDAxLTE5OTIsIElTTzg4NTktMSwgSVNPODg1OS03LlxuICAvLyAgKiBJU08yMDIyLUpQLTM6IEFkZHMgZXNjIHNlcSBmb3IgMDIwMS0xOTc2IEthbmEgc2V0LCAwMjEzLTIwMDAgUGxhbmVzIDEsIDIuXG4gIC8vICAqIElTTzIwMjItSlAtMjAwNDogQWRkcyAwMjEzLTIwMDQgUGxhbmUgMS5cbiAgLy9cbiAgLy8gQWZ0ZXIgSklTIFggMDIxMyBhcHBlYXJlZCwgU2hpZnRfSklTLTIwMDQsIEVVQy1KSVNYMDIxMyBhbmQgSVNPMjAyMi1KUC0yMDA0IGZvbGxvd2VkLCB3aXRoIGp1c3QgY2hhbmdpbmcgdGhlIHBsYW5lcy5cbiAgLy9cbiAgLy8gT3ZlcmFsbCwgaXQgc2VlbXMgdGhhdCBpdCdzIGEgbWVzcyA6KCBodHRwOi8vd3d3OC5wbGFsYS5vci5qcC90a3Vib3RhMS91bmljb2RlLXN5bWJvbHMtbWFwMi5odG1sXG5cbiAgc2hpZnRqaXM6IHtcbiAgICB0eXBlOiBcIl9kYmNzXCIsXG4gICAgdGFibGU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlcXVpcmUoXCIuL3RhYmxlcy9zaGlmdGppcy5qc29uXCIpIH0sXG4gICAgZW5jb2RlQWRkOiB7IFwiXFx1MDBhNVwiOiAweDVDLCBcIlxcdTIwM0VcIjogMHg3RSB9LFxuICAgIGVuY29kZVNraXBWYWxzOiBbeyBmcm9tOiAweEVENDAsIHRvOiAweEY5NDAgfV1cbiAgfSxcbiAgY3NzaGlmdGppczogXCJzaGlmdGppc1wiLFxuICBtc2thbmppOiBcInNoaWZ0amlzXCIsXG4gIHNqaXM6IFwic2hpZnRqaXNcIixcbiAgd2luZG93czMxajogXCJzaGlmdGppc1wiLFxuICBtczMxajogXCJzaGlmdGppc1wiLFxuICB4c2ppczogXCJzaGlmdGppc1wiLFxuICB3aW5kb3dzOTMyOiBcInNoaWZ0amlzXCIsXG4gIG1zOTMyOiBcInNoaWZ0amlzXCIsXG4gIDkzMjogXCJzaGlmdGppc1wiLFxuICBjcDkzMjogXCJzaGlmdGppc1wiLFxuXG4gIGV1Y2pwOiB7XG4gICAgdHlwZTogXCJfZGJjc1wiLFxuICAgIHRhYmxlOiBmdW5jdGlvbiAoKSB7IHJldHVybiByZXF1aXJlKFwiLi90YWJsZXMvZXVjanAuanNvblwiKSB9LFxuICAgIGVuY29kZUFkZDogeyBcIlxcdTAwYTVcIjogMHg1QywgXCJcXHUyMDNFXCI6IDB4N0UgfVxuICB9LFxuXG4gIC8vIFRPRE86IEtEREkgZXh0ZW5zaW9uIHRvIFNoaWZ0X0pJU1xuICAvLyBUT0RPOiBJQk0gQ0NTSUQgOTQyID0gQ1A5MzIsIGJ1dCBGMC1GOSBjdXN0b20gY2hhcnMgYW5kIG90aGVyIGNoYXIgY2hhbmdlcy5cbiAgLy8gVE9ETzogSUJNIENDU0lEIDk0MyA9IFNoaWZ0X0pJUyA9IENQOTMyIHdpdGggb3JpZ2luYWwgU2hpZnRfSklTIGxvd2VyIDEyOCBjaGFycy5cblxuICAvLyA9PSBDaGluZXNlL0dCSyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR0JLXG4gIC8vIFdlIG1vc3RseSBpbXBsZW1lbnQgVzNDIHJlY29tbWVuZGF0aW9uOiBodHRwczovL3d3dy53My5vcmcvVFIvZW5jb2RpbmcvI2diay1lbmNvZGVyXG5cbiAgLy8gT2xkZXN0IEdCMjMxMiAoMTk4MSwgfjc2MDAgY2hhcnMpIGlzIGEgc3Vic2V0IG9mIENQOTM2XG4gIGdiMjMxMjogXCJjcDkzNlwiLFxuICBnYjIzMTI4MDogXCJjcDkzNlwiLFxuICBnYjIzMTIxOTgwOiBcImNwOTM2XCIsXG4gIGNzZ2IyMzEyOiBcImNwOTM2XCIsXG4gIGNzaXNvNThnYjIzMTI4MDogXCJjcDkzNlwiLFxuICBldWNjbjogXCJjcDkzNlwiLFxuXG4gIC8vIE1pY3Jvc29mdCdzIENQOTM2IGlzIGEgc3Vic2V0IGFuZCBhcHByb3hpbWF0aW9uIG9mIEdCSy5cbiAgd2luZG93czkzNjogXCJjcDkzNlwiLFxuICBtczkzNjogXCJjcDkzNlwiLFxuICA5MzY6IFwiY3A5MzZcIixcbiAgY3A5MzY6IHtcbiAgICB0eXBlOiBcIl9kYmNzXCIsXG4gICAgdGFibGU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlcXVpcmUoXCIuL3RhYmxlcy9jcDkzNi5qc29uXCIpIH1cbiAgfSxcblxuICAvLyBHQksgKH4yMjAwMCBjaGFycykgaXMgYW4gZXh0ZW5zaW9uIG9mIENQOTM2IHRoYXQgYWRkZWQgdXNlci1tYXBwZWQgY2hhcnMgYW5kIHNvbWUgb3RoZXIuXG4gIGdiazoge1xuICAgIHR5cGU6IFwiX2RiY3NcIixcbiAgICB0YWJsZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVxdWlyZShcIi4vdGFibGVzL2NwOTM2Lmpzb25cIikuY29uY2F0KHJlcXVpcmUoXCIuL3RhYmxlcy9nYmstYWRkZWQuanNvblwiKSkgfVxuICB9LFxuICB4Z2JrOiBcImdia1wiLFxuICBpc29pcjU4OiBcImdia1wiLFxuXG4gIC8vIEdCMTgwMzAgaXMgYW4gYWxnb3JpdGhtaWMgZXh0ZW5zaW9uIG9mIEdCSy5cbiAgLy8gTWFpbiBzb3VyY2U6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9lbmNvZGluZy8jZ2JrLWVuY29kZXJcbiAgLy8gaHR0cDovL2ljdS1wcm9qZWN0Lm9yZy9kb2NzL3BhcGVycy9nYjE4MDMwLmh0bWxcbiAgLy8gaHR0cDovL3NvdXJjZS5pY3UtcHJvamVjdC5vcmcvcmVwb3MvaWN1L2RhdGEvdHJ1bmsvY2hhcnNldC9kYXRhL3htbC9nYi0xODAzMC0yMDAwLnhtbFxuICAvLyBodHRwOi8vd3d3LmtobmdhaS5jb20vY2hpbmVzZS9jaGFybWFwL3RibGdiay5waHA/cGFnZT0wXG4gIGdiMTgwMzA6IHtcbiAgICB0eXBlOiBcIl9kYmNzXCIsXG4gICAgdGFibGU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlcXVpcmUoXCIuL3RhYmxlcy9jcDkzNi5qc29uXCIpLmNvbmNhdChyZXF1aXJlKFwiLi90YWJsZXMvZ2JrLWFkZGVkLmpzb25cIikpIH0sXG4gICAgZ2IxODAzMDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVxdWlyZShcIi4vdGFibGVzL2diMTgwMzAtcmFuZ2VzLmpzb25cIikgfSxcbiAgICBlbmNvZGVTa2lwVmFsczogWzB4ODBdLFxuICAgIGVuY29kZUFkZDogeyBcIuKCrFwiOiAweEEyRTMgfVxuICB9LFxuXG4gIGNoaW5lc2U6IFwiZ2IxODAzMFwiLFxuXG4gIC8vID09IEtvcmVhbiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gRVVDLUtSLCBLU19DXzU2MDEgYW5kIEtTIFggMTAwMSBhcmUgZXhhY3RseSB0aGUgc2FtZS5cbiAgd2luZG93czk0OTogXCJjcDk0OVwiLFxuICBtczk0OTogXCJjcDk0OVwiLFxuICA5NDk6IFwiY3A5NDlcIixcbiAgY3A5NDk6IHtcbiAgICB0eXBlOiBcIl9kYmNzXCIsXG4gICAgdGFibGU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlcXVpcmUoXCIuL3RhYmxlcy9jcDk0OS5qc29uXCIpIH1cbiAgfSxcblxuICBjc2V1Y2tyOiBcImNwOTQ5XCIsXG4gIGNza3NjNTYwMTE5ODc6IFwiY3A5NDlcIixcbiAgZXVja3I6IFwiY3A5NDlcIixcbiAgaXNvaXIxNDk6IFwiY3A5NDlcIixcbiAga29yZWFuOiBcImNwOTQ5XCIsXG4gIGtzYzU2MDExOTg3OiBcImNwOTQ5XCIsXG4gIGtzYzU2MDExOTg5OiBcImNwOTQ5XCIsXG4gIGtzYzU2MDE6IFwiY3A5NDlcIixcblxuICAvLyA9PSBCaWc1L1RhaXdhbi9Ib25nIEtvbmcgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFRoZXJlIGFyZSBsb3RzIG9mIHRhYmxlcyBmb3IgQmlnNSBhbmQgY3A5NTAuIFBsZWFzZSBzZWUgdGhlIGZvbGxvd2luZyBsaW5rcyBmb3IgaGlzdG9yeTpcbiAgLy8gaHR0cDovL21venR3Lm9yZy9kb2NzL2JpZzUvICBodHRwOi8vd3d3LmhhaWJsZS5kZS9icnVuby9jaGFyc2V0cy9jb252ZXJzaW9uLXRhYmxlcy9CaWc1Lmh0bWxcbiAgLy8gVmFyaWF0aW9ucywgaW4gcm91Z2hseSBudW1iZXIgb2YgZGVmaW5lZCBjaGFyczpcbiAgLy8gICogV2luZG93cyBDUCA5NTA6IE1pY3Jvc29mdCB2YXJpYW50IG9mIEJpZzUuIENhbm9uaWNhbDogaHR0cDovL3d3dy51bmljb2RlLm9yZy9QdWJsaWMvTUFQUElOR1MvVkVORE9SUy9NSUNTRlQvV0lORE9XUy9DUDk1MC5UWFRcbiAgLy8gICogV2luZG93cyBDUCA5NTE6IE1pY3Jvc29mdCB2YXJpYW50IG9mIEJpZzUtSEtTQ1MtMjAwMS4gU2VlbXMgdG8gYmUgbmV2ZXIgcHVibGljLiBodHRwOi8vbWUuYWJlbGNoZXVuZy5vcmcvYXJ0aWNsZXMvcmVzZWFyY2gvd2hhdC1pcy1jcDk1MS9cbiAgLy8gICogQmlnNS0yMDAzIChUYWl3YW4gc3RhbmRhcmQpIGFsbW9zdCBzdXBlcnNldCBvZiBjcDk1MC5cbiAgLy8gICogVW5pY29kZS1hdC1vbiAoVUFPKSAvIE1vemlsbGEgMS44LiBGYWxsaW5nIG91dCBvZiB1c2Ugb24gdGhlIFdlYi4gTm90IHN1cHBvcnRlZCBieSBvdGhlciBicm93c2Vycy5cbiAgLy8gICogQmlnNS1IS1NDUyAoLTIwMDEsIC0yMDA0LCAtMjAwOCkuIEhvbmcgS29uZyBzdGFuZGFyZC5cbiAgLy8gICAgbWFueSB1bmljb2RlIGNvZGUgcG9pbnRzIG1vdmVkIGZyb20gUFVBIHRvIFN1cHBsZW1lbnRhcnkgcGxhbmUgKFUrMlhYWFgpIG92ZXIgdGhlIHllYXJzLlxuICAvLyAgICBQbHVzLCBpdCBoYXMgNCBjb21iaW5pbmcgc2VxdWVuY2VzLlxuICAvLyAgICBTZWVtcyB0aGF0IE1vemlsbGEgcmVmdXNlZCB0byBzdXBwb3J0IGl0IGZvciAxMCB5cnMuIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE2MjQzMSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0zMTAyOTlcbiAgLy8gICAgYmVjYXVzZSBiaWc1LWhrc2NzIGlzIHRoZSBvbmx5IGVuY29kaW5nIHRvIGluY2x1ZGUgYXN0cmFsIGNoYXJhY3RlcnMgaW4gbm9uLWFsZ29yaXRobWljIHdheS5cbiAgLy8gICAgSW1wbGVtZW50YXRpb25zIGFyZSBub3QgY29uc2lzdGVudCB3aXRoaW4gYnJvd3NlcnM7IHNvbWV0aW1lcyBsYWJlbGVkIGFzIGp1c3QgYmlnNS5cbiAgLy8gICAgTVMgSW50ZXJuZXQgRXhwbG9yZXIgc3dpdGNoZXMgZnJvbSBiaWc1IHRvIGJpZzUtaGtzY3Mgd2hlbiBhIHBhdGNoIGFwcGxpZWQuXG4gIC8vICAgIEdyZWF0IGRpc2N1c3Npb24gJiByZWNhcCBvZiB3aGF0J3MgZ29pbmcgb24gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9OTEyNDcwI2MzMVxuICAvLyAgICBJbiB0aGUgZW5jb2RlciwgaXQgbWlnaHQgbWFrZSBzZW5zZSB0byBzdXBwb3J0IGVuY29kaW5nIG9sZCBQVUEgbWFwcGluZ3MgdG8gQmlnNSBieXRlcyBzZXEtcy5cbiAgLy8gICAgT2ZmaWNpYWwgc3BlYzogaHR0cDovL3d3dy5vZ2Npby5nb3YuaGsvZW4vYnVzaW5lc3MvdGVjaF9wcm9tb3Rpb24vY2NsaS90ZXJtcy9kb2MvMjAwM2NtcF8yMDA4LnR4dFxuICAvLyAgICAgICAgICAgICAgICAgICBodHRwOi8vd3d3Lm9nY2lvLmdvdi5oay90Yy9idXNpbmVzcy90ZWNoX3Byb21vdGlvbi9jY2xpL3Rlcm1zL2RvYy9oa3Njcy0yMDA4LWJpZzUtaXNvLnR4dFxuICAvL1xuICAvLyBDdXJyZW50IHVuZGVyc3RhbmRpbmcgb2YgaG93IHRvIGRlYWwgd2l0aCBCaWc1KC1IS1NDUykgaXMgaW4gdGhlIEVuY29kaW5nIFN0YW5kYXJkLCBodHRwOi8vZW5jb2Rpbmcuc3BlYy53aGF0d2cub3JnLyNiaWc1LWVuY29kZXJcbiAgLy8gVW5pY29kZSBtYXBwaW5nIChodHRwOi8vd3d3LnVuaWNvZGUub3JnL1B1YmxpYy9NQVBQSU5HUy9PQlNPTEVURS9FQVNUQVNJQS9PVEhFUi9CSUc1LlRYVCkgaXMgc2FpZCB0byBiZSB3cm9uZy5cblxuICB3aW5kb3dzOTUwOiBcImNwOTUwXCIsXG4gIG1zOTUwOiBcImNwOTUwXCIsXG4gIDk1MDogXCJjcDk1MFwiLFxuICBjcDk1MDoge1xuICAgIHR5cGU6IFwiX2RiY3NcIixcbiAgICB0YWJsZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVxdWlyZShcIi4vdGFibGVzL2NwOTUwLmpzb25cIikgfVxuICB9LFxuXG4gIC8vIEJpZzUgaGFzIG1hbnkgdmFyaWF0aW9ucyBhbmQgaXMgYW4gZXh0ZW5zaW9uIG9mIGNwOTUwLiBXZSB1c2UgRW5jb2RpbmcgU3RhbmRhcmQncyBhcyBhIGNvbnNlbnN1cy5cbiAgYmlnNTogXCJiaWc1aGtzY3NcIixcbiAgYmlnNWhrc2NzOiB7XG4gICAgdHlwZTogXCJfZGJjc1wiLFxuICAgIHRhYmxlOiBmdW5jdGlvbiAoKSB7IHJldHVybiByZXF1aXJlKFwiLi90YWJsZXMvY3A5NTAuanNvblwiKS5jb25jYXQocmVxdWlyZShcIi4vdGFibGVzL2JpZzUtYWRkZWQuanNvblwiKSkgfSxcbiAgICBlbmNvZGVTa2lwVmFsczogW1xuICAgICAgLy8gQWx0aG91Z2ggRW5jb2RpbmcgU3RhbmRhcmQgc2F5cyB3ZSBzaG91bGQgYXZvaWQgZW5jb2RpbmcgdG8gSEtTQ1MgYXJlYSAoU2VlIFN0ZXAgMSBvZlxuICAgICAgLy8gaHR0cHM6Ly9lbmNvZGluZy5zcGVjLndoYXR3Zy5vcmcvI2luZGV4LWJpZzUtcG9pbnRlciksIHdlIHN0aWxsIGRvIGl0IHRvIGluY3JlYXNlIGNvbXBhdGliaWxpdHkgd2l0aCBJQ1UuXG4gICAgICAvLyBCdXQgaWYgYSBzaW5nbGUgdW5pY29kZSBwb2ludCBjYW4gYmUgZW5jb2RlZCBib3RoIGFzIEhLU0NTIGFuZCByZWd1bGFyIEJpZzUsIHdlIHByZWZlciB0aGUgbGF0dGVyLlxuICAgICAgMHg4ZTY5LCAweDhlNmYsIDB4OGU3ZSwgMHg4ZWFiLCAweDhlYjQsIDB4OGVjZCwgMHg4ZWQwLCAweDhmNTcsIDB4OGY2OSwgMHg4ZjZlLCAweDhmY2IsIDB4OGZmZSxcbiAgICAgIDB4OTA2ZCwgMHg5MDdhLCAweDkwYzQsIDB4OTBkYywgMHg5MGYxLCAweDkxYmYsIDB4OTJhZiwgMHg5MmIwLCAweDkyYjEsIDB4OTJiMiwgMHg5MmQxLCAweDk0NDcsIDB4OTRjYSxcbiAgICAgIDB4OTVkOSwgMHg5NmZjLCAweDk5NzUsIDB4OWI3NiwgMHg5Yjc4LCAweDliN2IsIDB4OWJjNiwgMHg5YmRlLCAweDliZWMsIDB4OWJmNiwgMHg5YzQyLCAweDljNTMsIDB4OWM2MixcbiAgICAgIDB4OWM2OCwgMHg5YzZiLCAweDljNzcsIDB4OWNiYywgMHg5Y2JkLCAweDljZDAsIDB4OWQ1NywgMHg5ZDVhLCAweDlkYzQsIDB4OWRlZiwgMHg5ZGZiLCAweDllYTksIDB4OWVlZixcbiAgICAgIDB4OWVmZCwgMHg5ZjYwLCAweDlmY2IsIDB4YTA3NywgMHhhMGRjLCAweGEwZGYsIDB4OGZjYywgMHg5MmM4LCAweDk2NDQsIDB4OTZlZCxcblxuICAgICAgLy8gU3RlcCAyIG9mIGh0dHBzOi8vZW5jb2Rpbmcuc3BlYy53aGF0d2cub3JnLyNpbmRleC1iaWc1LXBvaW50ZXI6IFVzZSBsYXN0IHBvaW50ZXIgZm9yIFUrMjU1MCwgVSsyNTVFLCBVKzI1NjEsIFUrMjU2QSwgVSs1MzQxLCBvciBVKzUzNDVcbiAgICAgIDB4YTJhNCwgMHhhMmE1LCAweGEyYTcsIDB4YTJhNiwgMHhhMmNjLCAweGEyY2VcbiAgICBdXG4gIH0sXG5cbiAgY25iaWc1OiBcImJpZzVoa3Njc1wiLFxuICBjc2JpZzU6IFwiYmlnNWhrc2NzXCIsXG4gIHh4YmlnNTogXCJiaWc1aGtzY3NcIlxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/dbcs-data.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/index.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/mailparser/node_modules/iconv-lite/encodings/index.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar mergeModules = __webpack_require__(/*! ../lib/helpers/merge-exports */ \"(rsc)/../node_modules/mailparser/node_modules/iconv-lite/lib/helpers/merge-exports.js\")\n\n// Update this array if you add/rename/remove files in this directory.\n// We support Browserify by skipping automatic module discovery and requiring modules directly.\nvar modules = [\n  __webpack_require__(/*! ./internal */ \"(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/internal.js\"),\n  __webpack_require__(/*! ./utf32 */ \"(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/utf32.js\"),\n  __webpack_require__(/*! ./utf16 */ \"(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/utf16.js\"),\n  __webpack_require__(/*! ./utf7 */ \"(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/utf7.js\"),\n  __webpack_require__(/*! ./sbcs-codec */ \"(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/sbcs-codec.js\"),\n  __webpack_require__(/*! ./sbcs-data */ \"(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/sbcs-data.js\"),\n  __webpack_require__(/*! ./sbcs-data-generated */ \"(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/sbcs-data-generated.js\"),\n  __webpack_require__(/*! ./dbcs-codec */ \"(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/dbcs-codec.js\"),\n  __webpack_require__(/*! ./dbcs-data */ \"(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/dbcs-data.js\")\n]\n\n// Put all encoding/alias/codec definitions to single object and export it.\nfor (var i = 0; i < modules.length; i++) {\n  var module = modules[i]\n  mergeModules(exports, module)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL21haWxwYXJzZXIvbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvZW5jb2RpbmdzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLG1CQUFtQixtQkFBTyxDQUFDLDJIQUE4Qjs7QUFFekQ7QUFDQTtBQUNBO0FBQ0EsRUFBRSxtQkFBTyxDQUFDLGtHQUFZO0FBQ3RCLEVBQUUsbUJBQU8sQ0FBQyw0RkFBUztBQUNuQixFQUFFLG1CQUFPLENBQUMsNEZBQVM7QUFDbkIsRUFBRSxtQkFBTyxDQUFDLDBGQUFRO0FBQ2xCLEVBQUUsbUJBQU8sQ0FBQyxzR0FBYztBQUN4QixFQUFFLG1CQUFPLENBQUMsb0dBQWE7QUFDdkIsRUFBRSxtQkFBTyxDQUFDLHdIQUF1QjtBQUNqQyxFQUFFLG1CQUFPLENBQUMsc0dBQWM7QUFDeEIsRUFBRSxtQkFBTyxDQUFDLG9HQUFhO0FBQ3ZCOztBQUVBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xca2ZyeXRcXC5nZW1pbmlcXGFudGlncmF2aXR5XFxzY3JhdGNoXFxkcl9rYWxzX3ZpcnR1YWxfaG9zcGl0YWxcXG5vZGVfbW9kdWxlc1xcbWFpbHBhcnNlclxcbm9kZV9tb2R1bGVzXFxpY29udi1saXRlXFxlbmNvZGluZ3NcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiXG5cbnZhciBtZXJnZU1vZHVsZXMgPSByZXF1aXJlKFwiLi4vbGliL2hlbHBlcnMvbWVyZ2UtZXhwb3J0c1wiKVxuXG4vLyBVcGRhdGUgdGhpcyBhcnJheSBpZiB5b3UgYWRkL3JlbmFtZS9yZW1vdmUgZmlsZXMgaW4gdGhpcyBkaXJlY3RvcnkuXG4vLyBXZSBzdXBwb3J0IEJyb3dzZXJpZnkgYnkgc2tpcHBpbmcgYXV0b21hdGljIG1vZHVsZSBkaXNjb3ZlcnkgYW5kIHJlcXVpcmluZyBtb2R1bGVzIGRpcmVjdGx5LlxudmFyIG1vZHVsZXMgPSBbXG4gIHJlcXVpcmUoXCIuL2ludGVybmFsXCIpLFxuICByZXF1aXJlKFwiLi91dGYzMlwiKSxcbiAgcmVxdWlyZShcIi4vdXRmMTZcIiksXG4gIHJlcXVpcmUoXCIuL3V0ZjdcIiksXG4gIHJlcXVpcmUoXCIuL3NiY3MtY29kZWNcIiksXG4gIHJlcXVpcmUoXCIuL3NiY3MtZGF0YVwiKSxcbiAgcmVxdWlyZShcIi4vc2Jjcy1kYXRhLWdlbmVyYXRlZFwiKSxcbiAgcmVxdWlyZShcIi4vZGJjcy1jb2RlY1wiKSxcbiAgcmVxdWlyZShcIi4vZGJjcy1kYXRhXCIpXG5dXG5cbi8vIFB1dCBhbGwgZW5jb2RpbmcvYWxpYXMvY29kZWMgZGVmaW5pdGlvbnMgdG8gc2luZ2xlIG9iamVjdCBhbmQgZXhwb3J0IGl0LlxuZm9yICh2YXIgaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG4gIHZhciBtb2R1bGUgPSBtb2R1bGVzW2ldXG4gIG1lcmdlTW9kdWxlcyhleHBvcnRzLCBtb2R1bGUpXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/index.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/internal.js":
/*!********************************************************************************!*\
  !*** ../node_modules/mailparser/node_modules/iconv-lite/encodings/internal.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(rsc)/../node_modules/safer-buffer/safer.js\").Buffer)\n\n// Export Node.js internal encodings.\n\nmodule.exports = {\n  // Encodings\n  utf8: { type: \"_internal\", bomAware: true },\n  cesu8: { type: \"_internal\", bomAware: true },\n  unicode11utf8: \"utf8\",\n\n  ucs2: { type: \"_internal\", bomAware: true },\n  utf16le: \"ucs2\",\n\n  binary: { type: \"_internal\" },\n  base64: { type: \"_internal\" },\n  hex: { type: \"_internal\" },\n\n  // Codec.\n  _internal: InternalCodec\n}\n\n// ------------------------------------------------------------------------------\n\nfunction InternalCodec (codecOptions, iconv) {\n  this.enc = codecOptions.encodingName\n  this.bomAware = codecOptions.bomAware\n\n  if (this.enc === \"base64\") { this.encoder = InternalEncoderBase64 } else if (this.enc === \"utf8\") { this.encoder = InternalEncoderUtf8 } else if (this.enc === \"cesu8\") {\n    this.enc = \"utf8\" // Use utf8 for decoding.\n    this.encoder = InternalEncoderCesu8\n\n    // Add decoder for versions of Node not supporting CESU-8\n    if (Buffer.from(\"eda0bdedb2a9\", \"hex\").toString() !== \"\") {\n      this.decoder = InternalDecoderCesu8\n      this.defaultCharUnicode = iconv.defaultCharUnicode\n    }\n  }\n}\n\nInternalCodec.prototype.encoder = InternalEncoder\nInternalCodec.prototype.decoder = InternalDecoder\n\n// ------------------------------------------------------------------------------\n\n// We use node.js internal decoder. Its signature is the same as ours.\nvar StringDecoder = (__webpack_require__(/*! string_decoder */ \"string_decoder\").StringDecoder)\n\nfunction InternalDecoder (options, codec) {\n  this.decoder = new StringDecoder(codec.enc)\n}\n\nInternalDecoder.prototype.write = function (buf) {\n  if (!Buffer.isBuffer(buf)) {\n    buf = Buffer.from(buf)\n  }\n\n  return this.decoder.write(buf)\n}\n\nInternalDecoder.prototype.end = function () {\n  return this.decoder.end()\n}\n\n// ------------------------------------------------------------------------------\n// Encoder is mostly trivial\n\nfunction InternalEncoder (options, codec) {\n  this.enc = codec.enc\n}\n\nInternalEncoder.prototype.write = function (str) {\n  return Buffer.from(str, this.enc)\n}\n\nInternalEncoder.prototype.end = function () {\n}\n\n// ------------------------------------------------------------------------------\n// Except base64 encoder, which must keep its state.\n\nfunction InternalEncoderBase64 (options, codec) {\n  this.prevStr = \"\"\n}\n\nInternalEncoderBase64.prototype.write = function (str) {\n  str = this.prevStr + str\n  var completeQuads = str.length - (str.length % 4)\n  this.prevStr = str.slice(completeQuads)\n  str = str.slice(0, completeQuads)\n\n  return Buffer.from(str, \"base64\")\n}\n\nInternalEncoderBase64.prototype.end = function () {\n  return Buffer.from(this.prevStr, \"base64\")\n}\n\n// ------------------------------------------------------------------------------\n// CESU-8 encoder is also special.\n\nfunction InternalEncoderCesu8 (options, codec) {\n}\n\nInternalEncoderCesu8.prototype.write = function (str) {\n  var buf = Buffer.alloc(str.length * 3); var bufIdx = 0\n  for (var i = 0; i < str.length; i++) {\n    var charCode = str.charCodeAt(i)\n    // Naive implementation, but it works because CESU-8 is especially easy\n    // to convert from UTF-16 (which all JS strings are encoded in).\n    if (charCode < 0x80) { buf[bufIdx++] = charCode } else if (charCode < 0x800) {\n      buf[bufIdx++] = 0xC0 + (charCode >>> 6)\n      buf[bufIdx++] = 0x80 + (charCode & 0x3f)\n    } else { // charCode will always be < 0x10000 in javascript.\n      buf[bufIdx++] = 0xE0 + (charCode >>> 12)\n      buf[bufIdx++] = 0x80 + ((charCode >>> 6) & 0x3f)\n      buf[bufIdx++] = 0x80 + (charCode & 0x3f)\n    }\n  }\n  return buf.slice(0, bufIdx)\n}\n\nInternalEncoderCesu8.prototype.end = function () {\n}\n\n// ------------------------------------------------------------------------------\n// CESU-8 decoder is not implemented in Node v4.0+\n\nfunction InternalDecoderCesu8 (options, codec) {\n  this.acc = 0\n  this.contBytes = 0\n  this.accBytes = 0\n  this.defaultCharUnicode = codec.defaultCharUnicode\n}\n\nInternalDecoderCesu8.prototype.write = function (buf) {\n  var acc = this.acc; var contBytes = this.contBytes; var accBytes = this.accBytes\n  var res = \"\"\n  for (var i = 0; i < buf.length; i++) {\n    var curByte = buf[i]\n    if ((curByte & 0xC0) !== 0x80) { // Leading byte\n      if (contBytes > 0) { // Previous code is invalid\n        res += this.defaultCharUnicode\n        contBytes = 0\n      }\n\n      if (curByte < 0x80) { // Single-byte code\n        res += String.fromCharCode(curByte)\n      } else if (curByte < 0xE0) { // Two-byte code\n        acc = curByte & 0x1F\n        contBytes = 1; accBytes = 1\n      } else if (curByte < 0xF0) { // Three-byte code\n        acc = curByte & 0x0F\n        contBytes = 2; accBytes = 1\n      } else { // Four or more are not supported for CESU-8.\n        res += this.defaultCharUnicode\n      }\n    } else { // Continuation byte\n      if (contBytes > 0) { // We're waiting for it.\n        acc = (acc << 6) | (curByte & 0x3f)\n        contBytes--; accBytes++\n        if (contBytes === 0) {\n          // Check for overlong encoding, but support Modified UTF-8 (encoding NULL as C0 80)\n          if (accBytes === 2 && acc < 0x80 && acc > 0) {\n            res += this.defaultCharUnicode\n          } else if (accBytes === 3 && acc < 0x800) {\n            res += this.defaultCharUnicode\n          } else {\n            // Actually add character.\n            res += String.fromCharCode(acc)\n          }\n        }\n      } else { // Unexpected continuation byte\n        res += this.defaultCharUnicode\n      }\n    }\n  }\n  this.acc = acc; this.contBytes = contBytes; this.accBytes = accBytes\n  return res\n}\n\nInternalDecoderCesu8.prototype.end = function () {\n  var res = 0\n  if (this.contBytes > 0) { res += this.defaultCharUnicode }\n  return res\n}\n\n// ------------------------------------------------------------------------------\n// check the chunk boundaries for surrogate pair\n\nfunction InternalEncoderUtf8 (options, codec) {\n  this.highSurrogate = \"\"\n}\n\nInternalEncoderUtf8.prototype.write = function (str) {\n  if (this.highSurrogate) {\n    str = this.highSurrogate + str\n    this.highSurrogate = \"\"\n  }\n\n  if (str.length > 0) {\n    var charCode = str.charCodeAt(str.length - 1)\n    if (charCode >= 0xd800 && charCode < 0xdc00) {\n      this.highSurrogate = str[str.length - 1]\n      str = str.slice(0, str.length - 1)\n    }\n  }\n\n  return Buffer.from(str, this.enc)\n}\n\nInternalEncoderUtf8.prototype.end = function () {\n  if (this.highSurrogate) {\n    var str = this.highSurrogate\n    this.highSurrogate = \"\"\n    return Buffer.from(str, this.enc)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL21haWxwYXJzZXIvbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvZW5jb2RpbmdzL2ludGVybmFsLmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1osYUFBYSwrRkFBOEI7O0FBRTNDOztBQUVBO0FBQ0E7QUFDQSxVQUFVLG1DQUFtQztBQUM3QyxXQUFXLG1DQUFtQztBQUM5Qzs7QUFFQSxVQUFVLG1DQUFtQztBQUM3Qzs7QUFFQSxZQUFZLG1CQUFtQjtBQUMvQixZQUFZLG1CQUFtQjtBQUMvQixTQUFTLG1CQUFtQjs7QUFFNUI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsdUNBQXVDLGdDQUFnQyxxQ0FBcUM7QUFDM0k7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0JBQW9CLDJFQUF1Qzs7QUFFM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDO0FBQzFDLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJCQUEyQjtBQUN0RDtBQUNBO0FBQ0EsTUFBTSxPQUFPO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixnQ0FBZ0M7QUFDdEQ7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0EscUNBQXFDO0FBQ3JDLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0EsUUFBUSwyQkFBMkI7QUFDbkM7QUFDQSx1QkFBdUI7QUFDdkIsUUFBUSwyQkFBMkI7QUFDbkM7QUFDQSx1QkFBdUI7QUFDdkIsUUFBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBLE1BQU0sT0FBTztBQUNiLDJCQUEyQjtBQUMzQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRCQUE0QjtBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xca2ZyeXRcXC5nZW1pbmlcXGFudGlncmF2aXR5XFxzY3JhdGNoXFxkcl9rYWxzX3ZpcnR1YWxfaG9zcGl0YWxcXG5vZGVfbW9kdWxlc1xcbWFpbHBhcnNlclxcbm9kZV9tb2R1bGVzXFxpY29udi1saXRlXFxlbmNvZGluZ3NcXGludGVybmFsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiXG52YXIgQnVmZmVyID0gcmVxdWlyZShcInNhZmVyLWJ1ZmZlclwiKS5CdWZmZXJcblxuLy8gRXhwb3J0IE5vZGUuanMgaW50ZXJuYWwgZW5jb2RpbmdzLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gRW5jb2RpbmdzXG4gIHV0Zjg6IHsgdHlwZTogXCJfaW50ZXJuYWxcIiwgYm9tQXdhcmU6IHRydWUgfSxcbiAgY2VzdTg6IHsgdHlwZTogXCJfaW50ZXJuYWxcIiwgYm9tQXdhcmU6IHRydWUgfSxcbiAgdW5pY29kZTExdXRmODogXCJ1dGY4XCIsXG5cbiAgdWNzMjogeyB0eXBlOiBcIl9pbnRlcm5hbFwiLCBib21Bd2FyZTogdHJ1ZSB9LFxuICB1dGYxNmxlOiBcInVjczJcIixcblxuICBiaW5hcnk6IHsgdHlwZTogXCJfaW50ZXJuYWxcIiB9LFxuICBiYXNlNjQ6IHsgdHlwZTogXCJfaW50ZXJuYWxcIiB9LFxuICBoZXg6IHsgdHlwZTogXCJfaW50ZXJuYWxcIiB9LFxuXG4gIC8vIENvZGVjLlxuICBfaW50ZXJuYWw6IEludGVybmFsQ29kZWNcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIEludGVybmFsQ29kZWMgKGNvZGVjT3B0aW9ucywgaWNvbnYpIHtcbiAgdGhpcy5lbmMgPSBjb2RlY09wdGlvbnMuZW5jb2RpbmdOYW1lXG4gIHRoaXMuYm9tQXdhcmUgPSBjb2RlY09wdGlvbnMuYm9tQXdhcmVcblxuICBpZiAodGhpcy5lbmMgPT09IFwiYmFzZTY0XCIpIHsgdGhpcy5lbmNvZGVyID0gSW50ZXJuYWxFbmNvZGVyQmFzZTY0IH0gZWxzZSBpZiAodGhpcy5lbmMgPT09IFwidXRmOFwiKSB7IHRoaXMuZW5jb2RlciA9IEludGVybmFsRW5jb2RlclV0ZjggfSBlbHNlIGlmICh0aGlzLmVuYyA9PT0gXCJjZXN1OFwiKSB7XG4gICAgdGhpcy5lbmMgPSBcInV0ZjhcIiAvLyBVc2UgdXRmOCBmb3IgZGVjb2RpbmcuXG4gICAgdGhpcy5lbmNvZGVyID0gSW50ZXJuYWxFbmNvZGVyQ2VzdThcblxuICAgIC8vIEFkZCBkZWNvZGVyIGZvciB2ZXJzaW9ucyBvZiBOb2RlIG5vdCBzdXBwb3J0aW5nIENFU1UtOFxuICAgIGlmIChCdWZmZXIuZnJvbShcImVkYTBiZGVkYjJhOVwiLCBcImhleFwiKS50b1N0cmluZygpICE9PSBcIvCfkqlcIikge1xuICAgICAgdGhpcy5kZWNvZGVyID0gSW50ZXJuYWxEZWNvZGVyQ2VzdThcbiAgICAgIHRoaXMuZGVmYXVsdENoYXJVbmljb2RlID0gaWNvbnYuZGVmYXVsdENoYXJVbmljb2RlXG4gICAgfVxuICB9XG59XG5cbkludGVybmFsQ29kZWMucHJvdG90eXBlLmVuY29kZXIgPSBJbnRlcm5hbEVuY29kZXJcbkludGVybmFsQ29kZWMucHJvdG90eXBlLmRlY29kZXIgPSBJbnRlcm5hbERlY29kZXJcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIFdlIHVzZSBub2RlLmpzIGludGVybmFsIGRlY29kZXIuIEl0cyBzaWduYXR1cmUgaXMgdGhlIHNhbWUgYXMgb3Vycy5cbnZhciBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZShcInN0cmluZ19kZWNvZGVyXCIpLlN0cmluZ0RlY29kZXJcblxuZnVuY3Rpb24gSW50ZXJuYWxEZWNvZGVyIChvcHRpb25zLCBjb2RlYykge1xuICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2Rlcihjb2RlYy5lbmMpXG59XG5cbkludGVybmFsRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICBidWYgPSBCdWZmZXIuZnJvbShidWYpXG4gIH1cblxuICByZXR1cm4gdGhpcy5kZWNvZGVyLndyaXRlKGJ1Zilcbn1cblxuSW50ZXJuYWxEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmRlY29kZXIuZW5kKClcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFbmNvZGVyIGlzIG1vc3RseSB0cml2aWFsXG5cbmZ1bmN0aW9uIEludGVybmFsRW5jb2RlciAob3B0aW9ucywgY29kZWMpIHtcbiAgdGhpcy5lbmMgPSBjb2RlYy5lbmNcbn1cblxuSW50ZXJuYWxFbmNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHN0ciwgdGhpcy5lbmMpXG59XG5cbkludGVybmFsRW5jb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEV4Y2VwdCBiYXNlNjQgZW5jb2Rlciwgd2hpY2ggbXVzdCBrZWVwIGl0cyBzdGF0ZS5cblxuZnVuY3Rpb24gSW50ZXJuYWxFbmNvZGVyQmFzZTY0IChvcHRpb25zLCBjb2RlYykge1xuICB0aGlzLnByZXZTdHIgPSBcIlwiXG59XG5cbkludGVybmFsRW5jb2RlckJhc2U2NC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHN0ciA9IHRoaXMucHJldlN0ciArIHN0clxuICB2YXIgY29tcGxldGVRdWFkcyA9IHN0ci5sZW5ndGggLSAoc3RyLmxlbmd0aCAlIDQpXG4gIHRoaXMucHJldlN0ciA9IHN0ci5zbGljZShjb21wbGV0ZVF1YWRzKVxuICBzdHIgPSBzdHIuc2xpY2UoMCwgY29tcGxldGVRdWFkcylcblxuICByZXR1cm4gQnVmZmVyLmZyb20oc3RyLCBcImJhc2U2NFwiKVxufVxuXG5JbnRlcm5hbEVuY29kZXJCYXNlNjQucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHRoaXMucHJldlN0ciwgXCJiYXNlNjRcIilcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBDRVNVLTggZW5jb2RlciBpcyBhbHNvIHNwZWNpYWwuXG5cbmZ1bmN0aW9uIEludGVybmFsRW5jb2RlckNlc3U4IChvcHRpb25zLCBjb2RlYykge1xufVxuXG5JbnRlcm5hbEVuY29kZXJDZXN1OC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciBidWYgPSBCdWZmZXIuYWxsb2Moc3RyLmxlbmd0aCAqIDMpOyB2YXIgYnVmSWR4ID0gMFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgLy8gTmFpdmUgaW1wbGVtZW50YXRpb24sIGJ1dCBpdCB3b3JrcyBiZWNhdXNlIENFU1UtOCBpcyBlc3BlY2lhbGx5IGVhc3lcbiAgICAvLyB0byBjb252ZXJ0IGZyb20gVVRGLTE2ICh3aGljaCBhbGwgSlMgc3RyaW5ncyBhcmUgZW5jb2RlZCBpbikuXG4gICAgaWYgKGNoYXJDb2RlIDwgMHg4MCkgeyBidWZbYnVmSWR4KytdID0gY2hhckNvZGUgfSBlbHNlIGlmIChjaGFyQ29kZSA8IDB4ODAwKSB7XG4gICAgICBidWZbYnVmSWR4KytdID0gMHhDMCArIChjaGFyQ29kZSA+Pj4gNilcbiAgICAgIGJ1ZltidWZJZHgrK10gPSAweDgwICsgKGNoYXJDb2RlICYgMHgzZilcbiAgICB9IGVsc2UgeyAvLyBjaGFyQ29kZSB3aWxsIGFsd2F5cyBiZSA8IDB4MTAwMDAgaW4gamF2YXNjcmlwdC5cbiAgICAgIGJ1ZltidWZJZHgrK10gPSAweEUwICsgKGNoYXJDb2RlID4+PiAxMilcbiAgICAgIGJ1ZltidWZJZHgrK10gPSAweDgwICsgKChjaGFyQ29kZSA+Pj4gNikgJiAweDNmKVxuICAgICAgYnVmW2J1ZklkeCsrXSA9IDB4ODAgKyAoY2hhckNvZGUgJiAweDNmKVxuICAgIH1cbiAgfVxuICByZXR1cm4gYnVmLnNsaWNlKDAsIGJ1ZklkeClcbn1cblxuSW50ZXJuYWxFbmNvZGVyQ2VzdTgucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBDRVNVLTggZGVjb2RlciBpcyBub3QgaW1wbGVtZW50ZWQgaW4gTm9kZSB2NC4wK1xuXG5mdW5jdGlvbiBJbnRlcm5hbERlY29kZXJDZXN1OCAob3B0aW9ucywgY29kZWMpIHtcbiAgdGhpcy5hY2MgPSAwXG4gIHRoaXMuY29udEJ5dGVzID0gMFxuICB0aGlzLmFjY0J5dGVzID0gMFxuICB0aGlzLmRlZmF1bHRDaGFyVW5pY29kZSA9IGNvZGVjLmRlZmF1bHRDaGFyVW5pY29kZVxufVxuXG5JbnRlcm5hbERlY29kZXJDZXN1OC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIHZhciBhY2MgPSB0aGlzLmFjYzsgdmFyIGNvbnRCeXRlcyA9IHRoaXMuY29udEJ5dGVzOyB2YXIgYWNjQnl0ZXMgPSB0aGlzLmFjY0J5dGVzXG4gIHZhciByZXMgPSBcIlwiXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGN1ckJ5dGUgPSBidWZbaV1cbiAgICBpZiAoKGN1ckJ5dGUgJiAweEMwKSAhPT0gMHg4MCkgeyAvLyBMZWFkaW5nIGJ5dGVcbiAgICAgIGlmIChjb250Qnl0ZXMgPiAwKSB7IC8vIFByZXZpb3VzIGNvZGUgaXMgaW52YWxpZFxuICAgICAgICByZXMgKz0gdGhpcy5kZWZhdWx0Q2hhclVuaWNvZGVcbiAgICAgICAgY29udEJ5dGVzID0gMFxuICAgICAgfVxuXG4gICAgICBpZiAoY3VyQnl0ZSA8IDB4ODApIHsgLy8gU2luZ2xlLWJ5dGUgY29kZVxuICAgICAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjdXJCeXRlKVxuICAgICAgfSBlbHNlIGlmIChjdXJCeXRlIDwgMHhFMCkgeyAvLyBUd28tYnl0ZSBjb2RlXG4gICAgICAgIGFjYyA9IGN1ckJ5dGUgJiAweDFGXG4gICAgICAgIGNvbnRCeXRlcyA9IDE7IGFjY0J5dGVzID0gMVxuICAgICAgfSBlbHNlIGlmIChjdXJCeXRlIDwgMHhGMCkgeyAvLyBUaHJlZS1ieXRlIGNvZGVcbiAgICAgICAgYWNjID0gY3VyQnl0ZSAmIDB4MEZcbiAgICAgICAgY29udEJ5dGVzID0gMjsgYWNjQnl0ZXMgPSAxXG4gICAgICB9IGVsc2UgeyAvLyBGb3VyIG9yIG1vcmUgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIENFU1UtOC5cbiAgICAgICAgcmVzICs9IHRoaXMuZGVmYXVsdENoYXJVbmljb2RlXG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gQ29udGludWF0aW9uIGJ5dGVcbiAgICAgIGlmIChjb250Qnl0ZXMgPiAwKSB7IC8vIFdlJ3JlIHdhaXRpbmcgZm9yIGl0LlxuICAgICAgICBhY2MgPSAoYWNjIDw8IDYpIHwgKGN1ckJ5dGUgJiAweDNmKVxuICAgICAgICBjb250Qnl0ZXMtLTsgYWNjQnl0ZXMrK1xuICAgICAgICBpZiAoY29udEJ5dGVzID09PSAwKSB7XG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIG92ZXJsb25nIGVuY29kaW5nLCBidXQgc3VwcG9ydCBNb2RpZmllZCBVVEYtOCAoZW5jb2RpbmcgTlVMTCBhcyBDMCA4MClcbiAgICAgICAgICBpZiAoYWNjQnl0ZXMgPT09IDIgJiYgYWNjIDwgMHg4MCAmJiBhY2MgPiAwKSB7XG4gICAgICAgICAgICByZXMgKz0gdGhpcy5kZWZhdWx0Q2hhclVuaWNvZGVcbiAgICAgICAgICB9IGVsc2UgaWYgKGFjY0J5dGVzID09PSAzICYmIGFjYyA8IDB4ODAwKSB7XG4gICAgICAgICAgICByZXMgKz0gdGhpcy5kZWZhdWx0Q2hhclVuaWNvZGVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQWN0dWFsbHkgYWRkIGNoYXJhY3Rlci5cbiAgICAgICAgICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGFjYylcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7IC8vIFVuZXhwZWN0ZWQgY29udGludWF0aW9uIGJ5dGVcbiAgICAgICAgcmVzICs9IHRoaXMuZGVmYXVsdENoYXJVbmljb2RlXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRoaXMuYWNjID0gYWNjOyB0aGlzLmNvbnRCeXRlcyA9IGNvbnRCeXRlczsgdGhpcy5hY2NCeXRlcyA9IGFjY0J5dGVzXG4gIHJldHVybiByZXNcbn1cblxuSW50ZXJuYWxEZWNvZGVyQ2VzdTgucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlcyA9IDBcbiAgaWYgKHRoaXMuY29udEJ5dGVzID4gMCkgeyByZXMgKz0gdGhpcy5kZWZhdWx0Q2hhclVuaWNvZGUgfVxuICByZXR1cm4gcmVzXG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gY2hlY2sgdGhlIGNodW5rIGJvdW5kYXJpZXMgZm9yIHN1cnJvZ2F0ZSBwYWlyXG5cbmZ1bmN0aW9uIEludGVybmFsRW5jb2RlclV0ZjggKG9wdGlvbnMsIGNvZGVjKSB7XG4gIHRoaXMuaGlnaFN1cnJvZ2F0ZSA9IFwiXCJcbn1cblxuSW50ZXJuYWxFbmNvZGVyVXRmOC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIGlmICh0aGlzLmhpZ2hTdXJyb2dhdGUpIHtcbiAgICBzdHIgPSB0aGlzLmhpZ2hTdXJyb2dhdGUgKyBzdHJcbiAgICB0aGlzLmhpZ2hTdXJyb2dhdGUgPSBcIlwiXG4gIH1cblxuICBpZiAoc3RyLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgY2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChzdHIubGVuZ3RoIC0gMSlcbiAgICBpZiAoY2hhckNvZGUgPj0gMHhkODAwICYmIGNoYXJDb2RlIDwgMHhkYzAwKSB7XG4gICAgICB0aGlzLmhpZ2hTdXJyb2dhdGUgPSBzdHJbc3RyLmxlbmd0aCAtIDFdXG4gICAgICBzdHIgPSBzdHIuc2xpY2UoMCwgc3RyLmxlbmd0aCAtIDEpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHN0ciwgdGhpcy5lbmMpXG59XG5cbkludGVybmFsRW5jb2RlclV0ZjgucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuaGlnaFN1cnJvZ2F0ZSkge1xuICAgIHZhciBzdHIgPSB0aGlzLmhpZ2hTdXJyb2dhdGVcbiAgICB0aGlzLmhpZ2hTdXJyb2dhdGUgPSBcIlwiXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHN0ciwgdGhpcy5lbmMpXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/internal.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/sbcs-codec.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/mailparser/node_modules/iconv-lite/encodings/sbcs-codec.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(rsc)/../node_modules/safer-buffer/safer.js\").Buffer)\n\n// Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that\n// correspond to encoded bytes (if 128 - then lower half is ASCII).\n\nexports._sbcs = SBCSCodec\nfunction SBCSCodec (codecOptions, iconv) {\n  if (!codecOptions) {\n    throw new Error(\"SBCS codec is called without the data.\")\n  }\n\n  // Prepare char buffer for decoding.\n  if (!codecOptions.chars || (codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256)) {\n    throw new Error(\"Encoding '\" + codecOptions.type + \"' has incorrect 'chars' (must be of len 128 or 256)\")\n  }\n\n  if (codecOptions.chars.length === 128) {\n    var asciiString = \"\"\n    for (var i = 0; i < 128; i++) {\n      asciiString += String.fromCharCode(i)\n    }\n    codecOptions.chars = asciiString + codecOptions.chars\n  }\n\n  this.decodeBuf = Buffer.from(codecOptions.chars, \"ucs2\")\n\n  // Encoding buffer.\n  var encodeBuf = Buffer.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0))\n\n  for (var i = 0; i < codecOptions.chars.length; i++) {\n    encodeBuf[codecOptions.chars.charCodeAt(i)] = i\n  }\n\n  this.encodeBuf = encodeBuf\n}\n\nSBCSCodec.prototype.encoder = SBCSEncoder\nSBCSCodec.prototype.decoder = SBCSDecoder\n\nfunction SBCSEncoder (options, codec) {\n  this.encodeBuf = codec.encodeBuf\n}\n\nSBCSEncoder.prototype.write = function (str) {\n  var buf = Buffer.alloc(str.length)\n  for (var i = 0; i < str.length; i++) {\n    buf[i] = this.encodeBuf[str.charCodeAt(i)]\n  }\n\n  return buf\n}\n\nSBCSEncoder.prototype.end = function () {\n}\n\nfunction SBCSDecoder (options, codec) {\n  this.decodeBuf = codec.decodeBuf\n}\n\nSBCSDecoder.prototype.write = function (buf) {\n  // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.\n  var decodeBuf = this.decodeBuf\n  var newBuf = Buffer.alloc(buf.length * 2)\n  var idx1 = 0; var idx2 = 0\n  for (var i = 0; i < buf.length; i++) {\n    idx1 = buf[i] * 2; idx2 = i * 2\n    newBuf[idx2] = decodeBuf[idx1]\n    newBuf[idx2 + 1] = decodeBuf[idx1 + 1]\n  }\n  return newBuf.toString(\"ucs2\")\n}\n\nSBCSDecoder.prototype.end = function () {\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL21haWxwYXJzZXIvbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvZW5jb2RpbmdzL3NiY3MtY29kZWMuanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWixhQUFhLCtGQUE4Qjs7QUFFM0M7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLCtCQUErQjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGtCQUFrQixnQkFBZ0I7QUFDbEMsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxrZnJ5dFxcLmdlbWluaVxcYW50aWdyYXZpdHlcXHNjcmF0Y2hcXGRyX2thbHNfdmlydHVhbF9ob3NwaXRhbFxcbm9kZV9tb2R1bGVzXFxtYWlscGFyc2VyXFxub2RlX21vZHVsZXNcXGljb252LWxpdGVcXGVuY29kaW5nc1xcc2Jjcy1jb2RlYy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoXCJzYWZlci1idWZmZXJcIikuQnVmZmVyXG5cbi8vIFNpbmdsZS1ieXRlIGNvZGVjLiBOZWVkcyBhICdjaGFycycgc3RyaW5nIHBhcmFtZXRlciB0aGF0IGNvbnRhaW5zIDI1NiBvciAxMjggY2hhcnMgdGhhdFxuLy8gY29ycmVzcG9uZCB0byBlbmNvZGVkIGJ5dGVzIChpZiAxMjggLSB0aGVuIGxvd2VyIGhhbGYgaXMgQVNDSUkpLlxuXG5leHBvcnRzLl9zYmNzID0gU0JDU0NvZGVjXG5mdW5jdGlvbiBTQkNTQ29kZWMgKGNvZGVjT3B0aW9ucywgaWNvbnYpIHtcbiAgaWYgKCFjb2RlY09wdGlvbnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTQkNTIGNvZGVjIGlzIGNhbGxlZCB3aXRob3V0IHRoZSBkYXRhLlwiKVxuICB9XG5cbiAgLy8gUHJlcGFyZSBjaGFyIGJ1ZmZlciBmb3IgZGVjb2RpbmcuXG4gIGlmICghY29kZWNPcHRpb25zLmNoYXJzIHx8IChjb2RlY09wdGlvbnMuY2hhcnMubGVuZ3RoICE9PSAxMjggJiYgY29kZWNPcHRpb25zLmNoYXJzLmxlbmd0aCAhPT0gMjU2KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkVuY29kaW5nICdcIiArIGNvZGVjT3B0aW9ucy50eXBlICsgXCInIGhhcyBpbmNvcnJlY3QgJ2NoYXJzJyAobXVzdCBiZSBvZiBsZW4gMTI4IG9yIDI1NilcIilcbiAgfVxuXG4gIGlmIChjb2RlY09wdGlvbnMuY2hhcnMubGVuZ3RoID09PSAxMjgpIHtcbiAgICB2YXIgYXNjaWlTdHJpbmcgPSBcIlwiXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMjg7IGkrKykge1xuICAgICAgYXNjaWlTdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShpKVxuICAgIH1cbiAgICBjb2RlY09wdGlvbnMuY2hhcnMgPSBhc2NpaVN0cmluZyArIGNvZGVjT3B0aW9ucy5jaGFyc1xuICB9XG5cbiAgdGhpcy5kZWNvZGVCdWYgPSBCdWZmZXIuZnJvbShjb2RlY09wdGlvbnMuY2hhcnMsIFwidWNzMlwiKVxuXG4gIC8vIEVuY29kaW5nIGJ1ZmZlci5cbiAgdmFyIGVuY29kZUJ1ZiA9IEJ1ZmZlci5hbGxvYyg2NTUzNiwgaWNvbnYuZGVmYXVsdENoYXJTaW5nbGVCeXRlLmNoYXJDb2RlQXQoMCkpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2RlY09wdGlvbnMuY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICBlbmNvZGVCdWZbY29kZWNPcHRpb25zLmNoYXJzLmNoYXJDb2RlQXQoaSldID0gaVxuICB9XG5cbiAgdGhpcy5lbmNvZGVCdWYgPSBlbmNvZGVCdWZcbn1cblxuU0JDU0NvZGVjLnByb3RvdHlwZS5lbmNvZGVyID0gU0JDU0VuY29kZXJcblNCQ1NDb2RlYy5wcm90b3R5cGUuZGVjb2RlciA9IFNCQ1NEZWNvZGVyXG5cbmZ1bmN0aW9uIFNCQ1NFbmNvZGVyIChvcHRpb25zLCBjb2RlYykge1xuICB0aGlzLmVuY29kZUJ1ZiA9IGNvZGVjLmVuY29kZUJ1ZlxufVxuXG5TQkNTRW5jb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciBidWYgPSBCdWZmZXIuYWxsb2Moc3RyLmxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBidWZbaV0gPSB0aGlzLmVuY29kZUJ1ZltzdHIuY2hhckNvZGVBdChpKV1cbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuU0JDU0VuY29kZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcbn1cblxuZnVuY3Rpb24gU0JDU0RlY29kZXIgKG9wdGlvbnMsIGNvZGVjKSB7XG4gIHRoaXMuZGVjb2RlQnVmID0gY29kZWMuZGVjb2RlQnVmXG59XG5cblNCQ1NEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgLy8gU3RyaW5ncyBhcmUgaW1tdXRhYmxlIGluIEpTIC0+IHdlIHVzZSB1Y3MyIGJ1ZmZlciB0byBzcGVlZCB1cCBjb21wdXRhdGlvbnMuXG4gIHZhciBkZWNvZGVCdWYgPSB0aGlzLmRlY29kZUJ1ZlxuICB2YXIgbmV3QnVmID0gQnVmZmVyLmFsbG9jKGJ1Zi5sZW5ndGggKiAyKVxuICB2YXIgaWR4MSA9IDA7IHZhciBpZHgyID0gMFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkrKykge1xuICAgIGlkeDEgPSBidWZbaV0gKiAyOyBpZHgyID0gaSAqIDJcbiAgICBuZXdCdWZbaWR4Ml0gPSBkZWNvZGVCdWZbaWR4MV1cbiAgICBuZXdCdWZbaWR4MiArIDFdID0gZGVjb2RlQnVmW2lkeDEgKyAxXVxuICB9XG4gIHJldHVybiBuZXdCdWYudG9TdHJpbmcoXCJ1Y3MyXCIpXG59XG5cblNCQ1NEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoKSB7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/sbcs-codec.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/sbcs-data-generated.js":
/*!*******************************************************************************************!*\
  !*** ../node_modules/mailparser/node_modules/iconv-lite/encodings/sbcs-data-generated.js ***!
  \*******************************************************************************************/
/***/ ((module) => {

eval("\n\n// Generated data for sbcs codec. Don't edit manually. Regenerate using generation/gen-sbcs.js script.\nmodule.exports = {\n  \"437\": \"cp437\",\n  \"737\": \"cp737\",\n  \"775\": \"cp775\",\n  \"850\": \"cp850\",\n  \"852\": \"cp852\",\n  \"855\": \"cp855\",\n  \"856\": \"cp856\",\n  \"857\": \"cp857\",\n  \"858\": \"cp858\",\n  \"860\": \"cp860\",\n  \"861\": \"cp861\",\n  \"862\": \"cp862\",\n  \"863\": \"cp863\",\n  \"864\": \"cp864\",\n  \"865\": \"cp865\",\n  \"866\": \"cp866\",\n  \"869\": \"cp869\",\n  \"874\": \"windows874\",\n  \"922\": \"cp922\",\n  \"1046\": \"cp1046\",\n  \"1124\": \"cp1124\",\n  \"1125\": \"cp1125\",\n  \"1129\": \"cp1129\",\n  \"1133\": \"cp1133\",\n  \"1161\": \"cp1161\",\n  \"1162\": \"cp1162\",\n  \"1163\": \"cp1163\",\n  \"1250\": \"windows1250\",\n  \"1251\": \"windows1251\",\n  \"1252\": \"windows1252\",\n  \"1253\": \"windows1253\",\n  \"1254\": \"windows1254\",\n  \"1255\": \"windows1255\",\n  \"1256\": \"windows1256\",\n  \"1257\": \"windows1257\",\n  \"1258\": \"windows1258\",\n  \"28591\": \"iso88591\",\n  \"28592\": \"iso88592\",\n  \"28593\": \"iso88593\",\n  \"28594\": \"iso88594\",\n  \"28595\": \"iso88595\",\n  \"28596\": \"iso88596\",\n  \"28597\": \"iso88597\",\n  \"28598\": \"iso88598\",\n  \"28599\": \"iso88599\",\n  \"28600\": \"iso885910\",\n  \"28601\": \"iso885911\",\n  \"28603\": \"iso885913\",\n  \"28604\": \"iso885914\",\n  \"28605\": \"iso885915\",\n  \"28606\": \"iso885916\",\n  \"windows874\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"win874\": \"windows874\",\n  \"cp874\": \"windows874\",\n  \"windows1250\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"win1250\": \"windows1250\",\n  \"cp1250\": \"windows1250\",\n  \"windows1251\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"win1251\": \"windows1251\",\n  \"cp1251\": \"windows1251\",\n  \"windows1252\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"win1252\": \"windows1252\",\n  \"cp1252\": \"windows1252\",\n  \"windows1253\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"win1253\": \"windows1253\",\n  \"cp1253\": \"windows1253\",\n  \"windows1254\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"win1254\": \"windows1254\",\n  \"cp1254\": \"windows1254\",\n  \"windows1255\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"win1255\": \"windows1255\",\n  \"cp1255\": \"windows1255\",\n  \"windows1256\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"win1256\": \"windows1256\",\n  \"cp1256\": \"windows1256\",\n  \"windows1257\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"win1257\": \"windows1257\",\n  \"cp1257\": \"windows1257\",\n  \"windows1258\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"win1258\": \"windows1258\",\n  \"cp1258\": \"windows1258\",\n  \"iso88591\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"cp28591\": \"iso88591\",\n  \"iso88592\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"cp28592\": \"iso88592\",\n  \"iso88593\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"cp28593\": \"iso88593\",\n  \"iso88594\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"cp28594\": \"iso88594\",\n  \"iso88595\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"cp28595\": \"iso88595\",\n  \"iso88596\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"cp28596\": \"iso88596\",\n  \"iso88597\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"cp28597\": \"iso88597\",\n  \"iso88598\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"cp28598\": \"iso88598\",\n  \"iso88599\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"cp28599\": \"iso88599\",\n  \"iso885910\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"cp28600\": \"iso885910\",\n  \"iso885911\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"cp28601\": \"iso885911\",\n  \"iso885913\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"cp28603\": \"iso885913\",\n  \"iso885914\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"cp28604\": \"iso885914\",\n  \"iso885915\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"cp28605\": \"iso885915\",\n  \"iso885916\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"cp28606\": \"iso885916\",\n  \"cp437\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm437\": \"cp437\",\n  \"csibm437\": \"cp437\",\n  \"cp737\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm737\": \"cp737\",\n  \"csibm737\": \"cp737\",\n  \"cp775\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm775\": \"cp775\",\n  \"csibm775\": \"cp775\",\n  \"cp850\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm850\": \"cp850\",\n  \"csibm850\": \"cp850\",\n  \"cp852\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm852\": \"cp852\",\n  \"csibm852\": \"cp852\",\n  \"cp855\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm855\": \"cp855\",\n  \"csibm855\": \"cp855\",\n  \"cp856\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm856\": \"cp856\",\n  \"csibm856\": \"cp856\",\n  \"cp857\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm857\": \"cp857\",\n  \"csibm857\": \"cp857\",\n  \"cp858\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm858\": \"cp858\",\n  \"csibm858\": \"cp858\",\n  \"cp860\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm860\": \"cp860\",\n  \"csibm860\": \"cp860\",\n  \"cp861\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm861\": \"cp861\",\n  \"csibm861\": \"cp861\",\n  \"cp862\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm862\": \"cp862\",\n  \"csibm862\": \"cp862\",\n  \"cp863\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm863\": \"cp863\",\n  \"csibm863\": \"cp863\",\n  \"cp864\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f !\\\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\"\n  },\n  \"ibm864\": \"cp864\",\n  \"csibm864\": \"cp864\",\n  \"cp865\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm865\": \"cp865\",\n  \"csibm865\": \"cp865\",\n  \"cp866\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm866\": \"cp866\",\n  \"csibm866\": \"cp866\",\n  \"cp869\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm869\": \"cp869\",\n  \"csibm869\": \"cp869\",\n  \"cp922\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm922\": \"cp922\",\n  \"csibm922\": \"cp922\",\n  \"cp1046\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm1046\": \"cp1046\",\n  \"csibm1046\": \"cp1046\",\n  \"cp1124\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm1124\": \"cp1124\",\n  \"csibm1124\": \"cp1124\",\n  \"cp1125\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm1125\": \"cp1125\",\n  \"csibm1125\": \"cp1125\",\n  \"cp1129\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm1129\": \"cp1129\",\n  \"csibm1129\": \"cp1129\",\n  \"cp1133\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm1133\": \"cp1133\",\n  \"csibm1133\": \"cp1133\",\n  \"cp1161\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm1161\": \"cp1161\",\n  \"csibm1161\": \"cp1161\",\n  \"cp1162\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm1162\": \"cp1162\",\n  \"csibm1162\": \"cp1162\",\n  \"cp1163\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm1163\": \"cp1163\",\n  \"csibm1163\": \"cp1163\",\n  \"maccroatian\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"maccyrillic\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"macgreek\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"maciceland\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"macroman\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"macromania\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"macthai\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"macturkish\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"macukraine\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"koi8r\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"koi8u\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"koi8ru\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"koi8t\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"armscii8\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \")(.,-\"\n  },\n  \"rk1048\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"tcvn\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\\u0000\\u0003\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\\u0010\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f !\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\"\n  },\n  \"georgianacademy\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"georgianps\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"pt154\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"viscii\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\\u0000\\u0001\\u0003\\u0004\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\\u0010\\u0011\\u0012\\u0013\\u0015\\u0016\\u0017\\u0018\\u001a\\u001b\\u001c\\u001d\\u001f !\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\"\n  },\n  \"iso646cn\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f !\\\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}\"\n  },\n  \"iso646jp\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f !\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}\"\n  },\n  \"hproman8\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"macintosh\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ascii\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"tis620\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL21haWxwYXJzZXIvbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvZW5jb2RpbmdzL3NiY3MtZGF0YS1nZW5lcmF0ZWQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdU5BQXVOLGlFQUFpRSxFQUFFO0FBQzFSLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDJKQUEySixpRUFBaUUsRUFBRTtBQUM5TixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHlMQUF5TCxpRUFBaUUsRUFBRTtBQUM1UCxHQUFHO0FBQ0g7QUFDQTtBQUNBLHVOQUF1TixpRUFBaUUsRUFBRTtBQUMxUixHQUFHO0FBQ0g7QUFDQTtBQUNBLHVOQUF1TixnRUFBZ0UsRUFBRTtBQUN6UixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxrZnJ5dFxcLmdlbWluaVxcYW50aWdyYXZpdHlcXHNjcmF0Y2hcXGRyX2thbHNfdmlydHVhbF9ob3NwaXRhbFxcbm9kZV9tb2R1bGVzXFxtYWlscGFyc2VyXFxub2RlX21vZHVsZXNcXGljb252LWxpdGVcXGVuY29kaW5nc1xcc2Jjcy1kYXRhLWdlbmVyYXRlZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLy8gR2VuZXJhdGVkIGRhdGEgZm9yIHNiY3MgY29kZWMuIERvbid0IGVkaXQgbWFudWFsbHkuIFJlZ2VuZXJhdGUgdXNpbmcgZ2VuZXJhdGlvbi9nZW4tc2Jjcy5qcyBzY3JpcHQuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgXCI0MzdcIjogXCJjcDQzN1wiLFxuICBcIjczN1wiOiBcImNwNzM3XCIsXG4gIFwiNzc1XCI6IFwiY3A3NzVcIixcbiAgXCI4NTBcIjogXCJjcDg1MFwiLFxuICBcIjg1MlwiOiBcImNwODUyXCIsXG4gIFwiODU1XCI6IFwiY3A4NTVcIixcbiAgXCI4NTZcIjogXCJjcDg1NlwiLFxuICBcIjg1N1wiOiBcImNwODU3XCIsXG4gIFwiODU4XCI6IFwiY3A4NThcIixcbiAgXCI4NjBcIjogXCJjcDg2MFwiLFxuICBcIjg2MVwiOiBcImNwODYxXCIsXG4gIFwiODYyXCI6IFwiY3A4NjJcIixcbiAgXCI4NjNcIjogXCJjcDg2M1wiLFxuICBcIjg2NFwiOiBcImNwODY0XCIsXG4gIFwiODY1XCI6IFwiY3A4NjVcIixcbiAgXCI4NjZcIjogXCJjcDg2NlwiLFxuICBcIjg2OVwiOiBcImNwODY5XCIsXG4gIFwiODc0XCI6IFwid2luZG93czg3NFwiLFxuICBcIjkyMlwiOiBcImNwOTIyXCIsXG4gIFwiMTA0NlwiOiBcImNwMTA0NlwiLFxuICBcIjExMjRcIjogXCJjcDExMjRcIixcbiAgXCIxMTI1XCI6IFwiY3AxMTI1XCIsXG4gIFwiMTEyOVwiOiBcImNwMTEyOVwiLFxuICBcIjExMzNcIjogXCJjcDExMzNcIixcbiAgXCIxMTYxXCI6IFwiY3AxMTYxXCIsXG4gIFwiMTE2MlwiOiBcImNwMTE2MlwiLFxuICBcIjExNjNcIjogXCJjcDExNjNcIixcbiAgXCIxMjUwXCI6IFwid2luZG93czEyNTBcIixcbiAgXCIxMjUxXCI6IFwid2luZG93czEyNTFcIixcbiAgXCIxMjUyXCI6IFwid2luZG93czEyNTJcIixcbiAgXCIxMjUzXCI6IFwid2luZG93czEyNTNcIixcbiAgXCIxMjU0XCI6IFwid2luZG93czEyNTRcIixcbiAgXCIxMjU1XCI6IFwid2luZG93czEyNTVcIixcbiAgXCIxMjU2XCI6IFwid2luZG93czEyNTZcIixcbiAgXCIxMjU3XCI6IFwid2luZG93czEyNTdcIixcbiAgXCIxMjU4XCI6IFwid2luZG93czEyNThcIixcbiAgXCIyODU5MVwiOiBcImlzbzg4NTkxXCIsXG4gIFwiMjg1OTJcIjogXCJpc284ODU5MlwiLFxuICBcIjI4NTkzXCI6IFwiaXNvODg1OTNcIixcbiAgXCIyODU5NFwiOiBcImlzbzg4NTk0XCIsXG4gIFwiMjg1OTVcIjogXCJpc284ODU5NVwiLFxuICBcIjI4NTk2XCI6IFwiaXNvODg1OTZcIixcbiAgXCIyODU5N1wiOiBcImlzbzg4NTk3XCIsXG4gIFwiMjg1OThcIjogXCJpc284ODU5OFwiLFxuICBcIjI4NTk5XCI6IFwiaXNvODg1OTlcIixcbiAgXCIyODYwMFwiOiBcImlzbzg4NTkxMFwiLFxuICBcIjI4NjAxXCI6IFwiaXNvODg1OTExXCIsXG4gIFwiMjg2MDNcIjogXCJpc284ODU5MTNcIixcbiAgXCIyODYwNFwiOiBcImlzbzg4NTkxNFwiLFxuICBcIjI4NjA1XCI6IFwiaXNvODg1OTE1XCIsXG4gIFwiMjg2MDZcIjogXCJpc284ODU5MTZcIixcbiAgXCJ3aW5kb3dzODc0XCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLigqzvv73vv73vv73vv73igKbvv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73igJjigJnigJzigJ3igKLigJPigJTvv73vv73vv73vv73vv73vv73vv73vv73CoOC4geC4guC4g+C4hOC4heC4huC4h+C4iOC4ieC4iuC4i+C4jOC4jeC4juC4j+C4kOC4keC4kuC4k+C4lOC4leC4luC4l+C4mOC4meC4muC4m+C4nOC4neC4nuC4n+C4oOC4oeC4ouC4o+C4pOC4peC4puC4p+C4qOC4qeC4quC4q+C4rOC4reC4ruC4r+C4sOC4seC4suC4s+C4tOC4teC4tuC4t+C4uOC4ueC4uu+/ve+/ve+/ve+/veC4v+C5gOC5geC5guC5g+C5hOC5heC5huC5h+C5iOC5ieC5iuC5i+C5jOC5jeC5juC5j+C5kOC5keC5kuC5k+C5lOC5leC5luC5l+C5mOC5meC5muC5m++/ve+/ve+/ve+/vVwiXG4gIH0sXG4gIFwid2luODc0XCI6IFwid2luZG93czg3NFwiLFxuICBcImNwODc0XCI6IFwid2luZG93czg3NFwiLFxuICBcIndpbmRvd3MxMjUwXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLigqzvv73igJrvv73igJ7igKbigKDigKHvv73igLDFoOKAucWaxaTFvcW577+94oCY4oCZ4oCc4oCd4oCi4oCT4oCU77+94oSixaHigLrFm8Wlxb7FusKgy4fLmMWBwqTEhMKmwqfCqMKpxZ7Cq8Kswq3CrsW7wrDCscubxYLCtMK1wrbCt8K4xIXFn8K7xL3LncS+xbzFlMOBw4LEgsOExLnEhsOHxIzDicSYw4vEmsONw47EjsSQxYPFh8OTw5TFkMOWw5fFmMWuw5rFsMOcw53FosOfxZXDocOixIPDpMS6xIfDp8SNw6nEmcOrxJvDrcOuxI/EkcWExYjDs8O0xZHDtsO3xZnFr8O6xbHDvMO9xaPLmVwiXG4gIH0sXG4gIFwid2luMTI1MFwiOiBcIndpbmRvd3MxMjUwXCIsXG4gIFwiY3AxMjUwXCI6IFwid2luZG93czEyNTBcIixcbiAgXCJ3aW5kb3dzMTI1MVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwi0ILQg+KAmtGT4oCe4oCm4oCg4oCh4oKs4oCw0InigLnQitCM0IvQj9GS4oCY4oCZ4oCc4oCd4oCi4oCT4oCU77+94oSi0ZnigLrRmtGc0ZvRn8Kg0I7RntCIwqTSkMKmwqfQgcKp0ITCq8Kswq3CrtCHwrDCsdCG0ZbSkcK1wrbCt9GR4oSW0ZTCu9GY0IXRldGX0JDQkdCS0JPQlNCV0JbQl9CY0JnQmtCb0JzQndCe0J/QoNCh0KLQo9Ck0KXQptCn0KjQqdCq0KvQrNCt0K7Qr9Cw0LHQstCz0LTQtdC20LfQuNC50LrQu9C80L3QvtC/0YDRgdGC0YPRhNGF0YbRh9GI0YnRitGL0YzRjdGO0Y9cIlxuICB9LFxuICBcIndpbjEyNTFcIjogXCJ3aW5kb3dzMTI1MVwiLFxuICBcImNwMTI1MVwiOiBcIndpbmRvd3MxMjUxXCIsXG4gIFwid2luZG93czEyNTJcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIuKCrO+/veKAmsaS4oCe4oCm4oCg4oChy4bigLDFoOKAucWS77+9xb3vv73vv73igJjigJnigJzigJ3igKLigJPigJTLnOKEosWh4oC6xZPvv73FvsW4wqDCocKiwqPCpMKlwqbCp8KowqnCqsKrwqzCrcKuwq/CsMKxwrLCs8K0wrXCtsK3wrjCucK6wrvCvMK9wr7Cv8OAw4HDgsODw4TDhcOGw4fDiMOJw4rDi8OMw43DjsOPw5DDkcOSw5PDlMOVw5bDl8OYw5nDmsObw5zDncOew5/DoMOhw6LDo8Okw6XDpsOnw6jDqcOqw6vDrMOtw67Dr8Oww7HDssOzw7TDtcO2w7fDuMO5w7rDu8O8w73DvsO/XCJcbiAgfSxcbiAgXCJ3aW4xMjUyXCI6IFwid2luZG93czEyNTJcIixcbiAgXCJjcDEyNTJcIjogXCJ3aW5kb3dzMTI1MlwiLFxuICBcIndpbmRvd3MxMjUzXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLigqzvv73igJrGkuKAnuKApuKAoOKAoe+/veKAsO+/veKAue+/ve+/ve+/ve+/ve+/veKAmOKAmeKAnOKAneKAouKAk+KAlO+/veKEou+/veKAuu+/ve+/ve+/ve+/vcKgzoXOhsKjwqTCpcKmwqfCqMKp77+9wqvCrMKtwq7igJXCsMKxwrLCs86EwrXCtsK3zojOic6KwrvOjMK9zo7Oj86QzpHOks6TzpTOlc6WzpfOmM6ZzprOm86czp3Ons6fzqDOoe+/vc6jzqTOpc6mzqfOqM6pzqrOq86szq3Ors6vzrDOsc6yzrPOtM61zrbOt864zrnOus67zrzOvc6+zr/PgM+Bz4LPg8+Ez4XPhs+Hz4jPic+Kz4vPjM+Nz47vv71cIlxuICB9LFxuICBcIndpbjEyNTNcIjogXCJ3aW5kb3dzMTI1M1wiLFxuICBcImNwMTI1M1wiOiBcIndpbmRvd3MxMjUzXCIsXG4gIFwid2luZG93czEyNTRcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIuKCrO+/veKAmsaS4oCe4oCm4oCg4oChy4bigLDFoOKAucWS77+977+977+977+94oCY4oCZ4oCc4oCd4oCi4oCT4oCUy5zihKLFoeKAusWT77+977+9xbjCoMKhwqLCo8KkwqXCpsKnwqjCqcKqwqvCrMKtwq7Cr8KwwrHCssKzwrTCtcK2wrfCuMK5wrrCu8K8wr3CvsK/w4DDgcOCw4PDhMOFw4bDh8OIw4nDisOLw4zDjcOOw4/EnsORw5LDk8OUw5XDlsOXw5jDmcOaw5vDnMSwxZ7Dn8Ogw6HDosOjw6TDpcOmw6fDqMOpw6rDq8Osw63DrsOvxJ/DscOyw7PDtMO1w7bDt8O4w7nDusO7w7zEscWfw79cIlxuICB9LFxuICBcIndpbjEyNTRcIjogXCJ3aW5kb3dzMTI1NFwiLFxuICBcImNwMTI1NFwiOiBcIndpbmRvd3MxMjU0XCIsXG4gIFwid2luZG93czEyNTVcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIuKCrO+/veKAmsaS4oCe4oCm4oCg4oChy4bigLDvv73igLnvv73vv73vv73vv73vv73igJjigJnigJzigJ3igKLigJPigJTLnOKEou+/veKAuu+/ve+/ve+/ve+/vcKgwqHCosKj4oKqwqXCpsKnwqjCqcOXwqvCrMKtwq7Cr8KwwrHCssKzwrTCtcK2wrfCuMK5w7fCu8K8wr3CvsK/1rDWsday1rPWtNa11rbWt9a41rnWuta71rzWvda+1r/XgNeB14LXg9ew17HXstez17Tvv73vv73vv73vv73vv73vv73vv73XkNeR15LXk9eU15XXlteX15jXmdea15vXnNed157Xn9eg16HXotej16TXpdem16fXqNep16rvv73vv73igI7igI/vv71cIlxuICB9LFxuICBcIndpbjEyNTVcIjogXCJ3aW5kb3dzMTI1NVwiLFxuICBcImNwMTI1NVwiOiBcIndpbmRvd3MxMjU1XCIsXG4gIFwid2luZG93czEyNTZcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIuKCrNm+4oCaxpLigJ7igKbigKDigKHLhuKAsNm54oC5xZLahtqY2ojar+KAmOKAmeKAnOKAneKAouKAk+KAlNqp4oSi2pHigLrFk+KAjOKAjdq6wqDYjMKiwqPCpMKlwqbCp8KowqnavsKrwqzCrcKuwq/CsMKxwrLCs8K0wrXCtsK3wrjCudibwrvCvMK9wr7Yn9uB2KHYotij2KTYpdim2KfYqNip2KrYq9is2K3Yrtiv2LDYsdiy2LPYtNi12LbDl9i32LjYudi62YDZgdmC2YPDoNmEw6LZhdmG2YfZiMOnw6jDqcOqw6vZidmKw67Dr9mL2YzZjdmOw7TZj9mQw7fZkcO52ZLDu8O84oCO4oCP25JcIlxuICB9LFxuICBcIndpbjEyNTZcIjogXCJ3aW5kb3dzMTI1NlwiLFxuICBcImNwMTI1NlwiOiBcIndpbmRvd3MxMjU2XCIsXG4gIFwid2luZG93czEyNTdcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIuKCrO+/veKAmu+/veKAnuKApuKAoOKAoe+/veKAsO+/veKAue+/vcKoy4fCuO+/veKAmOKAmeKAnOKAneKAouKAk+KAlO+/veKEou+/veKAuu+/vcKvy5vvv73CoO+/vcKiwqPCpO+/vcKmwqfDmMKpxZbCq8Kswq3CrsOGwrDCscKywrPCtMK1wrbCt8O4wrnFl8K7wrzCvcK+w6bEhMSuxIDEhsOEw4XEmMSSxIzDicW5xJbEosS2xKrEu8WgxYPFhcOTxYzDlcOWw5fFssWBxZrFqsOcxbvFvcOfxIXEr8SBxIfDpMOlxJnEk8SNw6nFusSXxKPEt8SrxLzFocWExYbDs8WNw7XDtsO3xbPFgsWbxavDvMW8xb7LmVwiXG4gIH0sXG4gIFwid2luMTI1N1wiOiBcIndpbmRvd3MxMjU3XCIsXG4gIFwiY3AxMjU3XCI6IFwid2luZG93czEyNTdcIixcbiAgXCJ3aW5kb3dzMTI1OFwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwi4oKs77+94oCaxpLigJ7igKbigKDigKHLhuKAsO+/veKAucWS77+977+977+977+94oCY4oCZ4oCc4oCd4oCi4oCT4oCUy5zihKLvv73igLrFk++/ve+/vcW4wqDCocKiwqPCpMKlwqbCp8KowqnCqsKrwqzCrcKuwq/CsMKxwrLCs8K0wrXCtsK3wrjCucK6wrvCvMK9wr7Cv8OAw4HDgsSCw4TDhcOGw4fDiMOJw4rDi8yAw43DjsOPxJDDkcyJw5PDlMagw5bDl8OYw5nDmsObw5zGr8yDw5/DoMOhw6LEg8Okw6XDpsOnw6jDqcOqw6vMgcOtw67Dr8SRw7HMo8Ozw7TGocO2w7fDuMO5w7rDu8O8xrDigqvDv1wiXG4gIH0sXG4gIFwid2luMTI1OFwiOiBcIndpbmRvd3MxMjU4XCIsXG4gIFwiY3AxMjU4XCI6IFwid2luZG93czEyNThcIixcbiAgXCJpc284ODU5MVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiwoDCgcKCwoPChMKFwobCh8KIwonCisKLwozCjcKOwo/CkMKRwpLCk8KUwpXClsKXwpjCmcKawpvCnMKdwp7Cn8KgwqHCosKjwqTCpcKmwqfCqMKpwqrCq8Kswq3CrsKvwrDCscKywrPCtMK1wrbCt8K4wrnCusK7wrzCvcK+wr/DgMOBw4LDg8OEw4XDhsOHw4jDicOKw4vDjMONw47Dj8OQw5HDksOTw5TDlcOWw5fDmMOZw5rDm8Ocw53DnsOfw6DDocOiw6PDpMOlw6bDp8Oow6nDqsOrw6zDrcOuw6/DsMOxw7LDs8O0w7XDtsO3w7jDucO6w7vDvMO9w77Dv1wiXG4gIH0sXG4gIFwiY3AyODU5MVwiOiBcImlzbzg4NTkxXCIsXG4gIFwiaXNvODg1OTJcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsKAwoHCgsKDwoTChcKGwofCiMKJworCi8KMwo3CjsKPwpDCkcKSwpPClMKVwpbCl8KYwpnCmsKbwpzCncKewp/CoMSEy5jFgcKkxL3FmsKnwqjFoMWexaTFucKtxb3Fu8KwxIXLm8WCwrTEvsWby4fCuMWhxZ/FpcW6y53FvsW8xZTDgcOCxILDhMS5xIbDh8SMw4nEmMOLxJrDjcOOxI7EkMWDxYfDk8OUxZDDlsOXxZjFrsOaxbDDnMOdxaLDn8WVw6HDosSDw6TEusSHw6fEjcOpxJnDq8Sbw63DrsSPxJHFhMWIw7PDtMWRw7bDt8WZxa/DusWxw7zDvcWjy5lcIlxuICB9LFxuICBcImNwMjg1OTJcIjogXCJpc284ODU5MlwiLFxuICBcImlzbzg4NTkzXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLCgMKBwoLCg8KEwoXChsKHwojCicKKwovCjMKNwo7Cj8KQwpHCksKTwpTClcKWwpfCmMKZwprCm8Kcwp3CnsKfwqDEpsuYwqPCpO+/vcSkwqfCqMSwxZ7EnsS0wq3vv73Fu8KwxKfCssKzwrTCtcSlwrfCuMSxxZ/En8S1wr3vv73FvMOAw4HDgu+/vcOExIrEiMOHw4jDicOKw4vDjMONw47Dj++/vcORw5LDk8OUxKDDlsOXxJzDmcOaw5vDnMWsxZzDn8Ogw6HDou+/vcOkxIvEicOnw6jDqcOqw6vDrMOtw67Dr++/vcOxw7LDs8O0xKHDtsO3xJ3DucO6w7vDvMWtxZ3LmVwiXG4gIH0sXG4gIFwiY3AyODU5M1wiOiBcImlzbzg4NTkzXCIsXG4gIFwiaXNvODg1OTRcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsKAwoHCgsKDwoTChcKGwofCiMKJworCi8KMwo3CjsKPwpDCkcKSwpPClMKVwpbCl8KYwpnCmsKbwpzCncKewp/CoMSExLjFlsKkxKjEu8KnwqjFoMSSxKLFpsKtxb3Cr8KwxIXLm8WXwrTEqcS8y4fCuMWhxJPEo8WnxYrFvsWLxIDDgcOCw4PDhMOFw4bErsSMw4nEmMOLxJbDjcOOxKrEkMWFxYzEtsOUw5XDlsOXw5jFssOaw5vDnMWoxarDn8SBw6HDosOjw6TDpcOmxK/EjcOpxJnDq8SXw63DrsSrxJHFhsWNxLfDtMO1w7bDt8O4xbPDusO7w7zFqcWry5lcIlxuICB9LFxuICBcImNwMjg1OTRcIjogXCJpc284ODU5NFwiLFxuICBcImlzbzg4NTk1XCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLCgMKBwoLCg8KEwoXChsKHwojCicKKwovCjMKNwo7Cj8KQwpHCksKTwpTClcKWwpfCmMKZwprCm8Kcwp3CnsKfwqDQgdCC0IPQhNCF0IbQh9CI0InQitCL0IzCrdCO0I/QkNCR0JLQk9CU0JXQltCX0JjQmdCa0JvQnNCd0J7Qn9Cg0KHQotCj0KTQpdCm0KfQqNCp0KrQq9Cs0K3QrtCv0LDQsdCy0LPQtNC10LbQt9C40LnQutC70LzQvdC+0L/RgNGB0YLRg9GE0YXRhtGH0YjRidGK0YvRjNGN0Y7Rj+KEltGR0ZLRk9GU0ZXRltGX0ZjRmdGa0ZvRnMKn0Z7Rn1wiXG4gIH0sXG4gIFwiY3AyODU5NVwiOiBcImlzbzg4NTk1XCIsXG4gIFwiaXNvODg1OTZcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsKAwoHCgsKDwoTChcKGwofCiMKJworCi8KMwo3CjsKPwpDCkcKSwpPClMKVwpbCl8KYwpnCmsKbwpzCncKewp/CoO+/ve+/ve+/vcKk77+977+977+977+977+977+977+92IzCre+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/vdib77+977+977+92J/vv73Yodii2KPYpNil2KbYp9io2KnYqtir2KzYrdiu2K/YsNix2LLYs9i02LXYtti32LjYudi677+977+977+977+977+92YDZgdmC2YPZhNmF2YbZh9mI2YnZitmL2YzZjdmO2Y/ZkNmR2ZLvv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv71cIlxuICB9LFxuICBcImNwMjg1OTZcIjogXCJpc284ODU5NlwiLFxuICBcImlzbzg4NTk3XCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLCgMKBwoLCg8KEwoXChsKHwojCicKKwovCjMKNwo7Cj8KQwpHCksKTwpTClcKWwpfCmMKZwprCm8Kcwp3CnsKfwqDigJjigJnCo+KCrOKCr8KmwqfCqMKpzbrCq8Kswq3vv73igJXCsMKxwrLCs86EzoXOhsK3zojOic6KwrvOjMK9zo7Oj86QzpHOks6TzpTOlc6WzpfOmM6ZzprOm86czp3Ons6fzqDOoe+/vc6jzqTOpc6mzqfOqM6pzqrOq86szq3Ors6vzrDOsc6yzrPOtM61zrbOt864zrnOus67zrzOvc6+zr/PgM+Bz4LPg8+Ez4XPhs+Hz4jPic+Kz4vPjM+Nz47vv71cIlxuICB9LFxuICBcImNwMjg1OTdcIjogXCJpc284ODU5N1wiLFxuICBcImlzbzg4NTk4XCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLCgMKBwoLCg8KEwoXChsKHwojCicKKwovCjMKNwo7Cj8KQwpHCksKTwpTClcKWwpfCmMKZwprCm8Kcwp3CnsKfwqDvv73CosKjwqTCpcKmwqfCqMKpw5fCq8Kswq3CrsKvwrDCscKywrPCtMK1wrbCt8K4wrnDt8K7wrzCvcK+77+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+94oCX15DXkdeS15PXlNeV15bXl9eY15nXmteb15zXndee15/XoNeh16LXo9ek16XXpten16jXqdeq77+977+94oCO4oCP77+9XCJcbiAgfSxcbiAgXCJjcDI4NTk4XCI6IFwiaXNvODg1OThcIixcbiAgXCJpc284ODU5OVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiwoDCgcKCwoPChMKFwobCh8KIwonCisKLwozCjcKOwo/CkMKRwpLCk8KUwpXClsKXwpjCmcKawpvCnMKdwp7Cn8KgwqHCosKjwqTCpcKmwqfCqMKpwqrCq8Kswq3CrsKvwrDCscKywrPCtMK1wrbCt8K4wrnCusK7wrzCvcK+wr/DgMOBw4LDg8OEw4XDhsOHw4jDicOKw4vDjMONw47Dj8Sew5HDksOTw5TDlcOWw5fDmMOZw5rDm8OcxLDFnsOfw6DDocOiw6PDpMOlw6bDp8Oow6nDqsOrw6zDrcOuw6/En8Oxw7LDs8O0w7XDtsO3w7jDucO6w7vDvMSxxZ/Dv1wiXG4gIH0sXG4gIFwiY3AyODU5OVwiOiBcImlzbzg4NTk5XCIsXG4gIFwiaXNvODg1OTEwXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLCgMKBwoLCg8KEwoXChsKHwojCicKKwovCjMKNwo7Cj8KQwpHCksKTwpTClcKWwpfCmMKZwprCm8Kcwp3CnsKfwqDEhMSSxKLEqsSoxLbCp8S7xJDFoMWmxb3CrcWqxYrCsMSFxJPEo8SrxKnEt8K3xLzEkcWhxafFvuKAlcWrxYvEgMOBw4LDg8OEw4XDhsSuxIzDicSYw4vElsONw47Dj8OQxYXFjMOTw5TDlcOWxajDmMWyw5rDm8Ocw53DnsOfxIHDocOiw6PDpMOlw6bEr8SNw6nEmcOrxJfDrcOuw6/DsMWGxY3Ds8O0w7XDtsWpw7jFs8O6w7vDvMO9w77EuFwiXG4gIH0sXG4gIFwiY3AyODYwMFwiOiBcImlzbzg4NTkxMFwiLFxuICBcImlzbzg4NTkxMVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiwoDCgcKCwoPChMKFwobCh8KIwonCisKLwozCjcKOwo/CkMKRwpLCk8KUwpXClsKXwpjCmcKawpvCnMKdwp7Cn8Kg4LiB4LiC4LiD4LiE4LiF4LiG4LiH4LiI4LiJ4LiK4LiL4LiM4LiN4LiO4LiP4LiQ4LiR4LiS4LiT4LiU4LiV4LiW4LiX4LiY4LiZ4Lia4Lib4Lic4Lid4Lie4Lif4Lig4Lih4Lii4Lij4Lik4Lil4Lim4Lin4Lio4Lip4Liq4Lir4Lis4Lit4Liu4Liv4Liw4Lix4Liy4Liz4Li04Li14Li24Li34Li44Li54Li677+977+977+977+94Li/4LmA4LmB4LmC4LmD4LmE4LmF4LmG4LmH4LmI4LmJ4LmK4LmL4LmM4LmN4LmO4LmP4LmQ4LmR4LmS4LmT4LmU4LmV4LmW4LmX4LmY4LmZ4Lma4Lmb77+977+977+977+9XCJcbiAgfSxcbiAgXCJjcDI4NjAxXCI6IFwiaXNvODg1OTExXCIsXG4gIFwiaXNvODg1OTEzXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLCgMKBwoLCg8KEwoXChsKHwojCicKKwovCjMKNwo7Cj8KQwpHCksKTwpTClcKWwpfCmMKZwprCm8Kcwp3CnsKfwqDigJ3CosKjwqTigJ7CpsKnw5jCqcWWwqvCrMKtwq7DhsKwwrHCssKz4oCcwrXCtsK3w7jCucWXwrvCvMK9wr7DpsSExK7EgMSGw4TDhcSYxJLEjMOJxbnElsSixLbEqsS7xaDFg8WFw5PFjMOVw5bDl8WyxYHFmsWqw5zFu8W9w5/EhcSvxIHEh8Okw6XEmcSTxI3DqcW6xJfEo8S3xKvEvMWhxYTFhsOzxY3DtcO2w7fFs8WCxZvFq8O8xbzFvuKAmVwiXG4gIH0sXG4gIFwiY3AyODYwM1wiOiBcImlzbzg4NTkxM1wiLFxuICBcImlzbzg4NTkxNFwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiwoDCgcKCwoPChMKFwobCh8KIwonCisKLwozCjcKOwo/CkMKRwpLCk8KUwpXClsKXwpjCmcKawpvCnMKdwp7Cn8Kg4biC4biDwqPEisSL4biKwqfhuoDCqeG6guG4i+G7ssKtwq7FuOG4nuG4n8SgxKHhuYDhuYHCtuG5luG6geG5l+G6g+G5oOG7s+G6hOG6heG5ocOAw4HDgsODw4TDhcOGw4fDiMOJw4rDi8OMw43DjsOPxbTDkcOSw5PDlMOVw5bhuarDmMOZw5rDm8Ocw53FtsOfw6DDocOiw6PDpMOlw6bDp8Oow6nDqsOrw6zDrcOuw6/FtcOxw7LDs8O0w7XDtuG5q8O4w7nDusO7w7zDvcW3w79cIlxuICB9LFxuICBcImNwMjg2MDRcIjogXCJpc284ODU5MTRcIixcbiAgXCJpc284ODU5MTVcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsKAwoHCgsKDwoTChcKGwofCiMKJworCi8KMwo3CjsKPwpDCkcKSwpPClMKVwpbCl8KYwpnCmsKbwpzCncKewp/CoMKhwqLCo+KCrMKlxaDCp8WhwqnCqsKrwqzCrcKuwq/CsMKxwrLCs8W9wrXCtsK3xb7CucK6wrvFksWTxbjCv8OAw4HDgsODw4TDhcOGw4fDiMOJw4rDi8OMw43DjsOPw5DDkcOSw5PDlMOVw5bDl8OYw5nDmsObw5zDncOew5/DoMOhw6LDo8Okw6XDpsOnw6jDqcOqw6vDrMOtw67Dr8Oww7HDssOzw7TDtcO2w7fDuMO5w7rDu8O8w73DvsO/XCJcbiAgfSxcbiAgXCJjcDI4NjA1XCI6IFwiaXNvODg1OTE1XCIsXG4gIFwiaXNvODg1OTE2XCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLCgMKBwoLCg8KEwoXChsKHwojCicKKwovCjMKNwo7Cj8KQwpHCksKTwpTClcKWwpfCmMKZwprCm8Kcwp3CnsKfwqDEhMSFxYHigqzigJ7FoMKnxaHCqciYwqvFucKtxbrFu8KwwrHEjMWCxb3igJ3CtsK3xb7EjciZwrvFksWTxbjFvMOAw4HDgsSCw4TEhsOGw4fDiMOJw4rDi8OMw43DjsOPxJDFg8OSw5PDlMWQw5bFmsWww5nDmsObw5zEmMiaw5/DoMOhw6LEg8OkxIfDpsOnw6jDqcOqw6vDrMOtw67Dr8SRxYTDssOzw7TFkcO2xZvFscO5w7rDu8O8xJnIm8O/XCJcbiAgfSxcbiAgXCJjcDI4NjA2XCI6IFwiaXNvODg1OTE2XCIsXG4gIFwiY3A0MzdcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsOHw7zDqcOiw6TDoMOlw6fDqsOrw6jDr8Ouw6zDhMOFw4nDpsOGw7TDtsOyw7vDucO/w5bDnMKiwqPCpeKCp8aSw6HDrcOzw7rDscORwqrCusK/4oyQwqzCvcK8wqHCq8K74paR4paS4paT4pSC4pSk4pWh4pWi4pWW4pWV4pWj4pWR4pWX4pWd4pWc4pWb4pSQ4pSU4pS04pSs4pSc4pSA4pS84pWe4pWf4pWa4pWU4pWp4pWm4pWg4pWQ4pWs4pWn4pWo4pWk4pWl4pWZ4pWY4pWS4pWT4pWr4pWq4pSY4pSM4paI4paE4paM4paQ4paAzrHDn86Tz4DOo8+DwrXPhM6mzpjOqc604oiez4bOteKIqeKJocKx4oml4omk4oyg4oyhw7fiiYjCsOKImcK34oia4oG/wrLilqDCoFwiXG4gIH0sXG4gIFwiaWJtNDM3XCI6IFwiY3A0MzdcIixcbiAgXCJjc2libTQzN1wiOiBcImNwNDM3XCIsXG4gIFwiY3A3MzdcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIs6RzpLOk86UzpXOls6XzpjOmc6azpvOnM6dzp7On86gzqHOo86kzqXOps6nzqjOqc6xzrLOs860zrXOts63zrjOuc66zrvOvM69zr7Ov8+Az4HPg8+Cz4TPhc+Gz4fPiOKWkeKWkuKWk+KUguKUpOKVoeKVouKVluKVleKVo+KVkeKVl+KVneKVnOKVm+KUkOKUlOKUtOKUrOKUnOKUgOKUvOKVnuKVn+KVmuKVlOKVqeKVpuKVoOKVkOKVrOKVp+KVqOKVpOKVpeKVmeKVmOKVkuKVk+KVq+KVquKUmOKUjOKWiOKWhOKWjOKWkOKWgM+JzqzOrc6uz4rOr8+Mz43Pi8+OzobOiM6JzorOjM6Ozo/CseKJpeKJpM6qzqvDt+KJiMKw4oiZwrfiiJrigb/CsuKWoMKgXCJcbiAgfSxcbiAgXCJpYm03MzdcIjogXCJjcDczN1wiLFxuICBcImNzaWJtNzM3XCI6IFwiY3A3MzdcIixcbiAgXCJjcDc3NVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwixIbDvMOpxIHDpMSjw6XEh8WCxJPFlsWXxKvFucOEw4XDicOmw4bFjcO2xKLCosWaxZvDlsOcw7jCo8OYw5fCpMSAxKrDs8W7xbzFuuKAncKmwqnCrsKswr3CvMWBwqvCu+KWkeKWkuKWk+KUguKUpMSExIzEmMSW4pWj4pWR4pWX4pWdxK7FoOKUkOKUlOKUtOKUrOKUnOKUgOKUvMWyxarilZrilZTilanilabilaDilZDilazFvcSFxI3EmcSXxK/FocWzxavFvuKUmOKUjOKWiOKWhOKWjOKWkOKWgMOTw5/FjMWDw7XDlcK1xYTEtsS3xLvEvMWGxJLFheKAmcKtwrHigJzCvsK2wqfDt+KAnsKw4oiZwrfCucKzwrLilqDCoFwiXG4gIH0sXG4gIFwiaWJtNzc1XCI6IFwiY3A3NzVcIixcbiAgXCJjc2libTc3NVwiOiBcImNwNzc1XCIsXG4gIFwiY3A4NTBcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsOHw7zDqcOiw6TDoMOlw6fDqsOrw6jDr8Ouw6zDhMOFw4nDpsOGw7TDtsOyw7vDucO/w5bDnMO4wqPDmMOXxpLDocOtw7PDusOxw5HCqsK6wr/CrsKswr3CvMKhwqvCu+KWkeKWkuKWk+KUguKUpMOBw4LDgMKp4pWj4pWR4pWX4pWdwqLCpeKUkOKUlOKUtOKUrOKUnOKUgOKUvMOjw4PilZrilZTilanilabilaDilZDilazCpMOww5DDisOLw4jEscONw47Dj+KUmOKUjOKWiOKWhMKmw4ziloDDk8Ofw5TDksO1w5XCtcO+w57DmsObw5nDvcOdwq/CtMKtwrHigJfCvsK2wqfDt8K4wrDCqMK3wrnCs8Ky4pagwqBcIlxuICB9LFxuICBcImlibTg1MFwiOiBcImNwODUwXCIsXG4gIFwiY3NpYm04NTBcIjogXCJjcDg1MFwiLFxuICBcImNwODUyXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLDh8O8w6nDosOkxa/Eh8OnxYLDq8WQxZHDrsW5w4TEhsOJxLnEusO0w7bEvcS+xZrFm8OWw5zFpMWlxYHDl8SNw6HDrcOzw7rEhMSFxb3FvsSYxJnCrMW6xIzFn8KrwrvilpHilpLilpPilILilKTDgcOCxJrFnuKVo+KVkeKVl+KVncW7xbzilJDilJTilLTilKzilJzilIDilLzEgsSD4pWa4pWU4pWp4pWm4pWg4pWQ4pWswqTEkcSQxI7Di8SPxYfDjcOOxJvilJjilIzilojiloTFosWu4paAw5PDn8OUxYPFhMWIxaDFocWUw5rFlcWww73DncWjwrTCrcudy5vLh8uYwqfDt8K4wrDCqMuZxbHFmMWZ4pagwqBcIlxuICB9LFxuICBcImlibTg1MlwiOiBcImNwODUyXCIsXG4gIFwiY3NpYm04NTJcIjogXCJjcDg1MlwiLFxuICBcImNwODU1XCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLRktCC0ZPQg9GR0IHRlNCE0ZXQhdGW0IbRl9CH0ZjQiNGZ0InRmtCK0ZvQi9Gc0IzRntCO0Z/Qj9GO0K7RitCq0LDQkNCx0JHRhtCm0LTQlNC10JXRhNCk0LPQk8KrwrvilpHilpLilpPilILilKTRhdCl0LjQmOKVo+KVkeKVl+KVndC50JnilJDilJTilLTilKzilJzilIDilLzQutCa4pWa4pWU4pWp4pWm4pWg4pWQ4pWswqTQu9Cb0LzQnNC90J3QvtCe0L/ilJjilIzilojiloTQn9GP4paA0K/RgNCg0YHQodGC0KLRg9Cj0LbQltCy0JLRjNCs4oSWwq3Ri9Cr0LfQl9GI0KjRjdCt0YnQqdGH0KfCp+KWoMKgXCJcbiAgfSxcbiAgXCJpYm04NTVcIjogXCJjcDg1NVwiLFxuICBcImNzaWJtODU1XCI6IFwiY3A4NTVcIixcbiAgXCJjcDg1NlwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwi15DXkdeS15PXlNeV15bXl9eY15nXmteb15zXndee15/XoNeh16LXo9ek16XXpten16jXqdeq77+9wqPvv73Dl++/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/vcKuwqzCvcK877+9wqvCu+KWkeKWkuKWk+KUguKUpO+/ve+/ve+/vcKp4pWj4pWR4pWX4pWdwqLCpeKUkOKUlOKUtOKUrOKUnOKUgOKUvO+/ve+/veKVmuKVlOKVqeKVpuKVoOKVkOKVrMKk77+977+977+977+977+977+977+977+977+94pSY4pSM4paI4paEwqbvv73iloDvv73vv73vv73vv73vv73vv73Cte+/ve+/ve+/ve+/ve+/ve+/ve+/vcKvwrTCrcKx4oCXwr7CtsKnw7fCuMKwwqjCt8K5wrPCsuKWoMKgXCJcbiAgfSxcbiAgXCJpYm04NTZcIjogXCJjcDg1NlwiLFxuICBcImNzaWJtODU2XCI6IFwiY3A4NTZcIixcbiAgXCJjcDg1N1wiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiw4fDvMOpw6LDpMOgw6XDp8Oqw6vDqMOvw67EscOEw4XDicOmw4bDtMO2w7LDu8O5xLDDlsOcw7jCo8OYxZ7Fn8Ohw63Ds8O6w7HDkcSexJ/Cv8KuwqzCvcK8wqHCq8K74paR4paS4paT4pSC4pSkw4HDgsOAwqnilaPilZHilZfilZ3CosKl4pSQ4pSU4pS04pSs4pSc4pSA4pS8w6PDg+KVmuKVlOKVqeKVpuKVoOKVkOKVrMKkwrrCqsOKw4vDiO+/vcONw47Dj+KUmOKUjOKWiOKWhMKmw4ziloDDk8Ofw5TDksO1w5XCte+/vcOXw5rDm8OZw6zDv8KvwrTCrcKx77+9wr7CtsKnw7fCuMKwwqjCt8K5wrPCsuKWoMKgXCJcbiAgfSxcbiAgXCJpYm04NTdcIjogXCJjcDg1N1wiLFxuICBcImNzaWJtODU3XCI6IFwiY3A4NTdcIixcbiAgXCJjcDg1OFwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiw4fDvMOpw6LDpMOgw6XDp8Oqw6vDqMOvw67DrMOEw4XDicOmw4bDtMO2w7LDu8O5w7/DlsOcw7jCo8OYw5fGksOhw63Ds8O6w7HDkcKqwrrCv8KuwqzCvcK8wqHCq8K74paR4paS4paT4pSC4pSkw4HDgsOAwqnilaPilZHilZfilZ3CosKl4pSQ4pSU4pS04pSs4pSc4pSA4pS8w6PDg+KVmuKVlOKVqeKVpuKVoOKVkOKVrMKkw7DDkMOKw4vDiOKCrMONw47Dj+KUmOKUjOKWiOKWhMKmw4ziloDDk8Ofw5TDksO1w5XCtcO+w57DmsObw5nDvcOdwq/CtMKtwrHigJfCvsK2wqfDt8K4wrDCqMK3wrnCs8Ky4pagwqBcIlxuICB9LFxuICBcImlibTg1OFwiOiBcImNwODU4XCIsXG4gIFwiY3NpYm04NThcIjogXCJjcDg1OFwiLFxuICBcImNwODYwXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLDh8O8w6nDosOjw6DDgcOnw6rDisOow43DlMOsw4PDgsOJw4DDiMO0w7XDssOaw7nDjMOVw5zCosKjw5nigqfDk8Ohw63Ds8O6w7HDkcKqwrrCv8OSwqzCvcK8wqHCq8K74paR4paS4paT4pSC4pSk4pWh4pWi4pWW4pWV4pWj4pWR4pWX4pWd4pWc4pWb4pSQ4pSU4pS04pSs4pSc4pSA4pS84pWe4pWf4pWa4pWU4pWp4pWm4pWg4pWQ4pWs4pWn4pWo4pWk4pWl4pWZ4pWY4pWS4pWT4pWr4pWq4pSY4pSM4paI4paE4paM4paQ4paAzrHDn86Tz4DOo8+DwrXPhM6mzpjOqc604oiez4bOteKIqeKJocKx4oml4omk4oyg4oyhw7fiiYjCsOKImcK34oia4oG/wrLilqDCoFwiXG4gIH0sXG4gIFwiaWJtODYwXCI6IFwiY3A4NjBcIixcbiAgXCJjc2libTg2MFwiOiBcImNwODYwXCIsXG4gIFwiY3A4NjFcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsOHw7zDqcOiw6TDoMOlw6fDqsOrw6jDkMOww57DhMOFw4nDpsOGw7TDtsO+w7vDncO9w5bDnMO4wqPDmOKCp8aSw6HDrcOzw7rDgcONw5PDmsK/4oyQwqzCvcK8wqHCq8K74paR4paS4paT4pSC4pSk4pWh4pWi4pWW4pWV4pWj4pWR4pWX4pWd4pWc4pWb4pSQ4pSU4pS04pSs4pSc4pSA4pS84pWe4pWf4pWa4pWU4pWp4pWm4pWg4pWQ4pWs4pWn4pWo4pWk4pWl4pWZ4pWY4pWS4pWT4pWr4pWq4pSY4pSM4paI4paE4paM4paQ4paAzrHDn86Tz4DOo8+DwrXPhM6mzpjOqc604oiez4bOteKIqeKJocKx4oml4omk4oyg4oyhw7fiiYjCsOKImcK34oia4oG/wrLilqDCoFwiXG4gIH0sXG4gIFwiaWJtODYxXCI6IFwiY3A4NjFcIixcbiAgXCJjc2libTg2MVwiOiBcImNwODYxXCIsXG4gIFwiY3A4NjJcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIteQ15HXkteT15TXldeW15fXmNeZ15rXm9ec153Xntef16DXodei16PXpNel16bXp9eo16nXqsKiwqPCpeKCp8aSw6HDrcOzw7rDscORwqrCusK/4oyQwqzCvcK8wqHCq8K74paR4paS4paT4pSC4pSk4pWh4pWi4pWW4pWV4pWj4pWR4pWX4pWd4pWc4pWb4pSQ4pSU4pS04pSs4pSc4pSA4pS84pWe4pWf4pWa4pWU4pWp4pWm4pWg4pWQ4pWs4pWn4pWo4pWk4pWl4pWZ4pWY4pWS4pWT4pWr4pWq4pSY4pSM4paI4paE4paM4paQ4paAzrHDn86Tz4DOo8+DwrXPhM6mzpjOqc604oiez4bOteKIqeKJocKx4oml4omk4oyg4oyhw7fiiYjCsOKImcK34oia4oG/wrLilqDCoFwiXG4gIH0sXG4gIFwiaWJtODYyXCI6IFwiY3A4NjJcIixcbiAgXCJjc2libTg2MlwiOiBcImNwODYyXCIsXG4gIFwiY3A4NjNcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsOHw7zDqcOiw4LDoMK2w6fDqsOrw6jDr8Ou4oCXw4DCp8OJw4jDisO0w4vDj8O7w7nCpMOUw5zCosKjw5nDm8aSwqbCtMOzw7rCqMK4wrPCr8OO4oyQwqzCvcK8wr7Cq8K74paR4paS4paT4pSC4pSk4pWh4pWi4pWW4pWV4pWj4pWR4pWX4pWd4pWc4pWb4pSQ4pSU4pS04pSs4pSc4pSA4pS84pWe4pWf4pWa4pWU4pWp4pWm4pWg4pWQ4pWs4pWn4pWo4pWk4pWl4pWZ4pWY4pWS4pWT4pWr4pWq4pSY4pSM4paI4paE4paM4paQ4paAzrHDn86Tz4DOo8+DwrXPhM6mzpjOqc604oiez4bOteKIqeKJocKx4oml4omk4oyg4oyhw7fiiYjCsOKImcK34oia4oG/wrLilqDCoFwiXG4gIH0sXG4gIFwiaWJtODYzXCI6IFwiY3A4NjNcIixcbiAgXCJjc2libTg2M1wiOiBcImNwODYzXCIsXG4gIFwiY3A4NjRcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIlxcdTAwMDBcXHUwMDAxXFx1MDAwMlxcdTAwMDNcXHUwMDA0XFx1MDAwNVxcdTAwMDZcXHUwMDA3XFxiXFx0XFxuXFx1MDAwYlxcZlxcclxcdTAwMGVcXHUwMDBmXFx1MDAxMFxcdTAwMTFcXHUwMDEyXFx1MDAxM1xcdTAwMTRcXHUwMDE1XFx1MDAxNlxcdTAwMTdcXHUwMDE4XFx1MDAxOVxcdTAwMWFcXHUwMDFiXFx1MDAxY1xcdTAwMWRcXHUwMDFlXFx1MDAxZiAhXFxcIiMk2aomJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXFxcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn/CsMK34oiZ4oia4paS4pSA4pSC4pS84pSk4pSs4pSc4pS04pSQ4pSM4pSU4pSYzrLiiJ7PhsKxwr3CvOKJiMKrwrvvu7fvu7jvv73vv73vu7vvu7zvv73CoMKt77qCwqPCpO+6hO+/ve+/ve+6ju+6j++6le+6mdiM77qd77qh77ql2aDZodmi2aPZpNml2abZp9mo2anvu5HYm++6se+6te+6udifwqLvuoDvuoHvuoPvuoXvu4rvuovvuo3vupHvupPvupfvupvvup/vuqPvuqfvuqnvuqvvuq3vuq/vurPvurfvurvvur/vu4Hvu4Xvu4vvu4/CpsKsw7fDl++7idmA77uT77uX77ub77uf77uj77un77ur77ut77uv77uz77q977uM77uO77uN77uh77m92ZHvu6Xvu6nvu6zvu7Dvu7Lvu5Dvu5Xvu7Xvu7bvu53vu5nvu7HilqDvv71cIlxuICB9LFxuICBcImlibTg2NFwiOiBcImNwODY0XCIsXG4gIFwiY3NpYm04NjRcIjogXCJjcDg2NFwiLFxuICBcImNwODY1XCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLDh8O8w6nDosOkw6DDpcOnw6rDq8Oow6/DrsOsw4TDhcOJw6bDhsO0w7bDssO7w7nDv8OWw5zDuMKjw5jigqfGksOhw63Ds8O6w7HDkcKqwrrCv+KMkMKswr3CvMKhwqvCpOKWkeKWkuKWk+KUguKUpOKVoeKVouKVluKVleKVo+KVkeKVl+KVneKVnOKVm+KUkOKUlOKUtOKUrOKUnOKUgOKUvOKVnuKVn+KVmuKVlOKVqeKVpuKVoOKVkOKVrOKVp+KVqOKVpOKVpeKVmeKVmOKVkuKVk+KVq+KVquKUmOKUjOKWiOKWhOKWjOKWkOKWgM6xw5/Ok8+AzqPPg8K1z4TOps6YzqnOtOKIns+GzrXiiKniiaHCseKJpeKJpOKMoOKMocO34omIwrDiiJnCt+KImuKBv8Ky4pagwqBcIlxuICB9LFxuICBcImlibTg2NVwiOiBcImNwODY1XCIsXG4gIFwiY3NpYm04NjVcIjogXCJjcDg2NVwiLFxuICBcImNwODY2XCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLQkNCR0JLQk9CU0JXQltCX0JjQmdCa0JvQnNCd0J7Qn9Cg0KHQotCj0KTQpdCm0KfQqNCp0KrQq9Cs0K3QrtCv0LDQsdCy0LPQtNC10LbQt9C40LnQutC70LzQvdC+0L/ilpHilpLilpPilILilKTilaHilaLilZbilZXilaPilZHilZfilZ3ilZzilZvilJDilJTilLTilKzilJzilIDilLzilZ7ilZ/ilZrilZTilanilabilaDilZDilazilafilajilaTilaXilZnilZjilZLilZPilavilarilJjilIzilojiloTilozilpDiloDRgNGB0YLRg9GE0YXRhtGH0YjRidGK0YvRjNGN0Y7Rj9CB0ZHQhNGU0IfRl9CO0Z7CsOKImcK34oia4oSWwqTilqDCoFwiXG4gIH0sXG4gIFwiaWJtODY2XCI6IFwiY3A4NjZcIixcbiAgXCJjc2libTg2NlwiOiBcImNwODY2XCIsXG4gIFwiY3A4NjlcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIu+/ve+/ve+/ve+/ve+/ve+/vc6G77+9wrfCrMKm4oCY4oCZzojigJXOic6KzqrOjO+/ve+/vc6OzqvCqc6PwrLCs86swqPOrc6uzq/Pis6Qz4zPjc6RzpLOk86UzpXOls6Xwr3OmM6ZwqvCu+KWkeKWkuKWk+KUguKUpM6azpvOnM6d4pWj4pWR4pWX4pWdzp7On+KUkOKUlOKUtOKUrOKUnOKUgOKUvM6gzqHilZrilZTilanilabilaDilZDilazOo86kzqXOps6nzqjOqc6xzrLOs+KUmOKUjOKWiOKWhM60zrXiloDOts63zrjOuc66zrvOvM69zr7Ov8+Az4HPg8+Cz4TOhMKtwrHPhc+Gz4fCp8+IzoXCsMKoz4nPi86wz47ilqDCoFwiXG4gIH0sXG4gIFwiaWJtODY5XCI6IFwiY3A4NjlcIixcbiAgXCJjc2libTg2OVwiOiBcImNwODY5XCIsXG4gIFwiY3A5MjJcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsKAwoHCgsKDwoTChcKGwofCiMKJworCi8KMwo3CjsKPwpDCkcKSwpPClMKVwpbCl8KYwpnCmsKbwpzCncKewp/CoMKhwqLCo8KkwqXCpsKnwqjCqcKqwqvCrMKtwq7igL7CsMKxwrLCs8K0wrXCtsK3wrjCucK6wrvCvMK9wr7Cv8OAw4HDgsODw4TDhcOGw4fDiMOJw4rDi8OMw43DjsOPxaDDkcOSw5PDlMOVw5bDl8OYw5nDmsObw5zDncW9w5/DoMOhw6LDo8Okw6XDpsOnw6jDqcOqw6vDrMOtw67Dr8Whw7HDssOzw7TDtcO2w7fDuMO5w7rDu8O8w73FvsO/XCJcbiAgfSxcbiAgXCJpYm05MjJcIjogXCJjcDkyMlwiLFxuICBcImNzaWJtOTIyXCI6IFwiY3A5MjJcIixcbiAgXCJjcDEwNDZcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIu+6iMOXw7fvo7bvo7Xvo7Tvo7fvubHCiOKWoOKUguKUgOKUkOKUjOKUlOKUmO+5ue+5u++5ve+5v++5t++6iu+7sO+7s++7su+7ju+7j++7kO+7tu+7uO+7uu+7vMKg76O676O576O4wqTvo7vvuovvupHvupfvupvvup/vuqPYjMKt77qn77qz2aDZodmi2aPZpNml2abZp9mo2anvurfYm++6u++6v++7itif77uL2KHYotij2KTYpdim2KfYqNip2KrYq9is2K3Yrtiv2LDYsdiy2LPYtNi12LbYt++7h9i52Lrvu4zvuoLvuoTvuo7vu5PZgNmB2YLZg9mE2YXZhtmH2YjZidmK2YvZjNmN2Y7Zj9mQ2ZHZku+7l++7m++7n++jvO+7te+7t++7ue+7u++7o++7p++7rO+7qe+/vVwiXG4gIH0sXG4gIFwiaWJtMTA0NlwiOiBcImNwMTA0NlwiLFxuICBcImNzaWJtMTA0NlwiOiBcImNwMTA0NlwiLFxuICBcImNwMTEyNFwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiwoDCgcKCwoPChMKFwobCh8KIwonCisKLwozCjcKOwo/CkMKRwpLCk8KUwpXClsKXwpjCmcKawpvCnMKdwp7Cn8Kg0IHQgtKQ0ITQhdCG0IfQiNCJ0IrQi9CMwq3QjtCP0JDQkdCS0JPQlNCV0JbQl9CY0JnQmtCb0JzQndCe0J/QoNCh0KLQo9Ck0KXQptCn0KjQqdCq0KvQrNCt0K7Qr9Cw0LHQstCz0LTQtdC20LfQuNC50LrQu9C80L3QvtC/0YDRgdGC0YPRhNGF0YbRh9GI0YnRitGL0YzRjdGO0Y/ihJbRkdGS0pHRlNGV0ZbRl9GY0ZnRmtGb0ZzCp9Ge0Z9cIlxuICB9LFxuICBcImlibTExMjRcIjogXCJjcDExMjRcIixcbiAgXCJjc2libTExMjRcIjogXCJjcDExMjRcIixcbiAgXCJjcDExMjVcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcItCQ0JHQktCT0JTQldCW0JfQmNCZ0JrQm9Cc0J3QntCf0KDQodCi0KPQpNCl0KbQp9Co0KnQqtCr0KzQrdCu0K/QsNCx0LLQs9C00LXQttC30LjQudC60LvQvNC90L7Qv+KWkeKWkuKWk+KUguKUpOKVoeKVouKVluKVleKVo+KVkeKVl+KVneKVnOKVm+KUkOKUlOKUtOKUrOKUnOKUgOKUvOKVnuKVn+KVmuKVlOKVqeKVpuKVoOKVkOKVrOKVp+KVqOKVpOKVpeKVmeKVmOKVkuKVk+KVq+KVquKUmOKUjOKWiOKWhOKWjOKWkOKWgNGA0YHRgtGD0YTRhdGG0YfRiNGJ0YrRi9GM0Y3RjtGP0IHRkdKQ0pHQhNGU0IbRltCH0ZfCt+KImuKElsKk4pagwqBcIlxuICB9LFxuICBcImlibTExMjVcIjogXCJjcDExMjVcIixcbiAgXCJjc2libTExMjVcIjogXCJjcDExMjVcIixcbiAgXCJjcDExMjlcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsKAwoHCgsKDwoTChcKGwofCiMKJworCi8KMwo3CjsKPwpDCkcKSwpPClMKVwpbCl8KYwpnCmsKbwpzCncKewp/CoMKhwqLCo8KkwqXCpsKnxZPCqcKqwqvCrMKtwq7Cr8KwwrHCssKzxbjCtcK2wrfFksK5wrrCu8K8wr3CvsK/w4DDgcOCxILDhMOFw4bDh8OIw4nDisOLzIDDjcOOw4/EkMORzInDk8OUxqDDlsOXw5jDmcOaw5vDnMavzIPDn8Ogw6HDosSDw6TDpcOmw6fDqMOpw6rDq8yBw63DrsOvxJHDscyjw7PDtMahw7bDt8O4w7nDusO7w7zGsOKCq8O/XCJcbiAgfSxcbiAgXCJpYm0xMTI5XCI6IFwiY3AxMTI5XCIsXG4gIFwiY3NpYm0xMTI5XCI6IFwiY3AxMTI5XCIsXG4gIFwiY3AxMTMzXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLCgMKBwoLCg8KEwoXChsKHwojCicKKwovCjMKNwo7Cj8KQwpHCksKTwpTClcKWwpfCmMKZwprCm8Kcwp3CnsKfwqDguoHguoLguoTguofguojguqrguorguo3gupTgupXgupbgupfgupnguprgupvgupzgup3gup7gup/guqHguqLguqPguqXguqfguqvguq3guq7vv73vv73vv73guq/gurDgurLgurPgurTgurXgurbgurfgurjgurngurzgurHgurvgur3vv73vv73vv73gu4Dgu4Hgu4Lgu4Pgu4Tgu4jgu4ngu4rgu4vgu4zgu43gu4bvv73gu5zgu53igq3vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73gu5Dgu5Hgu5Lgu5Pgu5Tgu5Xgu5bgu5fgu5jgu5nvv73vv73CosKswqbvv71cIlxuICB9LFxuICBcImlibTExMzNcIjogXCJjcDExMzNcIixcbiAgXCJjc2libTExMzNcIjogXCJjcDExMzNcIixcbiAgXCJjcDExNjFcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIu+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/veC5iOC4geC4guC4g+C4hOC4heC4huC4h+C4iOC4ieC4iuC4i+C4jOC4jeC4juC4j+C4kOC4keC4kuC4k+C4lOC4leC4luC4l+C4mOC4meC4muC4m+C4nOC4neC4nuC4n+C4oOC4oeC4ouC4o+C4pOC4peC4puC4p+C4qOC4qeC4quC4q+C4rOC4reC4ruC4r+C4sOC4seC4suC4s+C4tOC4teC4tuC4t+C4uOC4ueC4uuC5ieC5iuC5i+KCrOC4v+C5gOC5geC5guC5g+C5hOC5heC5huC5h+C5iOC5ieC5iuC5i+C5jOC5jeC5juC5j+C5kOC5keC5kuC5k+C5lOC5leC5luC5l+C5mOC5meC5muC5m8KiwqzCpsKgXCJcbiAgfSxcbiAgXCJpYm0xMTYxXCI6IFwiY3AxMTYxXCIsXG4gIFwiY3NpYm0xMTYxXCI6IFwiY3AxMTYxXCIsXG4gIFwiY3AxMTYyXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLigqzCgcKCwoPChOKApsKGwofCiMKJworCi8KMwo3CjsKPwpDigJjigJnigJzigJ3igKLigJPigJTCmMKZwprCm8Kcwp3CnsKfwqDguIHguILguIPguITguIXguIbguIfguIjguInguIrguIvguIzguI3guI7guI/guJDguJHguJLguJPguJTguJXguJbguJfguJjguJnguJrguJvguJzguJ3guJ7guJ/guKDguKHguKLguKPguKTguKXguKbguKfguKjguKnguKrguKvguKzguK3guK7guK/guLDguLHguLLguLPguLTguLXguLbguLfguLjguLnguLrvv73vv73vv73vv73guL/guYDguYHguYLguYPguYTguYXguYbguYfguYjguYnguYrguYvguYzguY3guY7guY/guZDguZHguZLguZPguZTguZXguZbguZfguZjguZnguZrguZvvv73vv73vv73vv71cIlxuICB9LFxuICBcImlibTExNjJcIjogXCJjcDExNjJcIixcbiAgXCJjc2libTExNjJcIjogXCJjcDExNjJcIixcbiAgXCJjcDExNjNcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsKAwoHCgsKDwoTChcKGwofCiMKJworCi8KMwo3CjsKPwpDCkcKSwpPClMKVwpbCl8KYwpnCmsKbwpzCncKewp/CoMKhwqLCo+KCrMKlwqbCp8WTwqnCqsKrwqzCrcKuwq/CsMKxwrLCs8W4wrXCtsK3xZLCucK6wrvCvMK9wr7Cv8OAw4HDgsSCw4TDhcOGw4fDiMOJw4rDi8yAw43DjsOPxJDDkcyJw5PDlMagw5bDl8OYw5nDmsObw5zGr8yDw5/DoMOhw6LEg8Okw6XDpsOnw6jDqcOqw6vMgcOtw67Dr8SRw7HMo8Ozw7TGocO2w7fDuMO5w7rDu8O8xrDigqvDv1wiXG4gIH0sXG4gIFwiaWJtMTE2M1wiOiBcImNwMTE2M1wiLFxuICBcImNzaWJtMTE2M1wiOiBcImNwMTE2M1wiLFxuICBcIm1hY2Nyb2F0aWFuXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLDhMOFw4fDicORw5bDnMOhw6DDosOkw6PDpcOnw6nDqMOqw6vDrcOsw67Dr8Oxw7PDssO0w7bDtcO6w7nDu8O84oCgwrDCosKjwqfigKLCtsOfwq7FoOKEosK0wqjiiaDFvcOY4oiewrHiiaTiiaXiiIbCteKIguKIkeKIj8Wh4oirwqrCuuKEpsW+w7jCv8KhwqziiJrGkuKJiMSGwqvEjOKApsKgw4DDg8OVxZLFk8SQ4oCU4oCc4oCd4oCY4oCZw7fil4rvv73CqeKBhMKk4oC54oC6w4bCu+KAk8K34oCa4oCe4oCww4LEh8OBxI3DiMONw47Dj8OMw5PDlMSRw5LDmsObw5nEscuGy5zCr8+Aw4vLmsK4w4rDpsuHXCJcbiAgfSxcbiAgXCJtYWNjeXJpbGxpY1wiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwi0JDQkdCS0JPQlNCV0JbQl9CY0JnQmtCb0JzQndCe0J/QoNCh0KLQo9Ck0KXQptCn0KjQqdCq0KvQrNCt0K7Qr+KAoMKwwqLCo8Kn4oCiwrbQhsKuwqnihKLQgtGS4omg0IPRk+KInsKx4omk4oml0ZbCteKIgtCI0ITRlNCH0ZfQidGZ0IrRmtGY0IXCrOKImsaS4omI4oiGwqvCu+KApsKg0IvRm9CM0ZzRleKAk+KAlOKAnOKAneKAmOKAmcO34oCe0I7RntCP0Z/ihJbQgdGR0Y/QsNCx0LLQs9C00LXQttC30LjQudC60LvQvNC90L7Qv9GA0YHRgtGD0YTRhdGG0YfRiNGJ0YrRi9GM0Y3RjsKkXCJcbiAgfSxcbiAgXCJtYWNncmVla1wiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiw4TCucKyw4nCs8OWw5zOhcOgw6LDpM6EwqjDp8Opw6jDqsOrwqPihKLDrsOv4oCiwr3igLDDtMO2wqbCrcO5w7vDvOKAoM6TzpTOmM6bzp7OoMOfwq7Cqc6jzqrCp+KJoMKwzofOkcKx4omk4omlwqXOks6VzpbOl86ZzprOnM6mzqvOqM6pzqzOncKszp/OoeKJiM6kwqvCu+KApsKgzqXOp86GzojFk+KAk+KAleKAnOKAneKAmOKAmcO3zonOis6Mzo7Orc6uzq/PjM6Pz43Osc6yz4jOtM61z4bOs863zrnOvs66zrvOvM69zr/PgM+Oz4HPg8+EzrjPic+Cz4fPhc62z4rPi86QzrDvv71cIlxuICB9LFxuICBcIm1hY2ljZWxhbmRcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsOEw4XDh8OJw5HDlsOcw6HDoMOiw6TDo8Olw6fDqcOow6rDq8Otw6zDrsOvw7HDs8Oyw7TDtsO1w7rDucO7w7zDncKwwqLCo8Kn4oCiwrbDn8KuwqnihKLCtMKo4omgw4bDmOKInsKx4omk4omlwqXCteKIguKIkeKIj8+A4oirwqrCuuKEpsOmw7jCv8KhwqziiJrGkuKJiOKIhsKrwrvigKbCoMOAw4PDlcWSxZPigJPigJTigJzigJ3igJjigJnDt+KXisO/xbjigYTCpMOQw7DDnsO+w73Ct+KAmuKAnuKAsMOCw4rDgcOLw4jDjcOOw4/DjMOTw5Tvv73DksOaw5vDmcSxy4bLnMKvy5jLmcuawrjLncuby4dcIlxuICB9LFxuICBcIm1hY3JvbWFuXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLDhMOFw4fDicORw5bDnMOhw6DDosOkw6PDpcOnw6nDqMOqw6vDrcOsw67Dr8Oxw7PDssO0w7bDtcO6w7nDu8O84oCgwrDCosKjwqfigKLCtsOfwq7CqeKEosK0wqjiiaDDhsOY4oiewrHiiaTiiaXCpcK14oiC4oiR4oiPz4DiiKvCqsK64oSmw6bDuMK/wqHCrOKImsaS4omI4oiGwqvCu+KApsKgw4DDg8OVxZLFk+KAk+KAlOKAnOKAneKAmOKAmcO34peKw7/FuOKBhMKk4oC54oC676yB76yC4oChwrfigJrigJ7igLDDgsOKw4HDi8OIw43DjsOPw4zDk8OU77+9w5LDmsObw5nEscuGy5zCr8uYy5nLmsK4y53Lm8uHXCJcbiAgfSxcbiAgXCJtYWNyb21hbmlhXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLDhMOFw4fDicORw5bDnMOhw6DDosOkw6PDpcOnw6nDqMOqw6vDrcOsw67Dr8Oxw7PDssO0w7bDtcO6w7nDu8O84oCgwrDCosKjwqfigKLCtsOfwq7CqeKEosK0wqjiiaDEgsWe4oiewrHiiaTiiaXCpcK14oiC4oiR4oiPz4DiiKvCqsK64oSmxIPFn8K/wqHCrOKImsaS4omI4oiGwqvCu+KApsKgw4DDg8OVxZLFk+KAk+KAlOKAnOKAneKAmOKAmcO34peKw7/FuOKBhMKk4oC54oC6xaLFo+KAocK34oCa4oCe4oCww4LDisOBw4vDiMONw47Dj8OMw5PDlO+/vcOSw5rDm8OZxLHLhsucwq/LmMuZy5rCuMudy5vLh1wiXG4gIH0sXG4gIFwibWFjdGhhaVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiwqvCu+KApu+ijO+ij++iku+ile+imO+ii++iju+ike+ilO+il+KAnOKAne+ime+/veKAou+ihO+iie+ihe+ihu+ih++iiO+iiu+ije+ikO+ik++iluKAmOKAme+/vcKg4LiB4LiC4LiD4LiE4LiF4LiG4LiH4LiI4LiJ4LiK4LiL4LiM4LiN4LiO4LiP4LiQ4LiR4LiS4LiT4LiU4LiV4LiW4LiX4LiY4LiZ4Lia4Lib4Lic4Lid4Lie4Lif4Lig4Lih4Lii4Lij4Lik4Lil4Lim4Lin4Lio4Lip4Liq4Lir4Lis4Lit4Liu4Liv4Liw4Lix4Liy4Liz4Li04Li14Li24Li34Li44Li54Li677u/4oCL4oCT4oCU4Li/4LmA4LmB4LmC4LmD4LmE4LmF4LmG4LmH4LmI4LmJ4LmK4LmL4LmM4LmN4oSi4LmP4LmQ4LmR4LmS4LmT4LmU4LmV4LmW4LmX4LmY4LmZwq7Cqe+/ve+/ve+/ve+/vVwiXG4gIH0sXG4gIFwibWFjdHVya2lzaFwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiw4TDhcOHw4nDkcOWw5zDocOgw6LDpMOjw6XDp8Opw6jDqsOrw63DrMOuw6/DscOzw7LDtMO2w7XDusO5w7vDvOKAoMKwwqLCo8Kn4oCiwrbDn8KuwqnihKLCtMKo4omgw4bDmOKInsKx4omk4omlwqXCteKIguKIkeKIj8+A4oirwqrCuuKEpsOmw7jCv8KhwqziiJrGkuKJiOKIhsKrwrvigKbCoMOAw4PDlcWSxZPigJPigJTigJzigJ3igJjigJnDt+KXisO/xbjEnsSfxLDEscWexZ/igKHCt+KAmuKAnuKAsMOCw4rDgcOLw4jDjcOOw4/DjMOTw5Tvv73DksOaw5vDme+/vcuGy5zCr8uYy5nLmsK4y53Lm8uHXCJcbiAgfSxcbiAgXCJtYWN1a3JhaW5lXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLQkNCR0JLQk9CU0JXQltCX0JjQmdCa0JvQnNCd0J7Qn9Cg0KHQotCj0KTQpdCm0KfQqNCp0KrQq9Cs0K3QrtCv4oCgwrDSkMKjwqfigKLCttCGwq7CqeKEotCC0ZLiiaDQg9GT4oiewrHiiaTiiaXRlsK10pHQiNCE0ZTQh9GX0InRmdCK0ZrRmNCFwqziiJrGkuKJiOKIhsKrwrvigKbCoNCL0ZvQjNGc0ZXigJPigJTigJzigJ3igJjigJnDt+KAntCO0Z7Qj9Gf4oSW0IHRkdGP0LDQsdCy0LPQtNC10LbQt9C40LnQutC70LzQvdC+0L/RgNGB0YLRg9GE0YXRhtGH0YjRidGK0YvRjNGN0Y7CpFwiXG4gIH0sXG4gIFwia29pOHJcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIuKUgOKUguKUjOKUkOKUlOKUmOKUnOKUpOKUrOKUtOKUvOKWgOKWhOKWiOKWjOKWkOKWkeKWkuKWk+KMoOKWoOKImeKImuKJiOKJpOKJpcKg4oyhwrDCssK3w7filZDilZHilZLRkeKVk+KVlOKVleKVluKVl+KVmOKVmeKVmuKVm+KVnOKVneKVnuKVn+KVoOKVodCB4pWi4pWj4pWk4pWl4pWm4pWn4pWo4pWp4pWq4pWr4pWswqnRjtCw0LHRhtC00LXRhNCz0YXQuNC50LrQu9C80L3QvtC/0Y/RgNGB0YLRg9C20LLRjNGL0LfRiNGN0YnRh9GK0K7QkNCR0KbQlNCV0KTQk9Cl0JjQmdCa0JvQnNCd0J7Qn9Cv0KDQodCi0KPQltCS0KzQq9CX0KjQrdCp0KfQqlwiXG4gIH0sXG4gIFwia29pOHVcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIuKUgOKUguKUjOKUkOKUlOKUmOKUnOKUpOKUrOKUtOKUvOKWgOKWhOKWiOKWjOKWkOKWkeKWkuKWk+KMoOKWoOKImeKImuKJiOKJpOKJpcKg4oyhwrDCssK3w7filZDilZHilZLRkdGU4pWU0ZbRl+KVl+KVmOKVmeKVmuKVm9KR4pWd4pWe4pWf4pWg4pWh0IHQhOKVo9CG0IfilabilafilajilanilarSkOKVrMKp0Y7QsNCx0YbQtNC10YTQs9GF0LjQudC60LvQvNC90L7Qv9GP0YDRgdGC0YPQttCy0YzRi9C30YjRjdGJ0YfRitCu0JDQkdCm0JTQldCk0JPQpdCY0JnQmtCb0JzQndCe0J/Qr9Cg0KHQotCj0JbQktCs0KvQl9Co0K3QqdCn0KpcIlxuICB9LFxuICBcImtvaThydVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwi4pSA4pSC4pSM4pSQ4pSU4pSY4pSc4pSk4pSs4pS04pS84paA4paE4paI4paM4paQ4paR4paS4paT4oyg4pag4oiZ4oia4omI4omk4omlwqDijKHCsMKywrfDt+KVkOKVkeKVktGR0ZTilZTRltGX4pWX4pWY4pWZ4pWa4pWb0pHRnuKVnuKVn+KVoOKVodCB0ITilaPQhtCH4pWm4pWn4pWo4pWp4pWq0pDQjsKp0Y7QsNCx0YbQtNC10YTQs9GF0LjQudC60LvQvNC90L7Qv9GP0YDRgdGC0YPQttCy0YzRi9C30YjRjdGJ0YfRitCu0JDQkdCm0JTQldCk0JPQpdCY0JnQmtCb0JzQndCe0J/Qr9Cg0KHQotCj0JbQktCs0KvQl9Co0K3QqdCn0KpcIlxuICB9LFxuICBcImtvaTh0XCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLSm9KT4oCa0pLigJ7igKbigKDigKHvv73igLDSs+KAudKy0rfStu+/vdKa4oCY4oCZ4oCc4oCd4oCi4oCT4oCU77+94oSi77+94oC677+977+977+977+977+906/TrtGRwqTTo8Kmwqfvv73vv73vv73Cq8Kswq3Cru+/vcKwwrHCstCB77+906LCtsK377+94oSW77+9wrvvv73vv73vv73CqdGO0LDQsdGG0LTQtdGE0LPRhdC40LnQutC70LzQvdC+0L/Rj9GA0YHRgtGD0LbQstGM0YvQt9GI0Y3RidGH0YrQrtCQ0JHQptCU0JXQpNCT0KXQmNCZ0JrQm9Cc0J3QntCf0K/QoNCh0KLQo9CW0JLQrNCr0JfQqNCt0KnQp9CqXCJcbiAgfSxcbiAgXCJhcm1zY2lpOFwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiwoDCgcKCwoPChMKFwobCh8KIwonCisKLwozCjcKOwo/CkMKRwpLCk8KUwpXClsKXwpjCmcKawpvCnMKdwp7Cn8Kg77+91ofWiSkowrvCq+KAlC7VnSwt1origKbVnNWb1Z7UsdWh1LLVotSz1aPUtNWk1LXVpdS21abUt9Wn1LjVqNS51anUutWq1LvVq9S81azUvdWt1L7VrtS/1a/VgNWw1YHVsdWC1bLVg9Wz1YTVtNWF1bXVhtW21YfVt9WI1bjVidW51YrVutWL1bvVjNW81Y3VvdWO1b7Vj9W/1ZDWgNWR1oHVktaC1ZPWg9WU1oTVldaF1ZbWhtWa77+9XCJcbiAgfSxcbiAgXCJyazEwNDhcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcItCC0IPigJrRk+KAnuKApuKAoOKAoeKCrOKAsNCJ4oC50IrSmtK60I/RkuKAmOKAmeKAnOKAneKAouKAk+KAlO+/veKEotGZ4oC60ZrSm9K70Z/CoNKw0rHTmMKk06jCpsKn0IHCqdKSwqvCrMKtwq7SrsKwwrHQhtGW06nCtcK2wrfRkeKEltKTwrvTmdKi0qPSr9CQ0JHQktCT0JTQldCW0JfQmNCZ0JrQm9Cc0J3QntCf0KDQodCi0KPQpNCl0KbQp9Co0KnQqtCr0KzQrdCu0K/QsNCx0LLQs9C00LXQttC30LjQudC60LvQvNC90L7Qv9GA0YHRgtGD0YTRhdGG0YfRiNGJ0YrRi9GM0Y3RjtGPXCJcbiAgfSxcbiAgXCJ0Y3ZuXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCJcXHUwMDAww5rhu6RcXHUwMDAz4buq4bus4buuXFx1MDAwN1xcYlxcdFxcblxcdTAwMGJcXGZcXHJcXHUwMDBlXFx1MDAwZlxcdTAwMTDhu6jhu7Dhu7Lhu7bhu7jDneG7tFxcdTAwMThcXHUwMDE5XFx1MDAxYVxcdTAwMWJcXHUwMDFjXFx1MDAxZFxcdTAwMWVcXHUwMDFmICFcXFwiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXFxcXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/w4DhuqLDg8OB4bqg4bq24bqsw4jhurrhurzDieG6uOG7hsOM4buIxKjDjeG7isOS4buOw5XDk+G7jOG7mOG7nOG7nuG7oOG7muG7osOZ4bumxajCoMSCw4LDisOUxqDGr8SQxIPDosOqw7TGocawxJHhurDMgMyJzIPMgcyjw6DhuqPDo8Oh4bqh4bqy4bqx4bqz4bq14bqv4bq04bqu4bqm4bqo4bqq4bqk4buA4bq34bqn4bqp4bqr4bql4bqtw6jhu4Lhurvhur3DqeG6ueG7geG7g+G7heG6v+G7h8Os4buJ4buE4bq+4buSxKnDreG7i8Oy4buU4buPw7XDs+G7jeG7k+G7leG7l+G7keG7meG7neG7n+G7oeG7m+G7o8O54buW4bunxanDuuG7peG7q+G7reG7r+G7qeG7seG7s+G7t+G7ucO94bu14buQXCJcbiAgfSxcbiAgXCJnZW9yZ2lhbmFjYWRlbXlcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsKAwoHigJrGkuKAnuKApuKAoOKAocuG4oCwxaDigLnFksKNwo7Cj8KQ4oCY4oCZ4oCc4oCd4oCi4oCT4oCUy5zihKLFoeKAusWTwp3CnsW4wqDCocKiwqPCpMKlwqbCp8KowqnCqsKrwqzCrcKuwq/CsMKxwrLCs8K0wrXCtsK3wrjCucK6wrvCvMK9wr7Cv+GDkOGDkeGDkuGDk+GDlOGDleGDluGDl+GDmOGDmeGDmuGDm+GDnOGDneGDnuGDn+GDoOGDoeGDouGDo+GDpOGDpeGDpuGDp+GDqOGDqeGDquGDq+GDrOGDreGDruGDr+GDsOGDseGDsuGDs+GDtOGDteGDtsOnw6jDqcOqw6vDrMOtw67Dr8Oww7HDssOzw7TDtcO2w7fDuMO5w7rDu8O8w73DvsO/XCJcbiAgfSxcbiAgXCJnZW9yZ2lhbnBzXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLCgMKB4oCaxpLigJ7igKbigKDigKHLhuKAsMWg4oC5xZLCjcKOwo/CkOKAmOKAmeKAnOKAneKAouKAk+KAlMuc4oSixaHigLrFk8Kdwp7FuMKgwqHCosKjwqTCpcKmwqfCqMKpwqrCq8Kswq3CrsKvwrDCscKywrPCtMK1wrbCt8K4wrnCusK7wrzCvcK+wr/hg5Dhg5Hhg5Lhg5Phg5Thg5Xhg5bhg7Hhg5fhg5jhg5nhg5rhg5vhg5zhg7Lhg53hg57hg5/hg6Dhg6Hhg6Lhg7Phg6Phg6Thg6Xhg6bhg6fhg6jhg6nhg6rhg6vhg6zhg63hg67hg7Thg6/hg7Dhg7XDpsOnw6jDqcOqw6vDrMOtw67Dr8Oww7HDssOzw7TDtcO2w7fDuMO5w7rDu8O8w73DvsO/XCJcbiAgfSxcbiAgXCJwdDE1NFwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwi0pbSktOu0pPigJ7igKbSttKu0rLSr9Kg06LSotKa0rrSuNKX4oCY4oCZ4oCc4oCd4oCi4oCT4oCU0rPSt9Kh06PSo9Kb0rvSucKg0I7RntCI06jSmNKwwqfQgcKp05jCq8Ks06/CrtKcwrDSsdCG0ZbSmdOpwrbCt9GR4oSW05nCu9GY0qrSq9Kd0JDQkdCS0JPQlNCV0JbQl9CY0JnQmtCb0JzQndCe0J/QoNCh0KLQo9Ck0KXQptCn0KjQqdCq0KvQrNCt0K7Qr9Cw0LHQstCz0LTQtdC20LfQuNC50LrQu9C80L3QvtC/0YDRgdGC0YPRhNGF0YbRh9GI0YnRitGL0YzRjdGO0Y9cIlxuICB9LFxuICBcInZpc2NpaVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiXFx1MDAwMFxcdTAwMDHhurJcXHUwMDAzXFx1MDAwNOG6tOG6qlxcdTAwMDdcXGJcXHRcXG5cXHUwMDBiXFxmXFxyXFx1MDAwZVxcdTAwMGZcXHUwMDEwXFx1MDAxMVxcdTAwMTJcXHUwMDEz4bu2XFx1MDAxNVxcdTAwMTZcXHUwMDE3XFx1MDAxOOG7uFxcdTAwMWFcXHUwMDFiXFx1MDAxY1xcdTAwMWThu7RcXHUwMDFmICFcXFwiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXFxcXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/4bqg4bqu4bqw4bq24bqk4bqm4bqo4bqs4bq84bq44bq+4buA4buC4buE4buG4buQ4buS4buU4buW4buY4bui4bua4buc4bue4buK4buO4buM4buI4bumxajhu6Thu7LDleG6r+G6seG6t+G6peG6p+G6qeG6reG6veG6ueG6v+G7geG7g+G7heG7h+G7keG7k+G7leG7l+G7oMag4buZ4bud4buf4buL4buw4buo4buq4busxqHhu5vGr8OAw4HDgsOD4bqixILhurPhurXDiMOJw4rhurrDjMONxKjhu7PEkOG7qcOSw5PDlOG6oeG7t+G7q+G7rcOZw5rhu7nhu7XDneG7ocaww6DDocOiw6PhuqPEg+G7r+G6q8Oow6nDquG6u8Osw63EqeG7icSR4buxw7LDs8O0w7Xhu4/hu43hu6XDucO6xanhu6fDveG7o+G7rlwiXG4gIH0sXG4gIFwiaXNvNjQ2Y25cIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIlxcdTAwMDBcXHUwMDAxXFx1MDAwMlxcdTAwMDNcXHUwMDA0XFx1MDAwNVxcdTAwMDZcXHUwMDA3XFxiXFx0XFxuXFx1MDAwYlxcZlxcclxcdTAwMGVcXHUwMDBmXFx1MDAxMFxcdTAwMTFcXHUwMDEyXFx1MDAxM1xcdTAwMTRcXHUwMDE1XFx1MDAxNlxcdTAwMTdcXHUwMDE4XFx1MDAxOVxcdTAwMWFcXHUwMDFiXFx1MDAxY1xcdTAwMWRcXHUwMDFlXFx1MDAxZiAhXFxcIiPCpSUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXFxcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x94oC+f++/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/vVwiXG4gIH0sXG4gIFwiaXNvNjQ2anBcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIlxcdTAwMDBcXHUwMDAxXFx1MDAwMlxcdTAwMDNcXHUwMDA0XFx1MDAwNVxcdTAwMDZcXHUwMDA3XFxiXFx0XFxuXFx1MDAwYlxcZlxcclxcdTAwMGVcXHUwMDBmXFx1MDAxMFxcdTAwMTFcXHUwMDEyXFx1MDAxM1xcdTAwMTRcXHUwMDE1XFx1MDAxNlxcdTAwMTdcXHUwMDE4XFx1MDAxOVxcdTAwMWFcXHUwMDFiXFx1MDAxY1xcdTAwMWRcXHUwMDFlXFx1MDAxZiAhXFxcIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaW8KlXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x94oC+f++/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/vVwiXG4gIH0sXG4gIFwiaHByb21hbjhcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsKAwoHCgsKDwoTChcKGwofCiMKJworCi8KMwo3CjsKPwpDCkcKSwpPClMKVwpbCl8KYwpnCmsKbwpzCncKewp/CoMOAw4LDiMOKw4vDjsOPwrTLi8uGwqjLnMOZw5vigqTCr8Odw73CsMOHw6fDkcOxwqHCv8KkwqPCpcKnxpLCosOiw6rDtMO7w6HDqcOzw7rDoMOow7LDucOkw6vDtsO8w4XDrsOYw4bDpcOtw7jDpsOEw6zDlsOcw4nDr8Ofw5TDgcODw6PDkMOww43DjMOTw5LDlcO1xaDFocOaxbjDv8Oew77Ct8K1wrbCvuKAlMK8wr3CqsK6wqvilqDCu8Kx77+9XCJcbiAgfSxcbiAgXCJtYWNpbnRvc2hcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsOEw4XDh8OJw5HDlsOcw6HDoMOiw6TDo8Olw6fDqcOow6rDq8Otw6zDrsOvw7HDs8Oyw7TDtsO1w7rDucO7w7zigKDCsMKiwqPCp+KAosK2w5/CrsKp4oSiwrTCqOKJoMOGw5jiiJ7CseKJpOKJpcKlwrXiiILiiJHiiI/PgOKIq8KqwrrihKbDpsO4wr/CocKs4oiaxpLiiYjiiIbCq8K74oCmwqDDgMODw5XFksWT4oCT4oCU4oCc4oCd4oCY4oCZw7fil4rDv8W44oGEwqTigLnigLrvrIHvrILigKHCt+KAmuKAnuKAsMOCw4rDgcOLw4jDjcOOw4/DjMOTw5Tvv73DksOaw5vDmcSxy4bLnMKvy5jLmcuawrjLncuby4dcIlxuICB9LFxuICBcImFzY2lpXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLvv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv71cIlxuICB9LFxuICBcInRpczYyMFwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwi77+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+94LiB4LiC4LiD4LiE4LiF4LiG4LiH4LiI4LiJ4LiK4LiL4LiM4LiN4LiO4LiP4LiQ4LiR4LiS4LiT4LiU4LiV4LiW4LiX4LiY4LiZ4Lia4Lib4Lic4Lid4Lie4Lif4Lig4Lih4Lii4Lij4Lik4Lil4Lim4Lin4Lio4Lip4Liq4Lir4Lis4Lit4Liu4Liv4Liw4Lix4Liy4Liz4Li04Li14Li24Li34Li44Li54Li677+977+977+977+94Li/4LmA4LmB4LmC4LmD4LmE4LmF4LmG4LmH4LmI4LmJ4LmK4LmL4LmM4LmN4LmO4LmP4LmQ4LmR4LmS4LmT4LmU4LmV4LmW4LmX4LmY4LmZ4Lma4Lmb77+977+977+977+9XCJcbiAgfVxufSJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/sbcs-data-generated.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/sbcs-data.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/mailparser/node_modules/iconv-lite/encodings/sbcs-data.js ***!
  \*********************************************************************************/
/***/ ((module) => {

eval("\n\n// Manually added data to be used by sbcs codec in addition to generated one.\n\nmodule.exports = {\n  // Not supported by iconv, not sure why.\n  10029: \"maccenteuro\",\n  maccenteuro: {\n    type: \"_sbcs\",\n    chars: \"\"\n  },\n\n  808: \"cp808\",\n  ibm808: \"cp808\",\n  cp808: {\n    type: \"_sbcs\",\n    chars: \"\"\n  },\n\n  mik: {\n    type: \"_sbcs\",\n    chars: \"\"\n  },\n\n  cp720: {\n    type: \"_sbcs\",\n    chars: \"\\x80\\x81\\x84\\x86\\x8d\\x8e\\x8f\\x90\\u0651\\u0652\\u064b\\u064c\\u064d\\u064e\\u064f\\u0650\\u00a0\"\n  },\n\n  // Aliases of generated encodings.\n  ascii8bit: \"ascii\",\n  usascii: \"ascii\",\n  ansix34: \"ascii\",\n  ansix341968: \"ascii\",\n  ansix341986: \"ascii\",\n  csascii: \"ascii\",\n  cp367: \"ascii\",\n  ibm367: \"ascii\",\n  isoir6: \"ascii\",\n  iso646us: \"ascii\",\n  iso646irv: \"ascii\",\n  us: \"ascii\",\n\n  latin1: \"iso88591\",\n  latin2: \"iso88592\",\n  latin3: \"iso88593\",\n  latin4: \"iso88594\",\n  latin5: \"iso88599\",\n  latin6: \"iso885910\",\n  latin7: \"iso885913\",\n  latin8: \"iso885914\",\n  latin9: \"iso885915\",\n  latin10: \"iso885916\",\n\n  csisolatin1: \"iso88591\",\n  csisolatin2: \"iso88592\",\n  csisolatin3: \"iso88593\",\n  csisolatin4: \"iso88594\",\n  csisolatincyrillic: \"iso88595\",\n  csisolatinarabic: \"iso88596\",\n  csisolatingreek: \"iso88597\",\n  csisolatinhebrew: \"iso88598\",\n  csisolatin5: \"iso88599\",\n  csisolatin6: \"iso885910\",\n\n  l1: \"iso88591\",\n  l2: \"iso88592\",\n  l3: \"iso88593\",\n  l4: \"iso88594\",\n  l5: \"iso88599\",\n  l6: \"iso885910\",\n  l7: \"iso885913\",\n  l8: \"iso885914\",\n  l9: \"iso885915\",\n  l10: \"iso885916\",\n\n  isoir14: \"iso646jp\",\n  isoir57: \"iso646cn\",\n  isoir100: \"iso88591\",\n  isoir101: \"iso88592\",\n  isoir109: \"iso88593\",\n  isoir110: \"iso88594\",\n  isoir144: \"iso88595\",\n  isoir127: \"iso88596\",\n  isoir126: \"iso88597\",\n  isoir138: \"iso88598\",\n  isoir148: \"iso88599\",\n  isoir157: \"iso885910\",\n  isoir166: \"tis620\",\n  isoir179: \"iso885913\",\n  isoir199: \"iso885914\",\n  isoir203: \"iso885915\",\n  isoir226: \"iso885916\",\n\n  cp819: \"iso88591\",\n  ibm819: \"iso88591\",\n\n  cyrillic: \"iso88595\",\n\n  arabic: \"iso88596\",\n  arabic8: \"iso88596\",\n  ecma114: \"iso88596\",\n  asmo708: \"iso88596\",\n\n  greek: \"iso88597\",\n  greek8: \"iso88597\",\n  ecma118: \"iso88597\",\n  elot928: \"iso88597\",\n\n  hebrew: \"iso88598\",\n  hebrew8: \"iso88598\",\n\n  turkish: \"iso88599\",\n  turkish8: \"iso88599\",\n\n  thai: \"iso885911\",\n  thai8: \"iso885911\",\n\n  celtic: \"iso885914\",\n  celtic8: \"iso885914\",\n  isoceltic: \"iso885914\",\n\n  tis6200: \"tis620\",\n  tis62025291: \"tis620\",\n  tis62025330: \"tis620\",\n\n  10000: \"macroman\",\n  10006: \"macgreek\",\n  10007: \"maccyrillic\",\n  10079: \"maciceland\",\n  10081: \"macturkish\",\n\n  cspc8codepage437: \"cp437\",\n  cspc775baltic: \"cp775\",\n  cspc850multilingual: \"cp850\",\n  cspcp852: \"cp852\",\n  cspc862latinhebrew: \"cp862\",\n  cpgr: \"cp869\",\n\n  msee: \"cp1250\",\n  mscyrl: \"cp1251\",\n  msansi: \"cp1252\",\n  msgreek: \"cp1253\",\n  msturk: \"cp1254\",\n  mshebr: \"cp1255\",\n  msarab: \"cp1256\",\n  winbaltrim: \"cp1257\",\n\n  cp20866: \"koi8r\",\n  20866: \"koi8r\",\n  ibm878: \"koi8r\",\n  cskoi8r: \"koi8r\",\n\n  cp21866: \"koi8u\",\n  21866: \"koi8u\",\n  ibm1168: \"koi8u\",\n\n  strk10482002: \"rk1048\",\n\n  tcvn5712: \"tcvn\",\n  tcvn57121: \"tcvn\",\n\n  gb198880: \"iso646cn\",\n  cn: \"iso646cn\",\n\n  csiso14jisc6220ro: \"iso646jp\",\n  jisc62201969ro: \"iso646jp\",\n  jp: \"iso646jp\",\n\n  cshproman8: \"hproman8\",\n  r8: \"hproman8\",\n  roman8: \"hproman8\",\n  xroman8: \"hproman8\",\n  ibm1051: \"hproman8\",\n\n  mac: \"macintosh\",\n  csmacintosh: \"macintosh\"\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL21haWxwYXJzZXIvbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvZW5jb2RpbmdzL3NiY3MtZGF0YS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGtmcnl0XFwuZ2VtaW5pXFxhbnRpZ3Jhdml0eVxcc2NyYXRjaFxcZHJfa2Fsc192aXJ0dWFsX2hvc3BpdGFsXFxub2RlX21vZHVsZXNcXG1haWxwYXJzZXJcXG5vZGVfbW9kdWxlc1xcaWNvbnYtbGl0ZVxcZW5jb2RpbmdzXFxzYmNzLWRhdGEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCJcblxuLy8gTWFudWFsbHkgYWRkZWQgZGF0YSB0byBiZSB1c2VkIGJ5IHNiY3MgY29kZWMgaW4gYWRkaXRpb24gdG8gZ2VuZXJhdGVkIG9uZS5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIE5vdCBzdXBwb3J0ZWQgYnkgaWNvbnYsIG5vdCBzdXJlIHdoeS5cbiAgMTAwMjk6IFwibWFjY2VudGV1cm9cIixcbiAgbWFjY2VudGV1cm86IHtcbiAgICB0eXBlOiBcIl9zYmNzXCIsXG4gICAgY2hhcnM6IFwiw4TEgMSBw4nEhMOWw5zDocSFxIzDpMSNxIbEh8OpxbnFusSOw63Ej8SSxJPElsOzxJfDtMO2w7XDusSaxJvDvOKAoMKwxJjCo8Kn4oCiwrbDn8KuwqnihKLEmcKo4omgxKPErsSvxKriiaTiiaXEq8S24oiC4oiRxYLEu8S8xL3EvsS5xLrFhcWGxYPCrOKImsWExYfiiIbCq8K74oCmwqDFiMWQw5XFkcWM4oCT4oCU4oCc4oCd4oCY4oCZw7fil4rFjcWUxZXFmOKAueKAusWZxZbFl8Wg4oCa4oCexaHFmsWbw4HFpMWlw43FvcW+xarDk8OUxavFrsOaxa/FsMWxxbLFs8Odw73Et8W7xYHFvMSiy4dcIlxuICB9LFxuXG4gIDgwODogXCJjcDgwOFwiLFxuICBpYm04MDg6IFwiY3A4MDhcIixcbiAgY3A4MDg6IHtcbiAgICB0eXBlOiBcIl9zYmNzXCIsXG4gICAgY2hhcnM6IFwi0JDQkdCS0JPQlNCV0JbQl9CY0JnQmtCb0JzQndCe0J/QoNCh0KLQo9Ck0KXQptCn0KjQqdCq0KvQrNCt0K7Qr9Cw0LHQstCz0LTQtdC20LfQuNC50LrQu9C80L3QvtC/4paR4paS4paT4pSC4pSk4pWh4pWi4pWW4pWV4pWj4pWR4pWX4pWd4pWc4pWb4pSQ4pSU4pS04pSs4pSc4pSA4pS84pWe4pWf4pWa4pWU4pWp4pWm4pWg4pWQ4pWs4pWn4pWo4pWk4pWl4pWZ4pWY4pWS4pWT4pWr4pWq4pSY4pSM4paI4paE4paM4paQ4paA0YDRgdGC0YPRhNGF0YbRh9GI0YnRitGL0YzRjdGO0Y/QgdGR0ITRlNCH0ZfQjtGewrDiiJnCt+KImuKEluKCrOKWoMKgXCJcbiAgfSxcblxuICBtaWs6IHtcbiAgICB0eXBlOiBcIl9zYmNzXCIsXG4gICAgY2hhcnM6IFwi0JDQkdCS0JPQlNCV0JbQl9CY0JnQmtCb0JzQndCe0J/QoNCh0KLQo9Ck0KXQptCn0KjQqdCq0KvQrNCt0K7Qr9Cw0LHQstCz0LTQtdC20LfQuNC50LrQu9C80L3QvtC/0YDRgdGC0YPRhNGF0YbRh9GI0YnRitGL0YzRjdGO0Y/ilJTilLTilKzilJzilIDilLzilaPilZHilZrilZTilanilabilaDilZDilazilJDilpHilpLilpPilILilKTihJbCp+KVl+KVneKUmOKUjOKWiOKWhOKWjOKWkOKWgM6xw5/Ok8+AzqPPg8K1z4TOps6YzqnOtOKIns+GzrXiiKniiaHCseKJpeKJpOKMoOKMocO34omIwrDiiJnCt+KImuKBv8Ky4pagwqBcIlxuICB9LFxuXG4gIGNwNzIwOiB7XG4gICAgdHlwZTogXCJfc2Jjc1wiLFxuICAgIGNoYXJzOiBcIlxceDgwXFx4ODHDqcOiXFx4ODTDoFxceDg2w6fDqsOrw6jDr8OuXFx4OGRcXHg4ZVxceDhmXFx4OTBcXHUwNjUxXFx1MDY1MsO0wqTZgMO7w7nYodii2KPYpMKj2KXYptin2KjYqdiq2KvYrNit2K7Yr9iw2LHYstiz2LTYtcKrwrvilpHilpLilpPilILilKTilaHilaLilZbilZXilaPilZHilZfilZ3ilZzilZvilJDilJTilLTilKzilJzilIDilLzilZ7ilZ/ilZrilZTilanilabilaDilZDilazilafilajilaTilaXilZnilZjilZLilZPilavilarilJjilIzilojiloTilozilpDiloDYtti32LjYudi62YHCtdmC2YPZhNmF2YbZh9mI2YnZiuKJoVxcdTA2NGJcXHUwNjRjXFx1MDY0ZFxcdTA2NGVcXHUwNjRmXFx1MDY1MOKJiMKw4oiZwrfiiJrigb/CsuKWoFxcdTAwYTBcIlxuICB9LFxuXG4gIC8vIEFsaWFzZXMgb2YgZ2VuZXJhdGVkIGVuY29kaW5ncy5cbiAgYXNjaWk4Yml0OiBcImFzY2lpXCIsXG4gIHVzYXNjaWk6IFwiYXNjaWlcIixcbiAgYW5zaXgzNDogXCJhc2NpaVwiLFxuICBhbnNpeDM0MTk2ODogXCJhc2NpaVwiLFxuICBhbnNpeDM0MTk4NjogXCJhc2NpaVwiLFxuICBjc2FzY2lpOiBcImFzY2lpXCIsXG4gIGNwMzY3OiBcImFzY2lpXCIsXG4gIGlibTM2NzogXCJhc2NpaVwiLFxuICBpc29pcjY6IFwiYXNjaWlcIixcbiAgaXNvNjQ2dXM6IFwiYXNjaWlcIixcbiAgaXNvNjQ2aXJ2OiBcImFzY2lpXCIsXG4gIHVzOiBcImFzY2lpXCIsXG5cbiAgbGF0aW4xOiBcImlzbzg4NTkxXCIsXG4gIGxhdGluMjogXCJpc284ODU5MlwiLFxuICBsYXRpbjM6IFwiaXNvODg1OTNcIixcbiAgbGF0aW40OiBcImlzbzg4NTk0XCIsXG4gIGxhdGluNTogXCJpc284ODU5OVwiLFxuICBsYXRpbjY6IFwiaXNvODg1OTEwXCIsXG4gIGxhdGluNzogXCJpc284ODU5MTNcIixcbiAgbGF0aW44OiBcImlzbzg4NTkxNFwiLFxuICBsYXRpbjk6IFwiaXNvODg1OTE1XCIsXG4gIGxhdGluMTA6IFwiaXNvODg1OTE2XCIsXG5cbiAgY3Npc29sYXRpbjE6IFwiaXNvODg1OTFcIixcbiAgY3Npc29sYXRpbjI6IFwiaXNvODg1OTJcIixcbiAgY3Npc29sYXRpbjM6IFwiaXNvODg1OTNcIixcbiAgY3Npc29sYXRpbjQ6IFwiaXNvODg1OTRcIixcbiAgY3Npc29sYXRpbmN5cmlsbGljOiBcImlzbzg4NTk1XCIsXG4gIGNzaXNvbGF0aW5hcmFiaWM6IFwiaXNvODg1OTZcIixcbiAgY3Npc29sYXRpbmdyZWVrOiBcImlzbzg4NTk3XCIsXG4gIGNzaXNvbGF0aW5oZWJyZXc6IFwiaXNvODg1OThcIixcbiAgY3Npc29sYXRpbjU6IFwiaXNvODg1OTlcIixcbiAgY3Npc29sYXRpbjY6IFwiaXNvODg1OTEwXCIsXG5cbiAgbDE6IFwiaXNvODg1OTFcIixcbiAgbDI6IFwiaXNvODg1OTJcIixcbiAgbDM6IFwiaXNvODg1OTNcIixcbiAgbDQ6IFwiaXNvODg1OTRcIixcbiAgbDU6IFwiaXNvODg1OTlcIixcbiAgbDY6IFwiaXNvODg1OTEwXCIsXG4gIGw3OiBcImlzbzg4NTkxM1wiLFxuICBsODogXCJpc284ODU5MTRcIixcbiAgbDk6IFwiaXNvODg1OTE1XCIsXG4gIGwxMDogXCJpc284ODU5MTZcIixcblxuICBpc29pcjE0OiBcImlzbzY0NmpwXCIsXG4gIGlzb2lyNTc6IFwiaXNvNjQ2Y25cIixcbiAgaXNvaXIxMDA6IFwiaXNvODg1OTFcIixcbiAgaXNvaXIxMDE6IFwiaXNvODg1OTJcIixcbiAgaXNvaXIxMDk6IFwiaXNvODg1OTNcIixcbiAgaXNvaXIxMTA6IFwiaXNvODg1OTRcIixcbiAgaXNvaXIxNDQ6IFwiaXNvODg1OTVcIixcbiAgaXNvaXIxMjc6IFwiaXNvODg1OTZcIixcbiAgaXNvaXIxMjY6IFwiaXNvODg1OTdcIixcbiAgaXNvaXIxMzg6IFwiaXNvODg1OThcIixcbiAgaXNvaXIxNDg6IFwiaXNvODg1OTlcIixcbiAgaXNvaXIxNTc6IFwiaXNvODg1OTEwXCIsXG4gIGlzb2lyMTY2OiBcInRpczYyMFwiLFxuICBpc29pcjE3OTogXCJpc284ODU5MTNcIixcbiAgaXNvaXIxOTk6IFwiaXNvODg1OTE0XCIsXG4gIGlzb2lyMjAzOiBcImlzbzg4NTkxNVwiLFxuICBpc29pcjIyNjogXCJpc284ODU5MTZcIixcblxuICBjcDgxOTogXCJpc284ODU5MVwiLFxuICBpYm04MTk6IFwiaXNvODg1OTFcIixcblxuICBjeXJpbGxpYzogXCJpc284ODU5NVwiLFxuXG4gIGFyYWJpYzogXCJpc284ODU5NlwiLFxuICBhcmFiaWM4OiBcImlzbzg4NTk2XCIsXG4gIGVjbWExMTQ6IFwiaXNvODg1OTZcIixcbiAgYXNtbzcwODogXCJpc284ODU5NlwiLFxuXG4gIGdyZWVrOiBcImlzbzg4NTk3XCIsXG4gIGdyZWVrODogXCJpc284ODU5N1wiLFxuICBlY21hMTE4OiBcImlzbzg4NTk3XCIsXG4gIGVsb3Q5Mjg6IFwiaXNvODg1OTdcIixcblxuICBoZWJyZXc6IFwiaXNvODg1OThcIixcbiAgaGVicmV3ODogXCJpc284ODU5OFwiLFxuXG4gIHR1cmtpc2g6IFwiaXNvODg1OTlcIixcbiAgdHVya2lzaDg6IFwiaXNvODg1OTlcIixcblxuICB0aGFpOiBcImlzbzg4NTkxMVwiLFxuICB0aGFpODogXCJpc284ODU5MTFcIixcblxuICBjZWx0aWM6IFwiaXNvODg1OTE0XCIsXG4gIGNlbHRpYzg6IFwiaXNvODg1OTE0XCIsXG4gIGlzb2NlbHRpYzogXCJpc284ODU5MTRcIixcblxuICB0aXM2MjAwOiBcInRpczYyMFwiLFxuICB0aXM2MjAyNTI5MTogXCJ0aXM2MjBcIixcbiAgdGlzNjIwMjUzMzA6IFwidGlzNjIwXCIsXG5cbiAgMTAwMDA6IFwibWFjcm9tYW5cIixcbiAgMTAwMDY6IFwibWFjZ3JlZWtcIixcbiAgMTAwMDc6IFwibWFjY3lyaWxsaWNcIixcbiAgMTAwNzk6IFwibWFjaWNlbGFuZFwiLFxuICAxMDA4MTogXCJtYWN0dXJraXNoXCIsXG5cbiAgY3NwYzhjb2RlcGFnZTQzNzogXCJjcDQzN1wiLFxuICBjc3BjNzc1YmFsdGljOiBcImNwNzc1XCIsXG4gIGNzcGM4NTBtdWx0aWxpbmd1YWw6IFwiY3A4NTBcIixcbiAgY3NwY3A4NTI6IFwiY3A4NTJcIixcbiAgY3NwYzg2MmxhdGluaGVicmV3OiBcImNwODYyXCIsXG4gIGNwZ3I6IFwiY3A4NjlcIixcblxuICBtc2VlOiBcImNwMTI1MFwiLFxuICBtc2N5cmw6IFwiY3AxMjUxXCIsXG4gIG1zYW5zaTogXCJjcDEyNTJcIixcbiAgbXNncmVlazogXCJjcDEyNTNcIixcbiAgbXN0dXJrOiBcImNwMTI1NFwiLFxuICBtc2hlYnI6IFwiY3AxMjU1XCIsXG4gIG1zYXJhYjogXCJjcDEyNTZcIixcbiAgd2luYmFsdHJpbTogXCJjcDEyNTdcIixcblxuICBjcDIwODY2OiBcImtvaThyXCIsXG4gIDIwODY2OiBcImtvaThyXCIsXG4gIGlibTg3ODogXCJrb2k4clwiLFxuICBjc2tvaThyOiBcImtvaThyXCIsXG5cbiAgY3AyMTg2NjogXCJrb2k4dVwiLFxuICAyMTg2NjogXCJrb2k4dVwiLFxuICBpYm0xMTY4OiBcImtvaTh1XCIsXG5cbiAgc3RyazEwNDgyMDAyOiBcInJrMTA0OFwiLFxuXG4gIHRjdm41NzEyOiBcInRjdm5cIixcbiAgdGN2bjU3MTIxOiBcInRjdm5cIixcblxuICBnYjE5ODg4MDogXCJpc282NDZjblwiLFxuICBjbjogXCJpc282NDZjblwiLFxuXG4gIGNzaXNvMTRqaXNjNjIyMHJvOiBcImlzbzY0NmpwXCIsXG4gIGppc2M2MjIwMTk2OXJvOiBcImlzbzY0NmpwXCIsXG4gIGpwOiBcImlzbzY0NmpwXCIsXG5cbiAgY3NocHJvbWFuODogXCJocHJvbWFuOFwiLFxuICByODogXCJocHJvbWFuOFwiLFxuICByb21hbjg6IFwiaHByb21hbjhcIixcbiAgeHJvbWFuODogXCJocHJvbWFuOFwiLFxuICBpYm0xMDUxOiBcImhwcm9tYW44XCIsXG5cbiAgbWFjOiBcIm1hY2ludG9zaFwiLFxuICBjc21hY2ludG9zaDogXCJtYWNpbnRvc2hcIlxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/sbcs-data.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/tables/big5-added.json":
/*!*******************************************************************************************!*\
  !*** ../node_modules/mailparser/node_modules/iconv-lite/encodings/tables/big5-added.json ***!
  \*******************************************************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('[["8740",""],["8767",""],["87a1",""],["8840","",4,""],["88a1",""],["8940",""],["8943",""],["8946",""],["894c",""],["89a1",""],["89ab",""],["89b0",""],["89b5",""],["89c1",""],["89c5",""],["8a40",""],["8a43",""],["8a64",""],["8a76",""],["8aa1",""],["8aac",""],["8ab2",""],["8abb",""],["8ac9",""],["8ace",""],["8adf",""],["8af6",""],["8b40",""],["8b55",""],["8ba1",""],["8bde",""],["8c40",""],["8ca1",""],["8ca7",""],["8cc9",""],["8cce",""],["8ce6",""],["8d40",""],["8d42",""],["8da1",""],["8e40",""],["8ea1",""],["8f40",""],["8fa1",""],["9040",""],["90a1",""],["9140",""],["91a1",""],["9240",""],["92a1",""],["9340",""],["93a1",""],["9440",""],["94a1",""],["9540",""],["95a1",""],["9640",""],["96a1",""],["9740",""],["97a1",""],["9840",""],["98a1",""],["9940",""],["99a1",""],["9a40",""],["9aa1",""],["9b40",""],["9b62",""],["9ba1",""],["9c40",""],["9ca1",""],["9d40",""],["9da1",""],["9e40",""],["9ea1",""],["9ead",""],["9ec5",""],["9ef5",""],["9f40",""],["9f4f",""],["9fa1",""],["9fae",""],["9fb2",""],["9fc1",""],["9fc9",""],["9fdb",""],["9fe7",""],["9feb",""],["9ff0",""],["a040",""],["a055",""],["a058",""],["a05b",""],["a063",""],["a073",""],["a0a1",""],["a0a6",""],["a0ae",""],["a0b0",""],["a0d4",""],["a0e2",""],["a3c0","",31,""],["c6a1","",9,"",9,"",9,"",23],["c740","",58,""],["c7a1","",81,"",5,"",4],["c840","",26,"",25,""],["c8a1",""],["c8cd",""],["c8f5",""],["f9fe",""],["fa40",""],["faa1",""],["fb40",""],["fba1",""],["fc40",""],["fca1",""],["fd40",""],["fda1",""],["fe40",""],["fea1",""]]');

/***/ }),

/***/ "(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/tables/cp936.json":
/*!**************************************************************************************!*\
  !*** ../node_modules/mailparser/node_modules/iconv-lite/encodings/tables/cp936.json ***!
  \**************************************************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('[["0","\\u0000",127,""],["8140","",5,"",9,"",6,""],["8180","",6,"",4,"",4,"",5,""],["8240","",4,"",8,"",4,"",11],["8280","",10,"",4,"",7,"",5,"",8,"",20,"",4,"",6,""],["8340","",17,"",5,"",10,"",4,"",9,""],["8380","",5,"",13,"",28,"",4,"",4,"",5],["8440","",5,"",5,""],["8480","",9,"",4,"",6,"",6,"",9,"",5,"",10,"",7,""],["8540","",9,""],["8580","",4,"",6,"",4,"",4,"",7,""],["8640","",4,"",5,"",4,"",5,""],["8680","",4,"",4,"",5,"",6,"",8,"",4,"",4,"",4,""],["8740","",7,"",11,"",4,"",4],["8780","",7,"",6,"",14,"",10,"",6,"",12,"",8,"",5,"",6],["8840","",9,"",4,"",4,""],["8880","",4,"",6,"",8,"",6,"",7,"",4,"",4,"",7],["8940","",5,"",6,"",4,"",5,"",4,"",16,""],["8980","",4,"",4,"",7,"",17,"",10,"",13,"",5,"",7,"",4,""],["8a40","",4,"",12,""],["8a80","",5,"",6,"",4,"",11,"",6,"",4,"",4,"",9,"",5],["8b40","",8,"",17,"",6,"",13,""],["8b80","",4,"",4,"",5,"",4,"",4,"",22,"",11,"",25,"",7,"",6],["8c40","",7,""],["8c80","",8,"",4,"",6,"",6,"",6,"",4,"",4,"",4],["8d40","",5,"",5,"",5,"",6,"",9,"",4],["8d80","",5,"",4,"",4,"",4,"",7,"",7,"",10,"",10,"",12,"",21,""],["8e40","",21,"",12,"",6,"",12,""],["8e80","",4,"",7,"",4,"",4,"",5,"",6,"",4,"",14,"",4,"",4,"",6],["8f40","",5,"",11,"",8,""],["8f80","",6,"",14,"",5,"",5,"",4,""],["9040","",4,"",4,"",6,""],["9080","",7,"",4,"",4,"",4,"",4,"",18,"",6],["9140","",6,"",6,"",18,"",4,""],["9180","",6,"",8,"",9,"",5,"",4,"",4,"",16,"",13,"",8,"",5,"",4,""],["9240","",6,"",5,""],["9280","",5,"",7,"",6,""],["9340","",6,"",4,"",4,"",5,""],["9380","",5,"",4,"",6,"",4,"",7,"",9,"",6,"",8,"",4,"",6,""],["9440","",24,"",7,"",7,"",4,"",8],["9480","",4,"",4,"",14,"",7,"",7,""],["9540","",4,"",4,"",6,""],["9580","",4,"",4,"",8,"",4,"",4,"",25,"",7,"",5,""],["9640","",5,"",4,""],["9680","",7,"",9,"",7,"",4,"",6,"",6,"",5],["9740","",7,"",8,"",7,"",9,""],["9780","",6,"",5,"",4,"",9,"",4,"",11,"",7,"",16,""],["9840","",4,"",5,"",9,""],["9880","",7,"",5,"",11,"",9,"",9,"",11,"",5,"",5,"",6,"",4,"",7,"",6,""],["9940","",4,"",10,"",6,"",8,"",4,"",7,"",5],["9980","",114,"",6],["9a40","",11,"",7,"",13,""],["9a80","",4,"",7,"",7,"",6,"",4,"",4,"",7,"",6,"",4,"",4,""],["9b40","",4,""],["9b80","",5,"",4,"",4,"",5,""],["9c40","",7,""],["9c80","",7,"",7,"",10,"",14,"",4,"",6,"",5],["9d40","",7,"",4,"",9,"",6,""],["9d80","",9,"",5,"",6,"",12,"",4,"",10,"",5,"",5,"",6,"",10,""],["9e40","",7,"",32,"",7,"",6,"",6],["9e80","",9,"",17,"",13,"",11,"",12,"",12,""],["9f40","",6,"",10,"",4,"",10,"",7,""],["9f80","",13,"",12,"",4,"",4,"",5,"",4,"",4,"",6,"",5,"",8,"",9,"",4],["a040","",9,"",5,"",9,"",11,"",19],["a080","",9,"",6,"",4,"",11,"",11,"",6,""],["a1a1","",7,""],["a2a1","",9],["a2b1","",19,"",19,"",9],["a2e5","",9],["a2f1","",11],["a3a1","",88,""],["a4a1","",82],["a5a1","",85],["a6a1","",16,"",6],["a6c1","",16,"",6],["a6e0",""],["a6ee",""],["a6f4",""],["a7a1","",5,"",25],["a7d1","",5,"",25],["a840","",35,"",6],["a880","",7,""],["a8a1",""],["a8bd",""],["a8c0",""],["a8c5","",36],["a940","",8,""],["a959",""],["a95c",""],["a960","",9,"",8],["a980","",4,""],["a996",""],["a9a4","",75],["aa40","",5,"",5,"",8],["aa80","",7,"",10,""],["ab40","",11,"",4,"",5,"",4],["ab80","",6,"",4],["ac40","",10,"",8,"",5,"",4,"",11],["ac80","",6,"",12,"",4,""],["ad40","",10,"",7,"",15,"",12],["ad80","",9,"",8,"",6,""],["ae40","",6,"",7,"",4,""],["ae80","",7,"",6,"",4,""],["af40","",4,""],["af80",""],["b040","",6,"",5,"",4,"",6,"",7,""],["b080","",7,"",8,"",9,""],["b140","",4,"",7,"",10,""],["b180","",4,"",7,"",7,""],["b240","",11,"",5,"",11,"",4],["b280","",12,"",8,"",4,""],["b340","",5,""],["b380","",11,"",7,"",6,""],["b440","",7,"",9],["b480","",4,"",5,"",6,""],["b540","",5,"",9,"",4,"",14,"",4,"",8,""],["b580","",6,"",4,""],["b640","",6,"",11,"",10,"",4,"",5,""],["b680","",6,"",4,""],["b740","",14,"",5,"",9,"",4,"",16],["b780","",6,""],["b840","",4,"",10,"",10,"",9,"",5,""],["b880","",4,""],["b940","",5,"",10,"",6,""],["b980","",7,""],["ba40","",4,"",4,"",7,"",5,""],["ba80","",4,"",5,"",12,"",5,""],["bb40","",9,"",36,"",5,"",9],["bb80","",6,"",4,""],["bc40","",6,"",6,"",5,"",7,"",13,"",5],["bc80","",14,"",6,""],["bd40","",54,"",7],["bd80","",32,""],["be40","",12,"",6,"",42],["be80","",32,""],["bf40","",62],["bf80","",4,"",4,"",21,""],["c040","",35,"",23,""],["c080","",6,"",9,""],["c140","",4,"",7,"",4,"",4,"",6,""],["c180","",4,"",4,"",5,""],["c240","",6,"",5,""],["c280","",13,"",5,"",11,""],["c340","",5,"",4,"",6,""],["c380","",12,"",4,""],["c440","",5,"",4,"",4,"",5,"",4,""],["c480","",7,"",5,"",6,""],["c540","",14,"",4,"",5,"",4,"",5,""],["c580","",7,"",7,""],["c640",""],["c680","",4,"",9,""],["c740","",4,"",4,"",6,"",6,"",6,""],["c780",""],["c840","",4,"",5,"",5,"",7,"",5,"",7,""],["c880","",6,"",4,"",4,""],["c940","",4,"",7,"",12,""],["c980","",4,"",4,"",10,""],["ca40","",8,"",8,"",9,"",4,"",10],["ca80","",4,"",8,""],["cb40","",6,"",10,"",6,"",5,"",6,"",6,"",4,""],["cb80","",5,"",6,"",14,""],["cc40","",4,"",10,"",15,"",13,""],["cc80","",11,"",4,"",7,""],["cd40","",6,"",6,"",4,"",5,"",4,"",4,""],["cd80",""],["ce40","",6,"",5,"",7,""],["ce80","",4,"",6,"",4,""],["cf40","",4,"",4,"",6,"",9],["cf80","",5,"",7,"",4,""],["d040","",13,"",5,"",5,"",5,"",6,""],["d080","",4,"",4,"",5,""],["d140","",4,"",4,"",6,"",5],["d180","",4,"",4,"",4,""],["d240","",8,"",24,"",5,"",19,""],["d280","",26,""],["d340","",30,"",6],["d380","",4,"",5,"",21,""],["d440","",31,"",8,"",21],["d480","",25,"",6,""],["d540","",7,"",7,"",46],["d580","",32,""],["d640","",34,"",27],["d680","",30,""],["d740","",31,"",4,"",25],["d780","",24,""],["d840","",8,"",7,"",5,"",6,"",6,"",6,""],["d880","",6,"",20,""],["d940","",62],["d980","",32,""],["da40","",14,"",8,"",4,"",9,""],["da80","",12,""],["db40","",6,"",7,"",4,""],["db80","",4,"",5,"",11,""],["dc40","",4,"",6,"",6,"",11,"",6,"",7],["dc80","",10,"",21,""],["dd40","",62],["dd80","",32,""],["de40","",32,""],["de80","",4,""],["df40","",5,"",4,"",4,"",5,"",4,"",6,""],["df80","",4,""],["e040","",19,""],["e080","",10,"",6,"",8,""],["e140","",4,"",6,"",5,"",5,""],["e180","",10,"",9,"",8,""],["e240","",62],["e280","",32,"",5,""],["e340","",45,"",16],["e380","",7,"",24,""],["e440","",5,"",24,"",31],["e480","",32,""],["e540","",51,"",10],["e580","",31,""],["e640","",34,"",27],["e680","",29,""],["e740","",7,"",54],["e780","",32,"",6,"",4,""],["e840","",14,"",43,""],["e880","",20,""],["e940","",7,"",42],["e980","",32,""],["ea40","",27,"",6,""],["ea80","",4,"",12,""],["eb40","",9,"",7,"",9,"",6,""],["eb80","",4,""],["ec40","",8,"",4,"",18,"",7],["ec80","",4,"",7,"",4,"",4,""],["ed40","",6,"",46],["ed80","",4,"",23,""],["ee40","",62],["ee80","",32,"",4,"",6,""],["ef40","",5,"",37,"",4],["ef80","",30,"",4,"",8,""],["f040","",4,"",28,"",26],["f080","",9,"",12,"",4,"",6,""],["f140","",10,"",47],["f180","",32,""],["f240","",62],["f280","",32,""],["f340","",17,"",6,"",4,""],["f380","",8,"",6,""],["f440","",5,"",10,"",10,"",7,"",5],["f480","",32,""],["f540","",62],["f580","",32,""],["f640","",62],["f680","",32,"",5,"",5,"",4,"",7,""],["f740","",62],["f780","",4,"",4,""],["f840","",62],["f880","",32],["f940","",62],["f980","",32],["fa40","",62],["fa80","",32],["fb40","",27,"",9,""],["fb80","",5,"",8,"",5,""],["fc40","",8,"",4,"",8,"",6],["fc80","",4,"",5,"",8,""],["fd40","",4,"",4,"",10,"",38],["fd80","",5,"",11,"",4,""],["fe40",""]]');

/***/ }),

/***/ "(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/tables/cp949.json":
/*!**************************************************************************************!*\
  !*** ../node_modules/mailparser/node_modules/iconv-lite/encodings/tables/cp949.json ***!
  \**************************************************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('[["0","\\u0000",127],["8141","",4,"",6,""],["8161","",9,"",5,""],["8181","",18,"",4,"",6,"",5,"",6,"",7,"",7,"",4,"",4,""],["8241","",7,"",5],["8261","",6,"",5,""],["8281","",7,"",7,"",4,"",10,"",5,"",17,"",7,"",6,"",7,"",18],["8341","",5,"",5,"",7],["8361","",18,""],["8381","",4,"",6,"",5,"",5,"",46,"",6,"",5,"",8],["8441","",5,"",8],["8461","",18],["8481","",7,"",6,"",5,"",10,"",5,"",18,"",5,"",6,"",5,"",26,""],["8541","",5,"",4,"",6,"",4],["8561","",5,"",5,"",6,""],["8581","",6,"",6,"",9,"",26,"",29,"",6,"",5,""],["8641","",6,"",5,""],["8661","",6,"",10],["8681","",22,"",4,"",6,"",5,"",6,"",22,"",4,""],["8741","",9,"",15],["8761","",18,""],["8781","",5,"",7,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",4],["8841","",4,"",5,"",6,"",4],["8861","",4,""],["8881","",15,"",4,"",6,"",5,"",54,""],["8941","",6,"",5,""],["8961","",10,"",5,""],["8981","",21,"",18,"",18,"",6,"",6,"",7,"",15],["8a41","",10,"",6,""],["8a61","",4,"",18,""],["8a81","",4,"",19,"",5,"",7,"",5,"",6,"",5,"",4,"",5,"",26,""],["8b41","",5,"",4,"",6,""],["8b61","",6,"",8],["8b81","",52,"",4,"",6,"",5,"",18,"",18],["8c41","",15,"",4],["8c61","",6,"",5,"",6,"",5],["8c81","",12,"",26,"",50,"",5,"",16],["8d41","",16,"",8],["8d61","",17,""],["8d81","",4,"",33,"",6,"",7,"",6,"",9,"",6,"",5,"",6,""],["8e41","",6,"",5,"",8],["8e61","",4,"",19],["8e81","",13,"",6,"",4,"",6,"",5,"",6,"",5,"",11,"",7,"",6,"",5,"",7],["8f41","",7,"",17],["8f61","",7,"",6,"",4],["8f81","",5,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",5],["9041","",6,"",5,""],["9061","",5,"",15],["9081","",12,"",6,"",5,"",4,"",6,"",4,"",5,"",11,"",33,""],["9141","",6,"",5],["9161","",9,"",5],["9181","",20,"",4,"",5,"",14,"",33,"",7,"",5,"",6],["9241","",7,"",4,""],["9261","",7,"",7,"",4],["9281","",21,"",18,"",6,"",7,"",6,"",35,""],["9341","",4,""],["9361","",6,"",8],["9381","",37,"",4,"",4,"",6,"",5,"",7,"",22,""],["9441","",5,"",5,"",8],["9461","",5,"",6,"",12],["9481","",5,"",6,"",6,"",9,"",22,"",4,"",6,"",10,"",6,"",24],["9541","",11,"",5,""],["9561","",6,"",5,""],["9581","",6,"",35,"",4,"",4,"",4,"",6,"",5,"",13,"",14],["9641","",23,""],["9661","",6,"",5,"",8],["9681","",10,"",5,"",13,"",33,"",6,"",44],["9741","",16,"",8],["9761","",17,"",7],["9781","",11,"",5,"",6,"",89,""],["9841","",16,"",5,""],["9861","",6,"",15],["9881","",21,"",6,"",5,"",4,"",6,"",5,"",6,"",5,"",6,"",5,""],["9941","",6,"",5,""],["9961","",6,"",5,""],["9981","",8,"",5,"",4,"",11,"",5,"",6,"",6,"",6,"",7,"",6,"",5,""],["9a41","",16],["9a61","",6,"",6,""],["9a81","",4,"",6,"",5,"",5,"",6,"",5,"",5,"",33,"",5,"",6,""],["9b41","",6,"",8],["9b61","",17,"",7],["9b81","",25,"",4,"",5,"",50,"",22,""],["9c41","",4,"",5,"",5],["9c61","",8,"",6,"",9],["9c81","",8,"",6,"",6,"",9,"",26,"",6,"",5,"",18,"",6,"",12],["9d41","",13,"",8],["9d61","",25],["9d81","",8,"",5,"",9,"",6,"",10,"",6,"",5,"",6,"",5,""],["9e41","",7,"",9,""],["9e61","",4,"",6,""],["9e81","",6,"",6,"",6,"",5,"",10,"",5,"",6,"",5,"",6,""],["9f41","",5,"",4,"",5,""],["9f61","",6,"",5,""],["9f81","",4,"",5,"",6,"",5,"",6,"",4,"",6,"",7,"",4,"",4,""],["a041","",5,"",6,""],["a061","",5,"",13],["a081","",4,"",4,"",4,"",6,"",5,"",6,"",5,"",26,"",4,"",5,"",7,""],["a141","",18,""],["a161","",6,"",5,""],["a181","",14,"",5,"",4,"",9,""],["a241","",5,"",18],["a261","",6,"",18],["a281","",7,"",6,"",7,""],["a341","",6,"",10,""],["a361","",6,"",16],["a381","",16,"",4,"",58,"",32,""],["a441","",5,""],["a461","",5,"",12],["a481","",28,"",93],["a541","",4,"",6,"",5,""],["a561","",17,"",5,""],["a581","",16,"",14,"",9],["a5b0","",9],["a5c1","",16,"",6],["a5e1","",16,"",6],["a641","",19,""],["a661","",5,"",5,"",6],["a681","",6,"",18,"",7],["a741","",4,"",6,"",7],["a761","",22,""],["a781","",6,"",5,"",7,"",9,"",9,"",4,"",5,"",4,""],["a841","",10,"",14],["a861","",18,"",6],["a881","",19,"",11,""],["a8a6",""],["a8a8",""],["a8b1","",27,"",25,"",14,""],["a941","",14,"",10],["a961","",18],["a981","",14,"",6,"",27,"",25,"",14,""],["aa41","",6,"",4,""],["aa61","",4,"",5,"",6,""],["aa81","",29,"",82],["ab41","",6,"",5,""],["ab61","",6,"",5,"",5],["ab81","",8,"",6,"",12,"",85],["ac41","",5,"",6,""],["ac61","",11,"",4],["ac81","",28,"",5,"",25],["acd1","",5,"",25],["ad41","",6,"",5,"",7],["ad61","",6,"",10,""],["ad81","",5,"",18,""],["ae41","",5,"",16],["ae61","",5,"",6,"",4],["ae81","",6,"",5,""],["af41","",19],["af61","",13,"",5,""],["af81","",5,"",6,"",5,""],["b041","",5,"",5,"",12],["b061","",5,"",19],["b081","",13,"",6,"",5,"",7,"",4,""],["b141","",6,"",5,""],["b161","",6,"",5,"",11],["b181","",14,"",6,""],["b241","",6,"",5,""],["b261","",18,"",5,""],["b281","",5,"",18,"",6,""],["b341","",19,""],["b361","",5,"",5,"",5],["b381","",5,"",5,"",19,"",4,""],["b441","",5,"",6,"",5],["b461","",6,"",10,""],["b481","",6,"",18,"",4,"",4,""],["b541","",14,"",5],["b561","",5,"",5,"",4],["b581","",6,"",5,"",11,""],["b641","",7,"",17],["b661","",15,""],["b681","",5,"",6,"",5,""],["b741","",13,"",6,""],["b761","",20,""],["b781","",6,"",14,""],["b841","",7,"",17],["b861","",8,"",13],["b881","",5,"",24,"",4,""],["b941","",6,"",5,""],["b961","",14,"",6,""],["b981","",22,"",4,"",4,""],["ba41","",5,"",6,""],["ba61","",5,"",4,"",5],["ba81","",6,"",9,""],["bb41","",4,"",5,"",4,""],["bb61","",6,"",5,""],["bb81","",31,""],["bc41","",17,""],["bc61","",5,"",6,""],["bc81","",4,"",6,"",5,"",5,"",4,""],["bd41","",7,"",7,""],["bd61","",5,"",13],["bd81","",5,"",25,""],["be41","",7,"",14],["be61","",7,"",7,""],["be81","",4,"",4,"",5,"",8,"",6,""],["bf41","",10,"",14],["bf61","",18,""],["bf81","",5,"",7,"",6,"",5,""],["c041","",5,"",6,"",5],["c061","",25],["c081","",6,"",5,"",7,""],["c141","",5,"",6,""],["c161","",19,""],["c181","",31,""],["c241","",4,"",5,""],["c261","",4,"",5,"",6,""],["c281","",5,"",7,"",9,""],["c341","",4],["c361","",4,"",5,"",11],["c381","",5,"",7,"",5,""],["c441","",7,"",7,""],["c461","",5,"",4],["c481","",5,"",11,""],["c541","",6,"",5,""],["c561","",6,"",5,"",4],["c581","",6,"",5,""],["c641","",6,"",5],["c6a1",""],["c7a1",""],["c8a1",""],["caa1",""],["cba1",""],["cca1",""],["cda1",""],["cea1",""],["cfa1",""],["d0a1",""],["d1a1","",5,"",4,""],["d2a1","",4,"",5,"",10,"",7,"",5,""],["d3a1",""],["d4a1",""],["d5a1",""],["d6a1",""],["d7a1",""],["d8a1",""],["d9a1",""],["daa1",""],["dba1",""],["dca1",""],["dda1",""],["dea1",""],["dfa1",""],["e0a1",""],["e1a1",""],["e2a1",""],["e3a1",""],["e4a1",""],["e5a1",""],["e6a1",""],["e7a1",""],["e8a1",""],["e9a1",""],["eaa1",""],["eba1",""],["eca1",""],["eda1",""],["eea1",""],["efa1",""],["f0a1",""],["f1a1",""],["f2a1",""],["f3a1",""],["f4a1",""],["f5a1",""],["f6a1",""],["f7a1",""],["f8a1",""],["f9a1",""],["faa1",""],["fba1",""],["fca1",""],["fda1",""]]');

/***/ }),

/***/ "(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/tables/cp950.json":
/*!**************************************************************************************!*\
  !*** ../node_modules/mailparser/node_modules/iconv-lite/encodings/tables/cp950.json ***!
  \**************************************************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('[["0","\\u0000",127],["a140",""],["a1a1","",4,""],["a240","",7,""],["a2a1","",9,"",9,"",8,"",25,"",21],["a340","",16,"",6,"",16,"",6,"",10],["a3a1","",25,""],["a3e1",""],["a440",""],["a4a1",""],["a540",""],["a5a1",""],["a640",""],["a6a1",""],["a740",""],["a7a1",""],["a840",""],["a8a1",""],["a940",""],["a9a1",""],["aa40",""],["aaa1",""],["ab40",""],["aba1",""],["ac40",""],["aca1",""],["ad40",""],["ada1",""],["ae40",""],["aea1",""],["af40",""],["afa1",""],["b040",""],["b0a1",""],["b140",""],["b1a1",""],["b240",""],["b2a1",""],["b340",""],["b3a1",""],["b440",""],["b4a1",""],["b540",""],["b5a1",""],["b640",""],["b6a1",""],["b740",""],["b7a1",""],["b840",""],["b8a1",""],["b940",""],["b9a1",""],["ba40",""],["baa1",""],["bb40",""],["bba1",""],["bc40",""],["bca1",""],["bd40",""],["bda1",""],["be40",""],["bea1",""],["bf40",""],["bfa1",""],["c040",""],["c0a1",""],["c140",""],["c1a1",""],["c240",""],["c2a1",""],["c340",""],["c3a1",""],["c440",""],["c4a1",""],["c540",""],["c5a1",""],["c640",""],["c940",""],["c9a1",""],["ca40",""],["caa1",""],["cb40",""],["cba1",""],["cc40",""],["cca1",""],["cd40",""],["cda1",""],["ce40",""],["cea1",""],["cf40",""],["cfa1",""],["d040",""],["d0a1",""],["d140",""],["d1a1",""],["d240",""],["d2a1",""],["d340",""],["d3a1",""],["d440",""],["d4a1",""],["d540",""],["d5a1",""],["d640",""],["d6a1",""],["d740",""],["d7a1",""],["d840",""],["d8a1",""],["d940",""],["d9a1",""],["da40",""],["daa1",""],["db40",""],["dba1",""],["dc40",""],["dca1",""],["dd40",""],["dda1",""],["de40",""],["dea1",""],["df40",""],["dfa1",""],["e040",""],["e0a1",""],["e140",""],["e1a1",""],["e240",""],["e2a1",""],["e340",""],["e3a1",""],["e440",""],["e4a1",""],["e540",""],["e5a1",""],["e640",""],["e6a1",""],["e740",""],["e7a1",""],["e840",""],["e8a1",""],["e940",""],["e9a1",""],["ea40",""],["eaa1",""],["eb40",""],["eba1",""],["ec40",""],["eca1",""],["ed40",""],["eda1",""],["ee40",""],["eea1",""],["ef40",""],["efa1",""],["f040",""],["f0a1",""],["f140",""],["f1a1",""],["f240",""],["f2a1",""],["f340",""],["f3a1",""],["f440",""],["f4a1",""],["f540",""],["f5a1",""],["f640",""],["f6a1",""],["f740",""],["f7a1",""],["f840",""],["f8a1",""],["f940",""],["f9a1",""]]');

/***/ }),

/***/ "(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/tables/eucjp.json":
/*!**************************************************************************************!*\
  !*** ../node_modules/mailparser/node_modules/iconv-lite/encodings/tables/eucjp.json ***!
  \**************************************************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('[["0","\\u0000",127],["8ea1","",62],["a1a1","",9,""],["a2a1",""],["a2ba",""],["a2ca",""],["a2dc",""],["a2f2",""],["a2fe",""],["a3b0","",9],["a3c1","",25],["a3e1","",25],["a4a1","",82],["a5a1","",85],["a6a1","",16,"",6],["a6c1","",16,"",6],["a7a1","",5,"",25],["a7d1","",5,"",25],["a8a1",""],["ada1","",19,"",9],["adc0",""],["addf","",4,""],["b0a1",""],["b1a1",""],["b2a1",""],["b3a1",""],["b4a1",""],["b5a1",""],["b6a1",""],["b7a1",""],["b8a1",""],["b9a1",""],["baa1",""],["bba1",""],["bca1",""],["bda1",""],["bea1",""],["bfa1",""],["c0a1",""],["c1a1",""],["c2a1",""],["c3a1",""],["c4a1",""],["c5a1",""],["c6a1",""],["c7a1",""],["c8a1",""],["c9a1",""],["caa1",""],["cba1",""],["cca1",""],["cda1",""],["cea1",""],["cfa1",""],["d0a1",""],["d1a1",""],["d2a1",""],["d3a1",""],["d4a1",""],["d5a1",""],["d6a1",""],["d7a1",""],["d8a1",""],["d9a1",""],["daa1",""],["dba1",""],["dca1",""],["dda1",""],["dea1",""],["dfa1",""],["e0a1",""],["e1a1",""],["e2a1",""],["e3a1",""],["e4a1",""],["e5a1",""],["e6a1",""],["e7a1",""],["e8a1",""],["e9a1",""],["eaa1",""],["eba1",""],["eca1",""],["eda1",""],["eea1",""],["efa1",""],["f0a1",""],["f1a1",""],["f2a1",""],["f3a1",""],["f4a1",""],["f9a1",""],["faa1",""],["fba1",""],["fca1",""],["fcf1","",9,""],["8fa2af",""],["8fa2c2",""],["8fa2eb",""],["8fa6e1",""],["8fa6e7",""],["8fa6e9",""],["8fa6ec",""],["8fa6f1",""],["8fa7c2","",10,""],["8fa7f2","",10,""],["8fa9a1",""],["8fa9a4",""],["8fa9a6",""],["8fa9a8",""],["8fa9ab",""],["8fa9af",""],["8fa9c1",""],["8faaa1",""],["8faaba",""],["8faba1",""],["8fabbd",""],["8fabc5",""],["8fb0a1",""],["8fb1a1",""],["8fb2a1","",4,""],["8fb3a1",""],["8fb4a1",""],["8fb5a1",""],["8fb6a1","",5,"",4,""],["8fb7a1","",4,""],["8fb8a1",""],["8fb9a1",""],["8fbaa1","",4,""],["8fbba1",""],["8fbca1","",4,""],["8fbda1","",4,""],["8fbea1","",4,""],["8fbfa1",""],["8fc0a1",""],["8fc1a1",""],["8fc2a1",""],["8fc3a1","",4,""],["8fc4a1",""],["8fc5a1",""],["8fc6a1",""],["8fc7a1",""],["8fc8a1",""],["8fc9a1","",4,"",4,""],["8fcaa1",""],["8fcba1",""],["8fcca1","",9,""],["8fcda1","",5,""],["8fcea1","",6,""],["8fcfa1",""],["8fd0a1",""],["8fd1a1",""],["8fd2a1","",5],["8fd3a1",""],["8fd4a1","",4,""],["8fd5a1",""],["8fd6a1",""],["8fd7a1",""],["8fd8a1",""],["8fd9a1","",4,"",6,""],["8fdaa1","",4,""],["8fdba1","",6,""],["8fdca1","",4,""],["8fdda1","",4,""],["8fdea1","",4,""],["8fdfa1",""],["8fe0a1",""],["8fe1a1","",4,""],["8fe2a1",""],["8fe3a1","",5,"",4,""],["8fe4a1","",4,""],["8fe5a1","",4,""],["8fe6a1",""],["8fe7a1",""],["8fe8a1","",4,""],["8fe9a1","",4],["8feaa1","",4,""],["8feba1","",4,""],["8feca1",""],["8feda1","",4,"",4,""]]');

/***/ }),

/***/ "(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/tables/gb18030-ranges.json":
/*!***********************************************************************************************!*\
  !*** ../node_modules/mailparser/node_modules/iconv-lite/encodings/tables/gb18030-ranges.json ***!
  \***********************************************************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"uChars":[128,165,169,178,184,216,226,235,238,244,248,251,253,258,276,284,300,325,329,334,364,463,465,467,469,471,473,475,477,506,594,610,712,716,730,930,938,962,970,1026,1104,1106,8209,8215,8218,8222,8231,8241,8244,8246,8252,8365,8452,8454,8458,8471,8482,8556,8570,8596,8602,8713,8720,8722,8726,8731,8737,8740,8742,8748,8751,8760,8766,8777,8781,8787,8802,8808,8816,8854,8858,8870,8896,8979,9322,9372,9548,9588,9616,9622,9634,9652,9662,9672,9676,9680,9702,9735,9738,9793,9795,11906,11909,11913,11917,11928,11944,11947,11951,11956,11960,11964,11979,12284,12292,12312,12319,12330,12351,12436,12447,12535,12543,12586,12842,12850,12964,13200,13215,13218,13253,13263,13267,13270,13384,13428,13727,13839,13851,14617,14703,14801,14816,14964,15183,15471,15585,16471,16736,17208,17325,17330,17374,17623,17997,18018,18212,18218,18301,18318,18760,18811,18814,18820,18823,18844,18848,18872,19576,19620,19738,19887,40870,59244,59336,59367,59413,59417,59423,59431,59437,59443,59452,59460,59478,59493,63789,63866,63894,63976,63986,64016,64018,64021,64025,64034,64037,64042,65074,65093,65107,65112,65127,65132,65375,65510,65536],"gbChars":[0,36,38,45,50,81,89,95,96,100,103,104,105,109,126,133,148,172,175,179,208,306,307,308,309,310,311,312,313,341,428,443,544,545,558,741,742,749,750,805,819,820,7922,7924,7925,7927,7934,7943,7944,7945,7950,8062,8148,8149,8152,8164,8174,8236,8240,8262,8264,8374,8380,8381,8384,8388,8390,8392,8393,8394,8396,8401,8406,8416,8419,8424,8437,8439,8445,8482,8485,8496,8521,8603,8936,8946,9046,9050,9063,9066,9076,9092,9100,9108,9111,9113,9131,9162,9164,9218,9219,11329,11331,11334,11336,11346,11361,11363,11366,11370,11372,11375,11389,11682,11686,11687,11692,11694,11714,11716,11723,11725,11730,11736,11982,11989,12102,12336,12348,12350,12384,12393,12395,12397,12510,12553,12851,12962,12973,13738,13823,13919,13933,14080,14298,14585,14698,15583,15847,16318,16434,16438,16481,16729,17102,17122,17315,17320,17402,17418,17859,17909,17911,17915,17916,17936,17939,17961,18664,18703,18814,18962,19043,33469,33470,33471,33484,33485,33490,33497,33501,33505,33513,33520,33536,33550,37845,37921,37948,38029,38038,38064,38065,38066,38069,38075,38076,38078,39108,39109,39113,39114,39115,39116,39265,39394,189000]}');

/***/ }),

/***/ "(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/tables/gbk-added.json":
/*!******************************************************************************************!*\
  !*** ../node_modules/mailparser/node_modules/iconv-lite/encodings/tables/gbk-added.json ***!
  \******************************************************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('[["a140","",62],["a180","",32],["a240","",62],["a280","",32],["a2ab","",5],["a2e3",""],["a2ef",""],["a2fd",""],["a340","",62],["a380","",31,""],["a440","",62],["a480","",32],["a4f4","",10],["a540","",62],["a580","",32],["a5f7","",7],["a640","",62],["a680","",32],["a6b9","",7],["a6d9","",6],["a6ec",""],["a6f3",""],["a6f6","",8],["a740","",62],["a780","",32],["a7c2","",14],["a7f2","",12],["a896","",10],["a8bc",""],["a8bf",""],["a8c1",""],["a8ea","",20],["a958",""],["a95b",""],["a95d",""],["a989","",11],["a997","",12],["a9f0","",14],["aaa1","",93],["aba1","",93],["aca1","",93],["ada1","",93],["aea1","",93],["afa1","",93],["d7fa","",4],["f8a1","",93],["f9a1","",93],["faa1","",93],["fba1","",93],["fca1","",93],["fda1","",93],["fe50",""],["fe80","",6,"",93],["8135f437",""]]');

/***/ }),

/***/ "(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/tables/shiftjis.json":
/*!*****************************************************************************************!*\
  !*** ../node_modules/mailparser/node_modules/iconv-lite/encodings/tables/shiftjis.json ***!
  \*****************************************************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('[["0","\\u0000",128],["a1","",62],["8140","",9,""],["8180",""],["81b8",""],["81c8",""],["81da",""],["81f0",""],["81fc",""],["824f","",9],["8260","",25],["8281","",25],["829f","",82],["8340","",62],["8380","",22],["839f","",16,"",6],["83bf","",16,"",6],["8440","",5,"",25],["8470","",5,"",7],["8480","",17],["849f",""],["8740","",19,"",9],["875f",""],["877e",""],["8780","",4,""],["889f",""],["8940",""],["8980",""],["8a40",""],["8a80",""],["8b40",""],["8b80",""],["8c40",""],["8c80",""],["8d40",""],["8d80",""],["8e40",""],["8e80",""],["8f40",""],["8f80",""],["9040",""],["9080",""],["9140",""],["9180",""],["9240",""],["9280",""],["9340",""],["9380",""],["9440",""],["9480",""],["9540",""],["9580",""],["9640",""],["9680",""],["9740",""],["9780",""],["9840",""],["989f",""],["9940",""],["9980",""],["9a40",""],["9a80",""],["9b40",""],["9b80",""],["9c40",""],["9c80",""],["9d40",""],["9d80",""],["9e40",""],["9e80",""],["9f40",""],["9f80",""],["e040",""],["e080",""],["e140",""],["e180",""],["e240",""],["e280",""],["e340",""],["e380",""],["e440",""],["e480",""],["e540",""],["e580",""],["e640",""],["e680",""],["e740",""],["e780",""],["e840",""],["e880",""],["e940",""],["e980",""],["ea40",""],["ea80",""],["ed40",""],["ed80",""],["ee40",""],["ee80",""],["eeef","",9,""],["f040","",62],["f080","",124],["f140","",62],["f180","",124],["f240","",62],["f280","",124],["f340","",62],["f380","",124],["f440","",62],["f480","",124],["f540","",62],["f580","",124],["f640","",62],["f680","",124],["f740","",62],["f780","",124],["f840","",62],["f880","",124],["f940",""],["fa40","",9,"",9,""],["fa80",""],["fb40",""],["fb80",""],["fc40",""]]');

/***/ }),

/***/ "(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/utf16.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/mailparser/node_modules/iconv-lite/encodings/utf16.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(rsc)/../node_modules/safer-buffer/safer.js\").Buffer)\n\n// Note: UTF16-LE (or UCS2) codec is Node.js native. See encodings/internal.js\n\n// == UTF16-BE codec. ==========================================================\n\nexports.utf16be = Utf16BECodec\nfunction Utf16BECodec () {\n}\n\nUtf16BECodec.prototype.encoder = Utf16BEEncoder\nUtf16BECodec.prototype.decoder = Utf16BEDecoder\nUtf16BECodec.prototype.bomAware = true\n\n// -- Encoding\n\nfunction Utf16BEEncoder () {\n}\n\nUtf16BEEncoder.prototype.write = function (str) {\n  var buf = Buffer.from(str, \"ucs2\")\n  for (var i = 0; i < buf.length; i += 2) {\n    var tmp = buf[i]; buf[i] = buf[i + 1]; buf[i + 1] = tmp\n  }\n  return buf\n}\n\nUtf16BEEncoder.prototype.end = function () {\n}\n\n// -- Decoding\n\nfunction Utf16BEDecoder () {\n  this.overflowByte = -1\n}\n\nUtf16BEDecoder.prototype.write = function (buf) {\n  if (buf.length == 0) { return \"\" }\n\n  var buf2 = Buffer.alloc(buf.length + 1)\n  var i = 0; var j = 0\n\n  if (this.overflowByte !== -1) {\n    buf2[0] = buf[0]\n    buf2[1] = this.overflowByte\n    i = 1; j = 2\n  }\n\n  for (; i < buf.length - 1; i += 2, j += 2) {\n    buf2[j] = buf[i + 1]\n    buf2[j + 1] = buf[i]\n  }\n\n  this.overflowByte = (i == buf.length - 1) ? buf[buf.length - 1] : -1\n\n  return buf2.slice(0, j).toString(\"ucs2\")\n}\n\nUtf16BEDecoder.prototype.end = function () {\n  this.overflowByte = -1\n}\n\n// == UTF-16 codec =============================================================\n// Decoder chooses automatically from UTF-16LE and UTF-16BE using BOM and space-based heuristic.\n// Defaults to UTF-16LE, as it's prevalent and default in Node.\n// http://en.wikipedia.org/wiki/UTF-16 and http://encoding.spec.whatwg.org/#utf-16le\n// Decoder default can be changed: iconv.decode(buf, 'utf16', {defaultEncoding: 'utf-16be'});\n\n// Encoder uses UTF-16LE and prepends BOM (which can be overridden with addBOM: false).\n\nexports.utf16 = Utf16Codec\nfunction Utf16Codec (codecOptions, iconv) {\n  this.iconv = iconv\n}\n\nUtf16Codec.prototype.encoder = Utf16Encoder\nUtf16Codec.prototype.decoder = Utf16Decoder\n\n// -- Encoding (pass-through)\n\nfunction Utf16Encoder (options, codec) {\n  options = options || {}\n  if (options.addBOM === undefined) { options.addBOM = true }\n  this.encoder = codec.iconv.getEncoder(\"utf-16le\", options)\n}\n\nUtf16Encoder.prototype.write = function (str) {\n  return this.encoder.write(str)\n}\n\nUtf16Encoder.prototype.end = function () {\n  return this.encoder.end()\n}\n\n// -- Decoding\n\nfunction Utf16Decoder (options, codec) {\n  this.decoder = null\n  this.initialBufs = []\n  this.initialBufsLen = 0\n\n  this.options = options || {}\n  this.iconv = codec.iconv\n}\n\nUtf16Decoder.prototype.write = function (buf) {\n  if (!this.decoder) {\n    // Codec is not chosen yet. Accumulate initial bytes.\n    this.initialBufs.push(buf)\n    this.initialBufsLen += buf.length\n\n    if (this.initialBufsLen < 16) // We need more bytes to use space heuristic (see below)\n    { return \"\" }\n\n    // We have enough bytes -> detect endianness.\n    var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding)\n    this.decoder = this.iconv.getDecoder(encoding, this.options)\n\n    var resStr = \"\"\n    for (var i = 0; i < this.initialBufs.length; i++) { resStr += this.decoder.write(this.initialBufs[i]) }\n\n    this.initialBufs.length = this.initialBufsLen = 0\n    return resStr\n  }\n\n  return this.decoder.write(buf)\n}\n\nUtf16Decoder.prototype.end = function () {\n  if (!this.decoder) {\n    var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding)\n    this.decoder = this.iconv.getDecoder(encoding, this.options)\n\n    var resStr = \"\"\n    for (var i = 0; i < this.initialBufs.length; i++) { resStr += this.decoder.write(this.initialBufs[i]) }\n\n    var trail = this.decoder.end()\n    if (trail) { resStr += trail }\n\n    this.initialBufs.length = this.initialBufsLen = 0\n    return resStr\n  }\n  return this.decoder.end()\n}\n\nfunction detectEncoding (bufs, defaultEncoding) {\n  var b = []\n  var charsProcessed = 0\n  // Number of ASCII chars when decoded as LE or BE.\n  var asciiCharsLE = 0\n  var asciiCharsBE = 0\n\n  outerLoop:\n  for (var i = 0; i < bufs.length; i++) {\n    var buf = bufs[i]\n    for (var j = 0; j < buf.length; j++) {\n      b.push(buf[j])\n      if (b.length === 2) {\n        if (charsProcessed === 0) {\n          // Check BOM first.\n          if (b[0] === 0xFF && b[1] === 0xFE) return \"utf-16le\"\n          if (b[0] === 0xFE && b[1] === 0xFF) return \"utf-16be\"\n        }\n\n        if (b[0] === 0 && b[1] !== 0) asciiCharsBE++\n        if (b[0] !== 0 && b[1] === 0) asciiCharsLE++\n\n        b.length = 0\n        charsProcessed++\n\n        if (charsProcessed >= 100) {\n          break outerLoop\n        }\n      }\n    }\n  }\n\n  // Make decisions.\n  // Most of the time, the content has ASCII chars (U+00**), but the opposite (U+**00) is uncommon.\n  // So, we count ASCII as if it was LE or BE, and decide from that.\n  if (asciiCharsBE > asciiCharsLE) return \"utf-16be\"\n  if (asciiCharsBE < asciiCharsLE) return \"utf-16le\"\n\n  // Couldn't decide (likely all zeros or not enough data).\n  return defaultEncoding || \"utf-16le\"\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL21haWxwYXJzZXIvbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvZW5jb2RpbmdzL3V0ZjE2LmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1osYUFBYSwrRkFBOEI7O0FBRTNDOztBQUVBOztBQUVBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBLFNBQVMsb0JBQW9CO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCw0QkFBNEI7O0FBRTNGOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLDZCQUE2QixPQUFPOztBQUV4RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQiw2QkFBNkIsT0FBTzs7QUFFeEQ7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxrZnJ5dFxcLmdlbWluaVxcYW50aWdyYXZpdHlcXHNjcmF0Y2hcXGRyX2thbHNfdmlydHVhbF9ob3NwaXRhbFxcbm9kZV9tb2R1bGVzXFxtYWlscGFyc2VyXFxub2RlX21vZHVsZXNcXGljb252LWxpdGVcXGVuY29kaW5nc1xcdXRmMTYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCJcbnZhciBCdWZmZXIgPSByZXF1aXJlKFwic2FmZXItYnVmZmVyXCIpLkJ1ZmZlclxuXG4vLyBOb3RlOiBVVEYxNi1MRSAob3IgVUNTMikgY29kZWMgaXMgTm9kZS5qcyBuYXRpdmUuIFNlZSBlbmNvZGluZ3MvaW50ZXJuYWwuanNcblxuLy8gPT0gVVRGMTYtQkUgY29kZWMuID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0cy51dGYxNmJlID0gVXRmMTZCRUNvZGVjXG5mdW5jdGlvbiBVdGYxNkJFQ29kZWMgKCkge1xufVxuXG5VdGYxNkJFQ29kZWMucHJvdG90eXBlLmVuY29kZXIgPSBVdGYxNkJFRW5jb2RlclxuVXRmMTZCRUNvZGVjLnByb3RvdHlwZS5kZWNvZGVyID0gVXRmMTZCRURlY29kZXJcblV0ZjE2QkVDb2RlYy5wcm90b3R5cGUuYm9tQXdhcmUgPSB0cnVlXG5cbi8vIC0tIEVuY29kaW5nXG5cbmZ1bmN0aW9uIFV0ZjE2QkVFbmNvZGVyICgpIHtcbn1cblxuVXRmMTZCRUVuY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHN0cikge1xuICB2YXIgYnVmID0gQnVmZmVyLmZyb20oc3RyLCBcInVjczJcIilcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgdG1wID0gYnVmW2ldOyBidWZbaV0gPSBidWZbaSArIDFdOyBidWZbaSArIDFdID0gdG1wXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5VdGYxNkJFRW5jb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xufVxuXG4vLyAtLSBEZWNvZGluZ1xuXG5mdW5jdGlvbiBVdGYxNkJFRGVjb2RlciAoKSB7XG4gIHRoaXMub3ZlcmZsb3dCeXRlID0gLTFcbn1cblxuVXRmMTZCRURlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAoYnVmLmxlbmd0aCA9PSAwKSB7IHJldHVybiBcIlwiIH1cblxuICB2YXIgYnVmMiA9IEJ1ZmZlci5hbGxvYyhidWYubGVuZ3RoICsgMSlcbiAgdmFyIGkgPSAwOyB2YXIgaiA9IDBcblxuICBpZiAodGhpcy5vdmVyZmxvd0J5dGUgIT09IC0xKSB7XG4gICAgYnVmMlswXSA9IGJ1ZlswXVxuICAgIGJ1ZjJbMV0gPSB0aGlzLm92ZXJmbG93Qnl0ZVxuICAgIGkgPSAxOyBqID0gMlxuICB9XG5cbiAgZm9yICg7IGkgPCBidWYubGVuZ3RoIC0gMTsgaSArPSAyLCBqICs9IDIpIHtcbiAgICBidWYyW2pdID0gYnVmW2kgKyAxXVxuICAgIGJ1ZjJbaiArIDFdID0gYnVmW2ldXG4gIH1cblxuICB0aGlzLm92ZXJmbG93Qnl0ZSA9IChpID09IGJ1Zi5sZW5ndGggLSAxKSA/IGJ1ZltidWYubGVuZ3RoIC0gMV0gOiAtMVxuXG4gIHJldHVybiBidWYyLnNsaWNlKDAsIGopLnRvU3RyaW5nKFwidWNzMlwiKVxufVxuXG5VdGYxNkJFRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLm92ZXJmbG93Qnl0ZSA9IC0xXG59XG5cbi8vID09IFVURi0xNiBjb2RlYyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBEZWNvZGVyIGNob29zZXMgYXV0b21hdGljYWxseSBmcm9tIFVURi0xNkxFIGFuZCBVVEYtMTZCRSB1c2luZyBCT00gYW5kIHNwYWNlLWJhc2VkIGhldXJpc3RpYy5cbi8vIERlZmF1bHRzIHRvIFVURi0xNkxFLCBhcyBpdCdzIHByZXZhbGVudCBhbmQgZGVmYXVsdCBpbiBOb2RlLlxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VVEYtMTYgYW5kIGh0dHA6Ly9lbmNvZGluZy5zcGVjLndoYXR3Zy5vcmcvI3V0Zi0xNmxlXG4vLyBEZWNvZGVyIGRlZmF1bHQgY2FuIGJlIGNoYW5nZWQ6IGljb252LmRlY29kZShidWYsICd1dGYxNicsIHtkZWZhdWx0RW5jb2Rpbmc6ICd1dGYtMTZiZSd9KTtcblxuLy8gRW5jb2RlciB1c2VzIFVURi0xNkxFIGFuZCBwcmVwZW5kcyBCT00gKHdoaWNoIGNhbiBiZSBvdmVycmlkZGVuIHdpdGggYWRkQk9NOiBmYWxzZSkuXG5cbmV4cG9ydHMudXRmMTYgPSBVdGYxNkNvZGVjXG5mdW5jdGlvbiBVdGYxNkNvZGVjIChjb2RlY09wdGlvbnMsIGljb252KSB7XG4gIHRoaXMuaWNvbnYgPSBpY29udlxufVxuXG5VdGYxNkNvZGVjLnByb3RvdHlwZS5lbmNvZGVyID0gVXRmMTZFbmNvZGVyXG5VdGYxNkNvZGVjLnByb3RvdHlwZS5kZWNvZGVyID0gVXRmMTZEZWNvZGVyXG5cbi8vIC0tIEVuY29kaW5nIChwYXNzLXRocm91Z2gpXG5cbmZ1bmN0aW9uIFV0ZjE2RW5jb2RlciAob3B0aW9ucywgY29kZWMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgaWYgKG9wdGlvbnMuYWRkQk9NID09PSB1bmRlZmluZWQpIHsgb3B0aW9ucy5hZGRCT00gPSB0cnVlIH1cbiAgdGhpcy5lbmNvZGVyID0gY29kZWMuaWNvbnYuZ2V0RW5jb2RlcihcInV0Zi0xNmxlXCIsIG9wdGlvbnMpXG59XG5cblV0ZjE2RW5jb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiB0aGlzLmVuY29kZXIud3JpdGUoc3RyKVxufVxuXG5VdGYxNkVuY29kZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZW5jb2Rlci5lbmQoKVxufVxuXG4vLyAtLSBEZWNvZGluZ1xuXG5mdW5jdGlvbiBVdGYxNkRlY29kZXIgKG9wdGlvbnMsIGNvZGVjKSB7XG4gIHRoaXMuZGVjb2RlciA9IG51bGxcbiAgdGhpcy5pbml0aWFsQnVmcyA9IFtdXG4gIHRoaXMuaW5pdGlhbEJ1ZnNMZW4gPSAwXG5cbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICB0aGlzLmljb252ID0gY29kZWMuaWNvbnZcbn1cblxuVXRmMTZEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKCF0aGlzLmRlY29kZXIpIHtcbiAgICAvLyBDb2RlYyBpcyBub3QgY2hvc2VuIHlldC4gQWNjdW11bGF0ZSBpbml0aWFsIGJ5dGVzLlxuICAgIHRoaXMuaW5pdGlhbEJ1ZnMucHVzaChidWYpXG4gICAgdGhpcy5pbml0aWFsQnVmc0xlbiArPSBidWYubGVuZ3RoXG5cbiAgICBpZiAodGhpcy5pbml0aWFsQnVmc0xlbiA8IDE2KSAvLyBXZSBuZWVkIG1vcmUgYnl0ZXMgdG8gdXNlIHNwYWNlIGhldXJpc3RpYyAoc2VlIGJlbG93KVxuICAgIHsgcmV0dXJuIFwiXCIgfVxuXG4gICAgLy8gV2UgaGF2ZSBlbm91Z2ggYnl0ZXMgLT4gZGV0ZWN0IGVuZGlhbm5lc3MuXG4gICAgdmFyIGVuY29kaW5nID0gZGV0ZWN0RW5jb2RpbmcodGhpcy5pbml0aWFsQnVmcywgdGhpcy5vcHRpb25zLmRlZmF1bHRFbmNvZGluZylcbiAgICB0aGlzLmRlY29kZXIgPSB0aGlzLmljb252LmdldERlY29kZXIoZW5jb2RpbmcsIHRoaXMub3B0aW9ucylcblxuICAgIHZhciByZXNTdHIgPSBcIlwiXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluaXRpYWxCdWZzLmxlbmd0aDsgaSsrKSB7IHJlc1N0ciArPSB0aGlzLmRlY29kZXIud3JpdGUodGhpcy5pbml0aWFsQnVmc1tpXSkgfVxuXG4gICAgdGhpcy5pbml0aWFsQnVmcy5sZW5ndGggPSB0aGlzLmluaXRpYWxCdWZzTGVuID0gMFxuICAgIHJldHVybiByZXNTdHJcbiAgfVxuXG4gIHJldHVybiB0aGlzLmRlY29kZXIud3JpdGUoYnVmKVxufVxuXG5VdGYxNkRlY29kZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmRlY29kZXIpIHtcbiAgICB2YXIgZW5jb2RpbmcgPSBkZXRlY3RFbmNvZGluZyh0aGlzLmluaXRpYWxCdWZzLCB0aGlzLm9wdGlvbnMuZGVmYXVsdEVuY29kaW5nKVxuICAgIHRoaXMuZGVjb2RlciA9IHRoaXMuaWNvbnYuZ2V0RGVjb2RlcihlbmNvZGluZywgdGhpcy5vcHRpb25zKVxuXG4gICAgdmFyIHJlc1N0ciA9IFwiXCJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5pdGlhbEJ1ZnMubGVuZ3RoOyBpKyspIHsgcmVzU3RyICs9IHRoaXMuZGVjb2Rlci53cml0ZSh0aGlzLmluaXRpYWxCdWZzW2ldKSB9XG5cbiAgICB2YXIgdHJhaWwgPSB0aGlzLmRlY29kZXIuZW5kKClcbiAgICBpZiAodHJhaWwpIHsgcmVzU3RyICs9IHRyYWlsIH1cblxuICAgIHRoaXMuaW5pdGlhbEJ1ZnMubGVuZ3RoID0gdGhpcy5pbml0aWFsQnVmc0xlbiA9IDBcbiAgICByZXR1cm4gcmVzU3RyXG4gIH1cbiAgcmV0dXJuIHRoaXMuZGVjb2Rlci5lbmQoKVxufVxuXG5mdW5jdGlvbiBkZXRlY3RFbmNvZGluZyAoYnVmcywgZGVmYXVsdEVuY29kaW5nKSB7XG4gIHZhciBiID0gW11cbiAgdmFyIGNoYXJzUHJvY2Vzc2VkID0gMFxuICAvLyBOdW1iZXIgb2YgQVNDSUkgY2hhcnMgd2hlbiBkZWNvZGVkIGFzIExFIG9yIEJFLlxuICB2YXIgYXNjaWlDaGFyc0xFID0gMFxuICB2YXIgYXNjaWlDaGFyc0JFID0gMFxuXG4gIG91dGVyTG9vcDpcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJ1ZiA9IGJ1ZnNbaV1cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGJ1Zi5sZW5ndGg7IGorKykge1xuICAgICAgYi5wdXNoKGJ1ZltqXSlcbiAgICAgIGlmIChiLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBpZiAoY2hhcnNQcm9jZXNzZWQgPT09IDApIHtcbiAgICAgICAgICAvLyBDaGVjayBCT00gZmlyc3QuXG4gICAgICAgICAgaWYgKGJbMF0gPT09IDB4RkYgJiYgYlsxXSA9PT0gMHhGRSkgcmV0dXJuIFwidXRmLTE2bGVcIlxuICAgICAgICAgIGlmIChiWzBdID09PSAweEZFICYmIGJbMV0gPT09IDB4RkYpIHJldHVybiBcInV0Zi0xNmJlXCJcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiWzBdID09PSAwICYmIGJbMV0gIT09IDApIGFzY2lpQ2hhcnNCRSsrXG4gICAgICAgIGlmIChiWzBdICE9PSAwICYmIGJbMV0gPT09IDApIGFzY2lpQ2hhcnNMRSsrXG5cbiAgICAgICAgYi5sZW5ndGggPSAwXG4gICAgICAgIGNoYXJzUHJvY2Vzc2VkKytcblxuICAgICAgICBpZiAoY2hhcnNQcm9jZXNzZWQgPj0gMTAwKSB7XG4gICAgICAgICAgYnJlYWsgb3V0ZXJMb29wXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBNYWtlIGRlY2lzaW9ucy5cbiAgLy8gTW9zdCBvZiB0aGUgdGltZSwgdGhlIGNvbnRlbnQgaGFzIEFTQ0lJIGNoYXJzIChVKzAwKiopLCBidXQgdGhlIG9wcG9zaXRlIChVKyoqMDApIGlzIHVuY29tbW9uLlxuICAvLyBTbywgd2UgY291bnQgQVNDSUkgYXMgaWYgaXQgd2FzIExFIG9yIEJFLCBhbmQgZGVjaWRlIGZyb20gdGhhdC5cbiAgaWYgKGFzY2lpQ2hhcnNCRSA+IGFzY2lpQ2hhcnNMRSkgcmV0dXJuIFwidXRmLTE2YmVcIlxuICBpZiAoYXNjaWlDaGFyc0JFIDwgYXNjaWlDaGFyc0xFKSByZXR1cm4gXCJ1dGYtMTZsZVwiXG5cbiAgLy8gQ291bGRuJ3QgZGVjaWRlIChsaWtlbHkgYWxsIHplcm9zIG9yIG5vdCBlbm91Z2ggZGF0YSkuXG4gIHJldHVybiBkZWZhdWx0RW5jb2RpbmcgfHwgXCJ1dGYtMTZsZVwiXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/utf16.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/utf32.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/mailparser/node_modules/iconv-lite/encodings/utf32.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(rsc)/../node_modules/safer-buffer/safer.js\").Buffer)\n\n// == UTF32-LE/BE codec. ==========================================================\n\nexports._utf32 = Utf32Codec\n\nfunction Utf32Codec (codecOptions, iconv) {\n  this.iconv = iconv\n  this.bomAware = true\n  this.isLE = codecOptions.isLE\n}\n\nexports.utf32le = { type: \"_utf32\", isLE: true }\nexports.utf32be = { type: \"_utf32\", isLE: false }\n\n// Aliases\nexports.ucs4le = \"utf32le\"\nexports.ucs4be = \"utf32be\"\n\nUtf32Codec.prototype.encoder = Utf32Encoder\nUtf32Codec.prototype.decoder = Utf32Decoder\n\n// -- Encoding\n\nfunction Utf32Encoder (options, codec) {\n  this.isLE = codec.isLE\n  this.highSurrogate = 0\n}\n\nUtf32Encoder.prototype.write = function (str) {\n  var src = Buffer.from(str, \"ucs2\")\n  var dst = Buffer.alloc(src.length * 2)\n  var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE\n  var offset = 0\n\n  for (var i = 0; i < src.length; i += 2) {\n    var code = src.readUInt16LE(i)\n    var isHighSurrogate = (code >= 0xD800 && code < 0xDC00)\n    var isLowSurrogate = (code >= 0xDC00 && code < 0xE000)\n\n    if (this.highSurrogate) {\n      if (isHighSurrogate || !isLowSurrogate) {\n        // There shouldn't be two high surrogates in a row, nor a high surrogate which isn't followed by a low\n        // surrogate. If this happens, keep the pending high surrogate as a stand-alone semi-invalid character\n        // (technically wrong, but expected by some applications, like Windows file names).\n        write32.call(dst, this.highSurrogate, offset)\n        offset += 4\n      } else {\n        // Create 32-bit value from high and low surrogates;\n        var codepoint = (((this.highSurrogate - 0xD800) << 10) | (code - 0xDC00)) + 0x10000\n\n        write32.call(dst, codepoint, offset)\n        offset += 4\n        this.highSurrogate = 0\n\n        continue\n      }\n    }\n\n    if (isHighSurrogate) { this.highSurrogate = code } else {\n      // Even if the current character is a low surrogate, with no previous high surrogate, we'll\n      // encode it as a semi-invalid stand-alone character for the same reasons expressed above for\n      // unpaired high surrogates.\n      write32.call(dst, code, offset)\n      offset += 4\n      this.highSurrogate = 0\n    }\n  }\n\n  if (offset < dst.length) { dst = dst.slice(0, offset) }\n\n  return dst\n}\n\nUtf32Encoder.prototype.end = function () {\n  // Treat any leftover high surrogate as a semi-valid independent character.\n  if (!this.highSurrogate) { return }\n\n  var buf = Buffer.alloc(4)\n\n  if (this.isLE) { buf.writeUInt32LE(this.highSurrogate, 0) } else { buf.writeUInt32BE(this.highSurrogate, 0) }\n\n  this.highSurrogate = 0\n\n  return buf\n}\n\n// -- Decoding\n\nfunction Utf32Decoder (options, codec) {\n  this.isLE = codec.isLE\n  this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0)\n  this.overflow = []\n}\n\nUtf32Decoder.prototype.write = function (src) {\n  if (src.length === 0) { return \"\" }\n\n  var i = 0\n  var codepoint = 0\n  var dst = Buffer.alloc(src.length + 4)\n  var offset = 0\n  var isLE = this.isLE\n  var overflow = this.overflow\n  var badChar = this.badChar\n\n  if (overflow.length > 0) {\n    for (; i < src.length && overflow.length < 4; i++) { overflow.push(src[i]) }\n\n    if (overflow.length === 4) {\n      // NOTE: codepoint is a signed int32 and can be negative.\n      // NOTE: We copied this block from below to help V8 optimize it (it works with array, not buffer).\n      if (isLE) {\n        codepoint = overflow[i] | (overflow[i + 1] << 8) | (overflow[i + 2] << 16) | (overflow[i + 3] << 24)\n      } else {\n        codepoint = overflow[i + 3] | (overflow[i + 2] << 8) | (overflow[i + 1] << 16) | (overflow[i] << 24)\n      }\n      overflow.length = 0\n\n      offset = _writeCodepoint(dst, offset, codepoint, badChar)\n    }\n  }\n\n  // Main loop. Should be as optimized as possible.\n  for (; i < src.length - 3; i += 4) {\n    // NOTE: codepoint is a signed int32 and can be negative.\n    if (isLE) {\n      codepoint = src[i] | (src[i + 1] << 8) | (src[i + 2] << 16) | (src[i + 3] << 24)\n    } else {\n      codepoint = src[i + 3] | (src[i + 2] << 8) | (src[i + 1] << 16) | (src[i] << 24)\n    }\n    offset = _writeCodepoint(dst, offset, codepoint, badChar)\n  }\n\n  // Keep overflowing bytes.\n  for (; i < src.length; i++) {\n    overflow.push(src[i])\n  }\n\n  return dst.slice(0, offset).toString(\"ucs2\")\n}\n\nfunction _writeCodepoint (dst, offset, codepoint, badChar) {\n  // NOTE: codepoint is signed int32 and can be negative. We keep it that way to help V8 with optimizations.\n  if (codepoint < 0 || codepoint > 0x10FFFF) {\n    // Not a valid Unicode codepoint\n    codepoint = badChar\n  }\n\n  // Ephemeral Planes: Write high surrogate.\n  if (codepoint >= 0x10000) {\n    codepoint -= 0x10000\n\n    var high = 0xD800 | (codepoint >> 10)\n    dst[offset++] = high & 0xff\n    dst[offset++] = high >> 8\n\n    // Low surrogate is written below.\n    var codepoint = 0xDC00 | (codepoint & 0x3FF)\n  }\n\n  // Write BMP char or low surrogate.\n  dst[offset++] = codepoint & 0xff\n  dst[offset++] = codepoint >> 8\n\n  return offset\n};\n\nUtf32Decoder.prototype.end = function () {\n  this.overflow.length = 0\n}\n\n// == UTF-32 Auto codec =============================================================\n// Decoder chooses automatically from UTF-32LE and UTF-32BE using BOM and space-based heuristic.\n// Defaults to UTF-32LE. http://en.wikipedia.org/wiki/UTF-32\n// Encoder/decoder default can be changed: iconv.decode(buf, 'utf32', {defaultEncoding: 'utf-32be'});\n\n// Encoder prepends BOM (which can be overridden with (addBOM: false}).\n\nexports.utf32 = Utf32AutoCodec\nexports.ucs4 = \"utf32\"\n\nfunction Utf32AutoCodec (options, iconv) {\n  this.iconv = iconv\n}\n\nUtf32AutoCodec.prototype.encoder = Utf32AutoEncoder\nUtf32AutoCodec.prototype.decoder = Utf32AutoDecoder\n\n// -- Encoding\n\nfunction Utf32AutoEncoder (options, codec) {\n  options = options || {}\n\n  if (options.addBOM === undefined) {\n    options.addBOM = true\n  }\n\n  this.encoder = codec.iconv.getEncoder(options.defaultEncoding || \"utf-32le\", options)\n}\n\nUtf32AutoEncoder.prototype.write = function (str) {\n  return this.encoder.write(str)\n}\n\nUtf32AutoEncoder.prototype.end = function () {\n  return this.encoder.end()\n}\n\n// -- Decoding\n\nfunction Utf32AutoDecoder (options, codec) {\n  this.decoder = null\n  this.initialBufs = []\n  this.initialBufsLen = 0\n  this.options = options || {}\n  this.iconv = codec.iconv\n}\n\nUtf32AutoDecoder.prototype.write = function (buf) {\n  if (!this.decoder) {\n    // Codec is not chosen yet. Accumulate initial bytes.\n    this.initialBufs.push(buf)\n    this.initialBufsLen += buf.length\n\n    if (this.initialBufsLen < 32) // We need more bytes to use space heuristic (see below)\n    { return \"\" }\n\n    // We have enough bytes -> detect endianness.\n    var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding)\n    this.decoder = this.iconv.getDecoder(encoding, this.options)\n\n    var resStr = \"\"\n    for (var i = 0; i < this.initialBufs.length; i++) { resStr += this.decoder.write(this.initialBufs[i]) }\n\n    this.initialBufs.length = this.initialBufsLen = 0\n    return resStr\n  }\n\n  return this.decoder.write(buf)\n}\n\nUtf32AutoDecoder.prototype.end = function () {\n  if (!this.decoder) {\n    var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding)\n    this.decoder = this.iconv.getDecoder(encoding, this.options)\n\n    var resStr = \"\"\n    for (var i = 0; i < this.initialBufs.length; i++) { resStr += this.decoder.write(this.initialBufs[i]) }\n\n    var trail = this.decoder.end()\n    if (trail) { resStr += trail }\n\n    this.initialBufs.length = this.initialBufsLen = 0\n    return resStr\n  }\n\n  return this.decoder.end()\n}\n\nfunction detectEncoding (bufs, defaultEncoding) {\n  var b = []\n  var charsProcessed = 0\n  var invalidLE = 0; var invalidBE = 0   // Number of invalid chars when decoded as LE or BE.\n  var bmpCharsLE = 0; var bmpCharsBE = 0 // Number of BMP chars when decoded as LE or BE.\n\n  outerLoop:\n  for (var i = 0; i < bufs.length; i++) {\n    var buf = bufs[i]\n    for (var j = 0; j < buf.length; j++) {\n      b.push(buf[j])\n      if (b.length === 4) {\n        if (charsProcessed === 0) {\n          // Check BOM first.\n          if (b[0] === 0xFF && b[1] === 0xFE && b[2] === 0 && b[3] === 0) {\n            return \"utf-32le\"\n          }\n          if (b[0] === 0 && b[1] === 0 && b[2] === 0xFE && b[3] === 0xFF) {\n            return \"utf-32be\"\n          }\n        }\n\n        if (b[0] !== 0 || b[1] > 0x10) invalidBE++\n        if (b[3] !== 0 || b[2] > 0x10) invalidLE++\n\n        if (b[0] === 0 && b[1] === 0 && (b[2] !== 0 || b[3] !== 0)) bmpCharsBE++\n        if ((b[0] !== 0 || b[1] !== 0) && b[2] === 0 && b[3] === 0) bmpCharsLE++\n\n        b.length = 0\n        charsProcessed++\n\n        if (charsProcessed >= 100) {\n          break outerLoop\n        }\n      }\n    }\n  }\n\n  // Make decisions.\n  if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE) return \"utf-32be\"\n  if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE) return \"utf-32le\"\n\n  // Couldn't decide (likely all zeros or not enough data).\n  return defaultEncoding || \"utf-32le\"\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL21haWxwYXJzZXIvbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvZW5jb2RpbmdzL3V0ZjMyLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGFBQWEsK0ZBQThCOztBQUUzQzs7QUFFQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxLQUFLO0FBQ3BCLGVBQWUsS0FBSzs7QUFFcEI7QUFDQSxjQUFjO0FBQ2QsY0FBYzs7QUFFZDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJCQUEyQiw0QkFBNEI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkI7O0FBRTdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7O0FBRUEsbUJBQW1CLDJDQUEyQyxPQUFPOztBQUVyRTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyx1Q0FBdUMsT0FBTzs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyxvQkFBb0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyxnQkFBZ0I7QUFDekI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLDRCQUE0Qjs7QUFFbkcscUVBQXFFOztBQUVyRSxhQUFhO0FBQ2IsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLDZCQUE2QixPQUFPOztBQUV4RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQiw2QkFBNkIsT0FBTzs7QUFFeEQ7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixzQkFBc0I7O0FBRXRCO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxrZnJ5dFxcLmdlbWluaVxcYW50aWdyYXZpdHlcXHNjcmF0Y2hcXGRyX2thbHNfdmlydHVhbF9ob3NwaXRhbFxcbm9kZV9tb2R1bGVzXFxtYWlscGFyc2VyXFxub2RlX21vZHVsZXNcXGljb252LWxpdGVcXGVuY29kaW5nc1xcdXRmMzIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoXCJzYWZlci1idWZmZXJcIikuQnVmZmVyXG5cbi8vID09IFVURjMyLUxFL0JFIGNvZGVjLiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydHMuX3V0ZjMyID0gVXRmMzJDb2RlY1xuXG5mdW5jdGlvbiBVdGYzMkNvZGVjIChjb2RlY09wdGlvbnMsIGljb252KSB7XG4gIHRoaXMuaWNvbnYgPSBpY29udlxuICB0aGlzLmJvbUF3YXJlID0gdHJ1ZVxuICB0aGlzLmlzTEUgPSBjb2RlY09wdGlvbnMuaXNMRVxufVxuXG5leHBvcnRzLnV0ZjMybGUgPSB7IHR5cGU6IFwiX3V0ZjMyXCIsIGlzTEU6IHRydWUgfVxuZXhwb3J0cy51dGYzMmJlID0geyB0eXBlOiBcIl91dGYzMlwiLCBpc0xFOiBmYWxzZSB9XG5cbi8vIEFsaWFzZXNcbmV4cG9ydHMudWNzNGxlID0gXCJ1dGYzMmxlXCJcbmV4cG9ydHMudWNzNGJlID0gXCJ1dGYzMmJlXCJcblxuVXRmMzJDb2RlYy5wcm90b3R5cGUuZW5jb2RlciA9IFV0ZjMyRW5jb2RlclxuVXRmMzJDb2RlYy5wcm90b3R5cGUuZGVjb2RlciA9IFV0ZjMyRGVjb2RlclxuXG4vLyAtLSBFbmNvZGluZ1xuXG5mdW5jdGlvbiBVdGYzMkVuY29kZXIgKG9wdGlvbnMsIGNvZGVjKSB7XG4gIHRoaXMuaXNMRSA9IGNvZGVjLmlzTEVcbiAgdGhpcy5oaWdoU3Vycm9nYXRlID0gMFxufVxuXG5VdGYzMkVuY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHN0cikge1xuICB2YXIgc3JjID0gQnVmZmVyLmZyb20oc3RyLCBcInVjczJcIilcbiAgdmFyIGRzdCA9IEJ1ZmZlci5hbGxvYyhzcmMubGVuZ3RoICogMilcbiAgdmFyIHdyaXRlMzIgPSB0aGlzLmlzTEUgPyBkc3Qud3JpdGVVSW50MzJMRSA6IGRzdC53cml0ZVVJbnQzMkJFXG4gIHZhciBvZmZzZXQgPSAwXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcmMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgY29kZSA9IHNyYy5yZWFkVUludDE2TEUoaSlcbiAgICB2YXIgaXNIaWdoU3Vycm9nYXRlID0gKGNvZGUgPj0gMHhEODAwICYmIGNvZGUgPCAweERDMDApXG4gICAgdmFyIGlzTG93U3Vycm9nYXRlID0gKGNvZGUgPj0gMHhEQzAwICYmIGNvZGUgPCAweEUwMDApXG5cbiAgICBpZiAodGhpcy5oaWdoU3Vycm9nYXRlKSB7XG4gICAgICBpZiAoaXNIaWdoU3Vycm9nYXRlIHx8ICFpc0xvd1N1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBUaGVyZSBzaG91bGRuJ3QgYmUgdHdvIGhpZ2ggc3Vycm9nYXRlcyBpbiBhIHJvdywgbm9yIGEgaGlnaCBzdXJyb2dhdGUgd2hpY2ggaXNuJ3QgZm9sbG93ZWQgYnkgYSBsb3dcbiAgICAgICAgLy8gc3Vycm9nYXRlLiBJZiB0aGlzIGhhcHBlbnMsIGtlZXAgdGhlIHBlbmRpbmcgaGlnaCBzdXJyb2dhdGUgYXMgYSBzdGFuZC1hbG9uZSBzZW1pLWludmFsaWQgY2hhcmFjdGVyXG4gICAgICAgIC8vICh0ZWNobmljYWxseSB3cm9uZywgYnV0IGV4cGVjdGVkIGJ5IHNvbWUgYXBwbGljYXRpb25zLCBsaWtlIFdpbmRvd3MgZmlsZSBuYW1lcykuXG4gICAgICAgIHdyaXRlMzIuY2FsbChkc3QsIHRoaXMuaGlnaFN1cnJvZ2F0ZSwgb2Zmc2V0KVxuICAgICAgICBvZmZzZXQgKz0gNFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ3JlYXRlIDMyLWJpdCB2YWx1ZSBmcm9tIGhpZ2ggYW5kIGxvdyBzdXJyb2dhdGVzO1xuICAgICAgICB2YXIgY29kZXBvaW50ID0gKCgodGhpcy5oaWdoU3Vycm9nYXRlIC0gMHhEODAwKSA8PCAxMCkgfCAoY29kZSAtIDB4REMwMCkpICsgMHgxMDAwMFxuXG4gICAgICAgIHdyaXRlMzIuY2FsbChkc3QsIGNvZGVwb2ludCwgb2Zmc2V0KVxuICAgICAgICBvZmZzZXQgKz0gNFxuICAgICAgICB0aGlzLmhpZ2hTdXJyb2dhdGUgPSAwXG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNIaWdoU3Vycm9nYXRlKSB7IHRoaXMuaGlnaFN1cnJvZ2F0ZSA9IGNvZGUgfSBlbHNlIHtcbiAgICAgIC8vIEV2ZW4gaWYgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzIGEgbG93IHN1cnJvZ2F0ZSwgd2l0aCBubyBwcmV2aW91cyBoaWdoIHN1cnJvZ2F0ZSwgd2UnbGxcbiAgICAgIC8vIGVuY29kZSBpdCBhcyBhIHNlbWktaW52YWxpZCBzdGFuZC1hbG9uZSBjaGFyYWN0ZXIgZm9yIHRoZSBzYW1lIHJlYXNvbnMgZXhwcmVzc2VkIGFib3ZlIGZvclxuICAgICAgLy8gdW5wYWlyZWQgaGlnaCBzdXJyb2dhdGVzLlxuICAgICAgd3JpdGUzMi5jYWxsKGRzdCwgY29kZSwgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IDRcbiAgICAgIHRoaXMuaGlnaFN1cnJvZ2F0ZSA9IDBcbiAgICB9XG4gIH1cblxuICBpZiAob2Zmc2V0IDwgZHN0Lmxlbmd0aCkgeyBkc3QgPSBkc3Quc2xpY2UoMCwgb2Zmc2V0KSB9XG5cbiAgcmV0dXJuIGRzdFxufVxuXG5VdGYzMkVuY29kZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVHJlYXQgYW55IGxlZnRvdmVyIGhpZ2ggc3Vycm9nYXRlIGFzIGEgc2VtaS12YWxpZCBpbmRlcGVuZGVudCBjaGFyYWN0ZXIuXG4gIGlmICghdGhpcy5oaWdoU3Vycm9nYXRlKSB7IHJldHVybiB9XG5cbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYyg0KVxuXG4gIGlmICh0aGlzLmlzTEUpIHsgYnVmLndyaXRlVUludDMyTEUodGhpcy5oaWdoU3Vycm9nYXRlLCAwKSB9IGVsc2UgeyBidWYud3JpdGVVSW50MzJCRSh0aGlzLmhpZ2hTdXJyb2dhdGUsIDApIH1cblxuICB0aGlzLmhpZ2hTdXJyb2dhdGUgPSAwXG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG4vLyAtLSBEZWNvZGluZ1xuXG5mdW5jdGlvbiBVdGYzMkRlY29kZXIgKG9wdGlvbnMsIGNvZGVjKSB7XG4gIHRoaXMuaXNMRSA9IGNvZGVjLmlzTEVcbiAgdGhpcy5iYWRDaGFyID0gY29kZWMuaWNvbnYuZGVmYXVsdENoYXJVbmljb2RlLmNoYXJDb2RlQXQoMClcbiAgdGhpcy5vdmVyZmxvdyA9IFtdXG59XG5cblV0ZjMyRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoc3JjKSB7XG4gIGlmIChzcmMubGVuZ3RoID09PSAwKSB7IHJldHVybiBcIlwiIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIGNvZGVwb2ludCA9IDBcbiAgdmFyIGRzdCA9IEJ1ZmZlci5hbGxvYyhzcmMubGVuZ3RoICsgNClcbiAgdmFyIG9mZnNldCA9IDBcbiAgdmFyIGlzTEUgPSB0aGlzLmlzTEVcbiAgdmFyIG92ZXJmbG93ID0gdGhpcy5vdmVyZmxvd1xuICB2YXIgYmFkQ2hhciA9IHRoaXMuYmFkQ2hhclxuXG4gIGlmIChvdmVyZmxvdy5sZW5ndGggPiAwKSB7XG4gICAgZm9yICg7IGkgPCBzcmMubGVuZ3RoICYmIG92ZXJmbG93Lmxlbmd0aCA8IDQ7IGkrKykgeyBvdmVyZmxvdy5wdXNoKHNyY1tpXSkgfVxuXG4gICAgaWYgKG92ZXJmbG93Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgLy8gTk9URTogY29kZXBvaW50IGlzIGEgc2lnbmVkIGludDMyIGFuZCBjYW4gYmUgbmVnYXRpdmUuXG4gICAgICAvLyBOT1RFOiBXZSBjb3BpZWQgdGhpcyBibG9jayBmcm9tIGJlbG93IHRvIGhlbHAgVjggb3B0aW1pemUgaXQgKGl0IHdvcmtzIHdpdGggYXJyYXksIG5vdCBidWZmZXIpLlxuICAgICAgaWYgKGlzTEUpIHtcbiAgICAgICAgY29kZXBvaW50ID0gb3ZlcmZsb3dbaV0gfCAob3ZlcmZsb3dbaSArIDFdIDw8IDgpIHwgKG92ZXJmbG93W2kgKyAyXSA8PCAxNikgfCAob3ZlcmZsb3dbaSArIDNdIDw8IDI0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29kZXBvaW50ID0gb3ZlcmZsb3dbaSArIDNdIHwgKG92ZXJmbG93W2kgKyAyXSA8PCA4KSB8IChvdmVyZmxvd1tpICsgMV0gPDwgMTYpIHwgKG92ZXJmbG93W2ldIDw8IDI0KVxuICAgICAgfVxuICAgICAgb3ZlcmZsb3cubGVuZ3RoID0gMFxuXG4gICAgICBvZmZzZXQgPSBfd3JpdGVDb2RlcG9pbnQoZHN0LCBvZmZzZXQsIGNvZGVwb2ludCwgYmFkQ2hhcilcbiAgICB9XG4gIH1cblxuICAvLyBNYWluIGxvb3AuIFNob3VsZCBiZSBhcyBvcHRpbWl6ZWQgYXMgcG9zc2libGUuXG4gIGZvciAoOyBpIDwgc3JjLmxlbmd0aCAtIDM7IGkgKz0gNCkge1xuICAgIC8vIE5PVEU6IGNvZGVwb2ludCBpcyBhIHNpZ25lZCBpbnQzMiBhbmQgY2FuIGJlIG5lZ2F0aXZlLlxuICAgIGlmIChpc0xFKSB7XG4gICAgICBjb2RlcG9pbnQgPSBzcmNbaV0gfCAoc3JjW2kgKyAxXSA8PCA4KSB8IChzcmNbaSArIDJdIDw8IDE2KSB8IChzcmNbaSArIDNdIDw8IDI0KVxuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlcG9pbnQgPSBzcmNbaSArIDNdIHwgKHNyY1tpICsgMl0gPDwgOCkgfCAoc3JjW2kgKyAxXSA8PCAxNikgfCAoc3JjW2ldIDw8IDI0KVxuICAgIH1cbiAgICBvZmZzZXQgPSBfd3JpdGVDb2RlcG9pbnQoZHN0LCBvZmZzZXQsIGNvZGVwb2ludCwgYmFkQ2hhcilcbiAgfVxuXG4gIC8vIEtlZXAgb3ZlcmZsb3dpbmcgYnl0ZXMuXG4gIGZvciAoOyBpIDwgc3JjLmxlbmd0aDsgaSsrKSB7XG4gICAgb3ZlcmZsb3cucHVzaChzcmNbaV0pXG4gIH1cblxuICByZXR1cm4gZHN0LnNsaWNlKDAsIG9mZnNldCkudG9TdHJpbmcoXCJ1Y3MyXCIpXG59XG5cbmZ1bmN0aW9uIF93cml0ZUNvZGVwb2ludCAoZHN0LCBvZmZzZXQsIGNvZGVwb2ludCwgYmFkQ2hhcikge1xuICAvLyBOT1RFOiBjb2RlcG9pbnQgaXMgc2lnbmVkIGludDMyIGFuZCBjYW4gYmUgbmVnYXRpdmUuIFdlIGtlZXAgaXQgdGhhdCB3YXkgdG8gaGVscCBWOCB3aXRoIG9wdGltaXphdGlvbnMuXG4gIGlmIChjb2RlcG9pbnQgPCAwIHx8IGNvZGVwb2ludCA+IDB4MTBGRkZGKSB7XG4gICAgLy8gTm90IGEgdmFsaWQgVW5pY29kZSBjb2RlcG9pbnRcbiAgICBjb2RlcG9pbnQgPSBiYWRDaGFyXG4gIH1cblxuICAvLyBFcGhlbWVyYWwgUGxhbmVzOiBXcml0ZSBoaWdoIHN1cnJvZ2F0ZS5cbiAgaWYgKGNvZGVwb2ludCA+PSAweDEwMDAwKSB7XG4gICAgY29kZXBvaW50IC09IDB4MTAwMDBcblxuICAgIHZhciBoaWdoID0gMHhEODAwIHwgKGNvZGVwb2ludCA+PiAxMClcbiAgICBkc3Rbb2Zmc2V0KytdID0gaGlnaCAmIDB4ZmZcbiAgICBkc3Rbb2Zmc2V0KytdID0gaGlnaCA+PiA4XG5cbiAgICAvLyBMb3cgc3Vycm9nYXRlIGlzIHdyaXR0ZW4gYmVsb3cuXG4gICAgdmFyIGNvZGVwb2ludCA9IDB4REMwMCB8IChjb2RlcG9pbnQgJiAweDNGRilcbiAgfVxuXG4gIC8vIFdyaXRlIEJNUCBjaGFyIG9yIGxvdyBzdXJyb2dhdGUuXG4gIGRzdFtvZmZzZXQrK10gPSBjb2RlcG9pbnQgJiAweGZmXG4gIGRzdFtvZmZzZXQrK10gPSBjb2RlcG9pbnQgPj4gOFxuXG4gIHJldHVybiBvZmZzZXRcbn07XG5cblV0ZjMyRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLm92ZXJmbG93Lmxlbmd0aCA9IDBcbn1cblxuLy8gPT0gVVRGLTMyIEF1dG8gY29kZWMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gRGVjb2RlciBjaG9vc2VzIGF1dG9tYXRpY2FsbHkgZnJvbSBVVEYtMzJMRSBhbmQgVVRGLTMyQkUgdXNpbmcgQk9NIGFuZCBzcGFjZS1iYXNlZCBoZXVyaXN0aWMuXG4vLyBEZWZhdWx0cyB0byBVVEYtMzJMRS4gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VVEYtMzJcbi8vIEVuY29kZXIvZGVjb2RlciBkZWZhdWx0IGNhbiBiZSBjaGFuZ2VkOiBpY29udi5kZWNvZGUoYnVmLCAndXRmMzInLCB7ZGVmYXVsdEVuY29kaW5nOiAndXRmLTMyYmUnfSk7XG5cbi8vIEVuY29kZXIgcHJlcGVuZHMgQk9NICh3aGljaCBjYW4gYmUgb3ZlcnJpZGRlbiB3aXRoIChhZGRCT006IGZhbHNlfSkuXG5cbmV4cG9ydHMudXRmMzIgPSBVdGYzMkF1dG9Db2RlY1xuZXhwb3J0cy51Y3M0ID0gXCJ1dGYzMlwiXG5cbmZ1bmN0aW9uIFV0ZjMyQXV0b0NvZGVjIChvcHRpb25zLCBpY29udikge1xuICB0aGlzLmljb252ID0gaWNvbnZcbn1cblxuVXRmMzJBdXRvQ29kZWMucHJvdG90eXBlLmVuY29kZXIgPSBVdGYzMkF1dG9FbmNvZGVyXG5VdGYzMkF1dG9Db2RlYy5wcm90b3R5cGUuZGVjb2RlciA9IFV0ZjMyQXV0b0RlY29kZXJcblxuLy8gLS0gRW5jb2RpbmdcblxuZnVuY3Rpb24gVXRmMzJBdXRvRW5jb2RlciAob3B0aW9ucywgY29kZWMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICBpZiAob3B0aW9ucy5hZGRCT00gPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMuYWRkQk9NID0gdHJ1ZVxuICB9XG5cbiAgdGhpcy5lbmNvZGVyID0gY29kZWMuaWNvbnYuZ2V0RW5jb2RlcihvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCBcInV0Zi0zMmxlXCIsIG9wdGlvbnMpXG59XG5cblV0ZjMyQXV0b0VuY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gdGhpcy5lbmNvZGVyLndyaXRlKHN0cilcbn1cblxuVXRmMzJBdXRvRW5jb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5lbmNvZGVyLmVuZCgpXG59XG5cbi8vIC0tIERlY29kaW5nXG5cbmZ1bmN0aW9uIFV0ZjMyQXV0b0RlY29kZXIgKG9wdGlvbnMsIGNvZGVjKSB7XG4gIHRoaXMuZGVjb2RlciA9IG51bGxcbiAgdGhpcy5pbml0aWFsQnVmcyA9IFtdXG4gIHRoaXMuaW5pdGlhbEJ1ZnNMZW4gPSAwXG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgdGhpcy5pY29udiA9IGNvZGVjLmljb252XG59XG5cblV0ZjMyQXV0b0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAoIXRoaXMuZGVjb2Rlcikge1xuICAgIC8vIENvZGVjIGlzIG5vdCBjaG9zZW4geWV0LiBBY2N1bXVsYXRlIGluaXRpYWwgYnl0ZXMuXG4gICAgdGhpcy5pbml0aWFsQnVmcy5wdXNoKGJ1ZilcbiAgICB0aGlzLmluaXRpYWxCdWZzTGVuICs9IGJ1Zi5sZW5ndGhcblxuICAgIGlmICh0aGlzLmluaXRpYWxCdWZzTGVuIDwgMzIpIC8vIFdlIG5lZWQgbW9yZSBieXRlcyB0byB1c2Ugc3BhY2UgaGV1cmlzdGljIChzZWUgYmVsb3cpXG4gICAgeyByZXR1cm4gXCJcIiB9XG5cbiAgICAvLyBXZSBoYXZlIGVub3VnaCBieXRlcyAtPiBkZXRlY3QgZW5kaWFubmVzcy5cbiAgICB2YXIgZW5jb2RpbmcgPSBkZXRlY3RFbmNvZGluZyh0aGlzLmluaXRpYWxCdWZzLCB0aGlzLm9wdGlvbnMuZGVmYXVsdEVuY29kaW5nKVxuICAgIHRoaXMuZGVjb2RlciA9IHRoaXMuaWNvbnYuZ2V0RGVjb2RlcihlbmNvZGluZywgdGhpcy5vcHRpb25zKVxuXG4gICAgdmFyIHJlc1N0ciA9IFwiXCJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5pdGlhbEJ1ZnMubGVuZ3RoOyBpKyspIHsgcmVzU3RyICs9IHRoaXMuZGVjb2Rlci53cml0ZSh0aGlzLmluaXRpYWxCdWZzW2ldKSB9XG5cbiAgICB0aGlzLmluaXRpYWxCdWZzLmxlbmd0aCA9IHRoaXMuaW5pdGlhbEJ1ZnNMZW4gPSAwXG4gICAgcmV0dXJuIHJlc1N0clxuICB9XG5cbiAgcmV0dXJuIHRoaXMuZGVjb2Rlci53cml0ZShidWYpXG59XG5cblV0ZjMyQXV0b0RlY29kZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmRlY29kZXIpIHtcbiAgICB2YXIgZW5jb2RpbmcgPSBkZXRlY3RFbmNvZGluZyh0aGlzLmluaXRpYWxCdWZzLCB0aGlzLm9wdGlvbnMuZGVmYXVsdEVuY29kaW5nKVxuICAgIHRoaXMuZGVjb2RlciA9IHRoaXMuaWNvbnYuZ2V0RGVjb2RlcihlbmNvZGluZywgdGhpcy5vcHRpb25zKVxuXG4gICAgdmFyIHJlc1N0ciA9IFwiXCJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5pdGlhbEJ1ZnMubGVuZ3RoOyBpKyspIHsgcmVzU3RyICs9IHRoaXMuZGVjb2Rlci53cml0ZSh0aGlzLmluaXRpYWxCdWZzW2ldKSB9XG5cbiAgICB2YXIgdHJhaWwgPSB0aGlzLmRlY29kZXIuZW5kKClcbiAgICBpZiAodHJhaWwpIHsgcmVzU3RyICs9IHRyYWlsIH1cblxuICAgIHRoaXMuaW5pdGlhbEJ1ZnMubGVuZ3RoID0gdGhpcy5pbml0aWFsQnVmc0xlbiA9IDBcbiAgICByZXR1cm4gcmVzU3RyXG4gIH1cblxuICByZXR1cm4gdGhpcy5kZWNvZGVyLmVuZCgpXG59XG5cbmZ1bmN0aW9uIGRldGVjdEVuY29kaW5nIChidWZzLCBkZWZhdWx0RW5jb2RpbmcpIHtcbiAgdmFyIGIgPSBbXVxuICB2YXIgY2hhcnNQcm9jZXNzZWQgPSAwXG4gIHZhciBpbnZhbGlkTEUgPSAwOyB2YXIgaW52YWxpZEJFID0gMCAgIC8vIE51bWJlciBvZiBpbnZhbGlkIGNoYXJzIHdoZW4gZGVjb2RlZCBhcyBMRSBvciBCRS5cbiAgdmFyIGJtcENoYXJzTEUgPSAwOyB2YXIgYm1wQ2hhcnNCRSA9IDAgLy8gTnVtYmVyIG9mIEJNUCBjaGFycyB3aGVuIGRlY29kZWQgYXMgTEUgb3IgQkUuXG5cbiAgb3V0ZXJMb29wOlxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYnVmID0gYnVmc1tpXVxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYnVmLmxlbmd0aDsgaisrKSB7XG4gICAgICBiLnB1c2goYnVmW2pdKVxuICAgICAgaWYgKGIubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIGlmIChjaGFyc1Byb2Nlc3NlZCA9PT0gMCkge1xuICAgICAgICAgIC8vIENoZWNrIEJPTSBmaXJzdC5cbiAgICAgICAgICBpZiAoYlswXSA9PT0gMHhGRiAmJiBiWzFdID09PSAweEZFICYmIGJbMl0gPT09IDAgJiYgYlszXSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFwidXRmLTMybGVcIlxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYlswXSA9PT0gMCAmJiBiWzFdID09PSAwICYmIGJbMl0gPT09IDB4RkUgJiYgYlszXSA9PT0gMHhGRikge1xuICAgICAgICAgICAgcmV0dXJuIFwidXRmLTMyYmVcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiWzBdICE9PSAwIHx8IGJbMV0gPiAweDEwKSBpbnZhbGlkQkUrK1xuICAgICAgICBpZiAoYlszXSAhPT0gMCB8fCBiWzJdID4gMHgxMCkgaW52YWxpZExFKytcblxuICAgICAgICBpZiAoYlswXSA9PT0gMCAmJiBiWzFdID09PSAwICYmIChiWzJdICE9PSAwIHx8IGJbM10gIT09IDApKSBibXBDaGFyc0JFKytcbiAgICAgICAgaWYgKChiWzBdICE9PSAwIHx8IGJbMV0gIT09IDApICYmIGJbMl0gPT09IDAgJiYgYlszXSA9PT0gMCkgYm1wQ2hhcnNMRSsrXG5cbiAgICAgICAgYi5sZW5ndGggPSAwXG4gICAgICAgIGNoYXJzUHJvY2Vzc2VkKytcblxuICAgICAgICBpZiAoY2hhcnNQcm9jZXNzZWQgPj0gMTAwKSB7XG4gICAgICAgICAgYnJlYWsgb3V0ZXJMb29wXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBNYWtlIGRlY2lzaW9ucy5cbiAgaWYgKGJtcENoYXJzQkUgLSBpbnZhbGlkQkUgPiBibXBDaGFyc0xFIC0gaW52YWxpZExFKSByZXR1cm4gXCJ1dGYtMzJiZVwiXG4gIGlmIChibXBDaGFyc0JFIC0gaW52YWxpZEJFIDwgYm1wQ2hhcnNMRSAtIGludmFsaWRMRSkgcmV0dXJuIFwidXRmLTMybGVcIlxuXG4gIC8vIENvdWxkbid0IGRlY2lkZSAobGlrZWx5IGFsbCB6ZXJvcyBvciBub3QgZW5vdWdoIGRhdGEpLlxuICByZXR1cm4gZGVmYXVsdEVuY29kaW5nIHx8IFwidXRmLTMybGVcIlxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/utf32.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/utf7.js":
/*!****************************************************************************!*\
  !*** ../node_modules/mailparser/node_modules/iconv-lite/encodings/utf7.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(rsc)/../node_modules/safer-buffer/safer.js\").Buffer)\n\n// UTF-7 codec, according to https://tools.ietf.org/html/rfc2152\n// See also below a UTF-7-IMAP codec, according to http://tools.ietf.org/html/rfc3501#section-5.1.3\n\nexports.utf7 = Utf7Codec\nexports.unicode11utf7 = \"utf7\" // Alias UNICODE-1-1-UTF-7\nfunction Utf7Codec (codecOptions, iconv) {\n  this.iconv = iconv\n};\n\nUtf7Codec.prototype.encoder = Utf7Encoder\nUtf7Codec.prototype.decoder = Utf7Decoder\nUtf7Codec.prototype.bomAware = true\n\n// -- Encoding\n\n// Why scape ()?./?\n// eslint-disable-next-line no-useless-escape\nvar nonDirectChars = /[^A-Za-z0-9'\\(\\),-\\.\\/:\\? \\n\\r\\t]+/g\n\nfunction Utf7Encoder (options, codec) {\n  this.iconv = codec.iconv\n}\n\nUtf7Encoder.prototype.write = function (str) {\n  // Naive implementation.\n  // Non-direct chars are encoded as \"+<base64>-\"; single \"+\" char is encoded as \"+-\".\n  return Buffer.from(str.replace(nonDirectChars, function (chunk) {\n    return \"+\" + (chunk === \"+\"\n      ? \"\"\n      : this.iconv.encode(chunk, \"utf16-be\").toString(\"base64\").replace(/=+$/, \"\")) +\n            \"-\"\n  }.bind(this)))\n}\n\nUtf7Encoder.prototype.end = function () {\n}\n\n// -- Decoding\n\nfunction Utf7Decoder (options, codec) {\n  this.iconv = codec.iconv\n  this.inBase64 = false\n  this.base64Accum = \"\"\n}\n\n// Why scape /?\n// eslint-disable-next-line no-useless-escape\nvar base64Regex = /[A-Za-z0-9\\/+]/\nvar base64Chars = []\nfor (var i = 0; i < 256; i++) { base64Chars[i] = base64Regex.test(String.fromCharCode(i)) }\n\nvar plusChar = \"+\".charCodeAt(0)\nvar minusChar = \"-\".charCodeAt(0)\nvar andChar = \"&\".charCodeAt(0)\n\nUtf7Decoder.prototype.write = function (buf) {\n  var res = \"\"; var lastI = 0\n  var inBase64 = this.inBase64\n  var base64Accum = this.base64Accum\n\n  // The decoder is more involved as we must handle chunks in stream.\n\n  for (var i = 0; i < buf.length; i++) {\n    if (!inBase64) { // We're in direct mode.\n      // Write direct chars until '+'\n      if (buf[i] == plusChar) {\n        res += this.iconv.decode(buf.slice(lastI, i), \"ascii\") // Write direct chars.\n        lastI = i + 1\n        inBase64 = true\n      }\n    } else { // We decode base64.\n      if (!base64Chars[buf[i]]) { // Base64 ended.\n        if (i == lastI && buf[i] == minusChar) { // \"+-\" -> \"+\"\n          res += \"+\"\n        } else {\n          var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i), \"ascii\")\n          res += this.iconv.decode(Buffer.from(b64str, \"base64\"), \"utf16-be\")\n        }\n\n        if (buf[i] != minusChar) // Minus is absorbed after base64.\n        { i-- }\n\n        lastI = i + 1\n        inBase64 = false\n        base64Accum = \"\"\n      }\n    }\n  }\n\n  if (!inBase64) {\n    res += this.iconv.decode(buf.slice(lastI), \"ascii\") // Write direct chars.\n  } else {\n    var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), \"ascii\")\n\n    var canBeDecoded = b64str.length - (b64str.length % 8) // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.\n    base64Accum = b64str.slice(canBeDecoded) // The rest will be decoded in future.\n    b64str = b64str.slice(0, canBeDecoded)\n\n    res += this.iconv.decode(Buffer.from(b64str, \"base64\"), \"utf16-be\")\n  }\n\n  this.inBase64 = inBase64\n  this.base64Accum = base64Accum\n\n  return res\n}\n\nUtf7Decoder.prototype.end = function () {\n  var res = \"\"\n  if (this.inBase64 && this.base64Accum.length > 0) { res = this.iconv.decode(Buffer.from(this.base64Accum, \"base64\"), \"utf16-be\") }\n\n  this.inBase64 = false\n  this.base64Accum = \"\"\n  return res\n}\n\n// UTF-7-IMAP codec.\n// RFC3501 Sec. 5.1.3 Modified UTF-7 (http://tools.ietf.org/html/rfc3501#section-5.1.3)\n// Differences:\n//  * Base64 part is started by \"&\" instead of \"+\"\n//  * Direct characters are 0x20-0x7E, except \"&\" (0x26)\n//  * In Base64, \",\" is used instead of \"/\"\n//  * Base64 must not be used to represent direct characters.\n//  * No implicit shift back from Base64 (should always end with '-')\n//  * String must end in non-shifted position.\n//  * \"-&\" while in base64 is not allowed.\n\nexports.utf7imap = Utf7IMAPCodec\nfunction Utf7IMAPCodec (codecOptions, iconv) {\n  this.iconv = iconv\n};\n\nUtf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder\nUtf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder\nUtf7IMAPCodec.prototype.bomAware = true\n\n// -- Encoding\n\nfunction Utf7IMAPEncoder (options, codec) {\n  this.iconv = codec.iconv\n  this.inBase64 = false\n  this.base64Accum = Buffer.alloc(6)\n  this.base64AccumIdx = 0\n}\n\nUtf7IMAPEncoder.prototype.write = function (str) {\n  var inBase64 = this.inBase64\n  var base64Accum = this.base64Accum\n  var base64AccumIdx = this.base64AccumIdx\n  var buf = Buffer.alloc(str.length * 5 + 10); var bufIdx = 0\n\n  for (var i = 0; i < str.length; i++) {\n    var uChar = str.charCodeAt(i)\n    if (uChar >= 0x20 && uChar <= 0x7E) { // Direct character or '&'.\n      if (inBase64) {\n        if (base64AccumIdx > 0) {\n          bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString(\"base64\").replace(/\\//g, \",\").replace(/=+$/, \"\"), bufIdx)\n          base64AccumIdx = 0\n        }\n\n        buf[bufIdx++] = minusChar // Write '-', then go to direct mode.\n        inBase64 = false\n      }\n\n      if (!inBase64) {\n        buf[bufIdx++] = uChar // Write direct character\n\n        if (uChar === andChar)  // Ampersand -> '&-'\n        { buf[bufIdx++] = minusChar }\n      }\n    } else { // Non-direct character\n      if (!inBase64) {\n        buf[bufIdx++] = andChar // Write '&', then go to base64 mode.\n        inBase64 = true\n      }\n      if (inBase64) {\n        base64Accum[base64AccumIdx++] = uChar >> 8\n        base64Accum[base64AccumIdx++] = uChar & 0xFF\n\n        if (base64AccumIdx == base64Accum.length) {\n          bufIdx += buf.write(base64Accum.toString(\"base64\").replace(/\\//g, \",\"), bufIdx)\n          base64AccumIdx = 0\n        }\n      }\n    }\n  }\n\n  this.inBase64 = inBase64\n  this.base64AccumIdx = base64AccumIdx\n\n  return buf.slice(0, bufIdx)\n}\n\nUtf7IMAPEncoder.prototype.end = function () {\n  var buf = Buffer.alloc(10); var bufIdx = 0\n  if (this.inBase64) {\n    if (this.base64AccumIdx > 0) {\n      bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString(\"base64\").replace(/\\//g, \",\").replace(/=+$/, \"\"), bufIdx)\n      this.base64AccumIdx = 0\n    }\n\n    buf[bufIdx++] = minusChar // Write '-', then go to direct mode.\n    this.inBase64 = false\n  }\n\n  return buf.slice(0, bufIdx)\n}\n\n// -- Decoding\n\nfunction Utf7IMAPDecoder (options, codec) {\n  this.iconv = codec.iconv\n  this.inBase64 = false\n  this.base64Accum = \"\"\n}\n\nvar base64IMAPChars = base64Chars.slice()\nbase64IMAPChars[\",\".charCodeAt(0)] = true\n\nUtf7IMAPDecoder.prototype.write = function (buf) {\n  var res = \"\"; var lastI = 0\n  var inBase64 = this.inBase64\n  var base64Accum = this.base64Accum\n\n  // The decoder is more involved as we must handle chunks in stream.\n  // It is forgiving, closer to standard UTF-7 (for example, '-' is optional at the end).\n\n  for (var i = 0; i < buf.length; i++) {\n    if (!inBase64) { // We're in direct mode.\n      // Write direct chars until '&'\n      if (buf[i] == andChar) {\n        res += this.iconv.decode(buf.slice(lastI, i), \"ascii\") // Write direct chars.\n        lastI = i + 1\n        inBase64 = true\n      }\n    } else { // We decode base64.\n      if (!base64IMAPChars[buf[i]]) { // Base64 ended.\n        if (i == lastI && buf[i] == minusChar) { // \"&-\" -> \"&\"\n          res += \"&\"\n        } else {\n          var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i), \"ascii\").replace(/,/g, \"/\")\n          res += this.iconv.decode(Buffer.from(b64str, \"base64\"), \"utf16-be\")\n        }\n\n        if (buf[i] != minusChar) // Minus may be absorbed after base64.\n        { i-- }\n\n        lastI = i + 1\n        inBase64 = false\n        base64Accum = \"\"\n      }\n    }\n  }\n\n  if (!inBase64) {\n    res += this.iconv.decode(buf.slice(lastI), \"ascii\") // Write direct chars.\n  } else {\n    var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), \"ascii\").replace(/,/g, \"/\")\n\n    var canBeDecoded = b64str.length - (b64str.length % 8) // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.\n    base64Accum = b64str.slice(canBeDecoded) // The rest will be decoded in future.\n    b64str = b64str.slice(0, canBeDecoded)\n\n    res += this.iconv.decode(Buffer.from(b64str, \"base64\"), \"utf16-be\")\n  }\n\n  this.inBase64 = inBase64\n  this.base64Accum = base64Accum\n\n  return res\n}\n\nUtf7IMAPDecoder.prototype.end = function () {\n  var res = \"\"\n  if (this.inBase64 && this.base64Accum.length > 0) { res = this.iconv.decode(Buffer.from(this.base64Accum, \"base64\"), \"utf16-be\") }\n\n  this.inBase64 = false\n  this.base64Accum = \"\"\n  return res\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL21haWxwYXJzZXIvbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvZW5jb2RpbmdzL3V0ZjcuanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWixhQUFhLCtGQUE4Qjs7QUFFM0M7QUFDQTs7QUFFQSxZQUFZO0FBQ1oscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVMsT0FBTzs7QUFFaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLGdCQUFnQjtBQUNsQyxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxPQUFPO0FBQ2Isa0NBQWtDO0FBQ2xDLGlEQUFpRDtBQUNqRDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0RBQXNEOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7O0FBRS9DLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBLE1BQU0sT0FBTztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLGdCQUFnQjtBQUNsQyxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxPQUFPO0FBQ2Isc0NBQXNDO0FBQ3RDLGlEQUFpRDtBQUNqRDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0RBQXNEOztBQUV0RDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxrZnJ5dFxcLmdlbWluaVxcYW50aWdyYXZpdHlcXHNjcmF0Y2hcXGRyX2thbHNfdmlydHVhbF9ob3NwaXRhbFxcbm9kZV9tb2R1bGVzXFxtYWlscGFyc2VyXFxub2RlX21vZHVsZXNcXGljb252LWxpdGVcXGVuY29kaW5nc1xcdXRmNy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoXCJzYWZlci1idWZmZXJcIikuQnVmZmVyXG5cbi8vIFVURi03IGNvZGVjLCBhY2NvcmRpbmcgdG8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzIxNTJcbi8vIFNlZSBhbHNvIGJlbG93IGEgVVRGLTctSU1BUCBjb2RlYywgYWNjb3JkaW5nIHRvIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM1MDEjc2VjdGlvbi01LjEuM1xuXG5leHBvcnRzLnV0ZjcgPSBVdGY3Q29kZWNcbmV4cG9ydHMudW5pY29kZTExdXRmNyA9IFwidXRmN1wiIC8vIEFsaWFzIFVOSUNPREUtMS0xLVVURi03XG5mdW5jdGlvbiBVdGY3Q29kZWMgKGNvZGVjT3B0aW9ucywgaWNvbnYpIHtcbiAgdGhpcy5pY29udiA9IGljb252XG59O1xuXG5VdGY3Q29kZWMucHJvdG90eXBlLmVuY29kZXIgPSBVdGY3RW5jb2RlclxuVXRmN0NvZGVjLnByb3RvdHlwZS5kZWNvZGVyID0gVXRmN0RlY29kZXJcblV0ZjdDb2RlYy5wcm90b3R5cGUuYm9tQXdhcmUgPSB0cnVlXG5cbi8vIC0tIEVuY29kaW5nXG5cbi8vIFdoeSBzY2FwZSAoKT8uLz9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWVzY2FwZVxudmFyIG5vbkRpcmVjdENoYXJzID0gL1teQS1aYS16MC05J1xcKFxcKSwtXFwuXFwvOlxcPyBcXG5cXHJcXHRdKy9nXG5cbmZ1bmN0aW9uIFV0ZjdFbmNvZGVyIChvcHRpb25zLCBjb2RlYykge1xuICB0aGlzLmljb252ID0gY29kZWMuaWNvbnZcbn1cblxuVXRmN0VuY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHN0cikge1xuICAvLyBOYWl2ZSBpbXBsZW1lbnRhdGlvbi5cbiAgLy8gTm9uLWRpcmVjdCBjaGFycyBhcmUgZW5jb2RlZCBhcyBcIis8YmFzZTY0Pi1cIjsgc2luZ2xlIFwiK1wiIGNoYXIgaXMgZW5jb2RlZCBhcyBcIistXCIuXG4gIHJldHVybiBCdWZmZXIuZnJvbShzdHIucmVwbGFjZShub25EaXJlY3RDaGFycywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgcmV0dXJuIFwiK1wiICsgKGNodW5rID09PSBcIitcIlxuICAgICAgPyBcIlwiXG4gICAgICA6IHRoaXMuaWNvbnYuZW5jb2RlKGNodW5rLCBcInV0ZjE2LWJlXCIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpLnJlcGxhY2UoLz0rJC8sIFwiXCIpKSArXG4gICAgICAgICAgICBcIi1cIlxuICB9LmJpbmQodGhpcykpKVxufVxuXG5VdGY3RW5jb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xufVxuXG4vLyAtLSBEZWNvZGluZ1xuXG5mdW5jdGlvbiBVdGY3RGVjb2RlciAob3B0aW9ucywgY29kZWMpIHtcbiAgdGhpcy5pY29udiA9IGNvZGVjLmljb252XG4gIHRoaXMuaW5CYXNlNjQgPSBmYWxzZVxuICB0aGlzLmJhc2U2NEFjY3VtID0gXCJcIlxufVxuXG4vLyBXaHkgc2NhcGUgLz9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWVzY2FwZVxudmFyIGJhc2U2NFJlZ2V4ID0gL1tBLVphLXowLTlcXC8rXS9cbnZhciBiYXNlNjRDaGFycyA9IFtdXG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7IGJhc2U2NENoYXJzW2ldID0gYmFzZTY0UmVnZXgudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGkpKSB9XG5cbnZhciBwbHVzQ2hhciA9IFwiK1wiLmNoYXJDb2RlQXQoMClcbnZhciBtaW51c0NoYXIgPSBcIi1cIi5jaGFyQ29kZUF0KDApXG52YXIgYW5kQ2hhciA9IFwiJlwiLmNoYXJDb2RlQXQoMClcblxuVXRmN0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICB2YXIgcmVzID0gXCJcIjsgdmFyIGxhc3RJID0gMFxuICB2YXIgaW5CYXNlNjQgPSB0aGlzLmluQmFzZTY0XG4gIHZhciBiYXNlNjRBY2N1bSA9IHRoaXMuYmFzZTY0QWNjdW1cblxuICAvLyBUaGUgZGVjb2RlciBpcyBtb3JlIGludm9sdmVkIGFzIHdlIG11c3QgaGFuZGxlIGNodW5rcyBpbiBzdHJlYW0uXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWluQmFzZTY0KSB7IC8vIFdlJ3JlIGluIGRpcmVjdCBtb2RlLlxuICAgICAgLy8gV3JpdGUgZGlyZWN0IGNoYXJzIHVudGlsICcrJ1xuICAgICAgaWYgKGJ1ZltpXSA9PSBwbHVzQ2hhcikge1xuICAgICAgICByZXMgKz0gdGhpcy5pY29udi5kZWNvZGUoYnVmLnNsaWNlKGxhc3RJLCBpKSwgXCJhc2NpaVwiKSAvLyBXcml0ZSBkaXJlY3QgY2hhcnMuXG4gICAgICAgIGxhc3RJID0gaSArIDFcbiAgICAgICAgaW5CYXNlNjQgPSB0cnVlXG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gV2UgZGVjb2RlIGJhc2U2NC5cbiAgICAgIGlmICghYmFzZTY0Q2hhcnNbYnVmW2ldXSkgeyAvLyBCYXNlNjQgZW5kZWQuXG4gICAgICAgIGlmIChpID09IGxhc3RJICYmIGJ1ZltpXSA9PSBtaW51c0NoYXIpIHsgLy8gXCIrLVwiIC0+IFwiK1wiXG4gICAgICAgICAgcmVzICs9IFwiK1wiXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGI2NHN0ciA9IGJhc2U2NEFjY3VtICsgdGhpcy5pY29udi5kZWNvZGUoYnVmLnNsaWNlKGxhc3RJLCBpKSwgXCJhc2NpaVwiKVxuICAgICAgICAgIHJlcyArPSB0aGlzLmljb252LmRlY29kZShCdWZmZXIuZnJvbShiNjRzdHIsIFwiYmFzZTY0XCIpLCBcInV0ZjE2LWJlXCIpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYnVmW2ldICE9IG1pbnVzQ2hhcikgLy8gTWludXMgaXMgYWJzb3JiZWQgYWZ0ZXIgYmFzZTY0LlxuICAgICAgICB7IGktLSB9XG5cbiAgICAgICAgbGFzdEkgPSBpICsgMVxuICAgICAgICBpbkJhc2U2NCA9IGZhbHNlXG4gICAgICAgIGJhc2U2NEFjY3VtID0gXCJcIlxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghaW5CYXNlNjQpIHtcbiAgICByZXMgKz0gdGhpcy5pY29udi5kZWNvZGUoYnVmLnNsaWNlKGxhc3RJKSwgXCJhc2NpaVwiKSAvLyBXcml0ZSBkaXJlY3QgY2hhcnMuXG4gIH0gZWxzZSB7XG4gICAgdmFyIGI2NHN0ciA9IGJhc2U2NEFjY3VtICsgdGhpcy5pY29udi5kZWNvZGUoYnVmLnNsaWNlKGxhc3RJKSwgXCJhc2NpaVwiKVxuXG4gICAgdmFyIGNhbkJlRGVjb2RlZCA9IGI2NHN0ci5sZW5ndGggLSAoYjY0c3RyLmxlbmd0aCAlIDgpIC8vIE1pbmltYWwgY2h1bms6IDIgcXVhZHMgLT4gMngzIGJ5dGVzIC0+IDMgY2hhcnMuXG4gICAgYmFzZTY0QWNjdW0gPSBiNjRzdHIuc2xpY2UoY2FuQmVEZWNvZGVkKSAvLyBUaGUgcmVzdCB3aWxsIGJlIGRlY29kZWQgaW4gZnV0dXJlLlxuICAgIGI2NHN0ciA9IGI2NHN0ci5zbGljZSgwLCBjYW5CZURlY29kZWQpXG5cbiAgICByZXMgKz0gdGhpcy5pY29udi5kZWNvZGUoQnVmZmVyLmZyb20oYjY0c3RyLCBcImJhc2U2NFwiKSwgXCJ1dGYxNi1iZVwiKVxuICB9XG5cbiAgdGhpcy5pbkJhc2U2NCA9IGluQmFzZTY0XG4gIHRoaXMuYmFzZTY0QWNjdW0gPSBiYXNlNjRBY2N1bVxuXG4gIHJldHVybiByZXNcbn1cblxuVXRmN0RlY29kZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlcyA9IFwiXCJcbiAgaWYgKHRoaXMuaW5CYXNlNjQgJiYgdGhpcy5iYXNlNjRBY2N1bS5sZW5ndGggPiAwKSB7IHJlcyA9IHRoaXMuaWNvbnYuZGVjb2RlKEJ1ZmZlci5mcm9tKHRoaXMuYmFzZTY0QWNjdW0sIFwiYmFzZTY0XCIpLCBcInV0ZjE2LWJlXCIpIH1cblxuICB0aGlzLmluQmFzZTY0ID0gZmFsc2VcbiAgdGhpcy5iYXNlNjRBY2N1bSA9IFwiXCJcbiAgcmV0dXJuIHJlc1xufVxuXG4vLyBVVEYtNy1JTUFQIGNvZGVjLlxuLy8gUkZDMzUwMSBTZWMuIDUuMS4zIE1vZGlmaWVkIFVURi03IChodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNTAxI3NlY3Rpb24tNS4xLjMpXG4vLyBEaWZmZXJlbmNlczpcbi8vICAqIEJhc2U2NCBwYXJ0IGlzIHN0YXJ0ZWQgYnkgXCImXCIgaW5zdGVhZCBvZiBcIitcIlxuLy8gICogRGlyZWN0IGNoYXJhY3RlcnMgYXJlIDB4MjAtMHg3RSwgZXhjZXB0IFwiJlwiICgweDI2KVxuLy8gICogSW4gQmFzZTY0LCBcIixcIiBpcyB1c2VkIGluc3RlYWQgb2YgXCIvXCJcbi8vICAqIEJhc2U2NCBtdXN0IG5vdCBiZSB1c2VkIHRvIHJlcHJlc2VudCBkaXJlY3QgY2hhcmFjdGVycy5cbi8vICAqIE5vIGltcGxpY2l0IHNoaWZ0IGJhY2sgZnJvbSBCYXNlNjQgKHNob3VsZCBhbHdheXMgZW5kIHdpdGggJy0nKVxuLy8gICogU3RyaW5nIG11c3QgZW5kIGluIG5vbi1zaGlmdGVkIHBvc2l0aW9uLlxuLy8gICogXCItJlwiIHdoaWxlIGluIGJhc2U2NCBpcyBub3QgYWxsb3dlZC5cblxuZXhwb3J0cy51dGY3aW1hcCA9IFV0ZjdJTUFQQ29kZWNcbmZ1bmN0aW9uIFV0ZjdJTUFQQ29kZWMgKGNvZGVjT3B0aW9ucywgaWNvbnYpIHtcbiAgdGhpcy5pY29udiA9IGljb252XG59O1xuXG5VdGY3SU1BUENvZGVjLnByb3RvdHlwZS5lbmNvZGVyID0gVXRmN0lNQVBFbmNvZGVyXG5VdGY3SU1BUENvZGVjLnByb3RvdHlwZS5kZWNvZGVyID0gVXRmN0lNQVBEZWNvZGVyXG5VdGY3SU1BUENvZGVjLnByb3RvdHlwZS5ib21Bd2FyZSA9IHRydWVcblxuLy8gLS0gRW5jb2RpbmdcblxuZnVuY3Rpb24gVXRmN0lNQVBFbmNvZGVyIChvcHRpb25zLCBjb2RlYykge1xuICB0aGlzLmljb252ID0gY29kZWMuaWNvbnZcbiAgdGhpcy5pbkJhc2U2NCA9IGZhbHNlXG4gIHRoaXMuYmFzZTY0QWNjdW0gPSBCdWZmZXIuYWxsb2MoNilcbiAgdGhpcy5iYXNlNjRBY2N1bUlkeCA9IDBcbn1cblxuVXRmN0lNQVBFbmNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdmFyIGluQmFzZTY0ID0gdGhpcy5pbkJhc2U2NFxuICB2YXIgYmFzZTY0QWNjdW0gPSB0aGlzLmJhc2U2NEFjY3VtXG4gIHZhciBiYXNlNjRBY2N1bUlkeCA9IHRoaXMuYmFzZTY0QWNjdW1JZHhcbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYyhzdHIubGVuZ3RoICogNSArIDEwKTsgdmFyIGJ1ZklkeCA9IDBcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIHZhciB1Q2hhciA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaWYgKHVDaGFyID49IDB4MjAgJiYgdUNoYXIgPD0gMHg3RSkgeyAvLyBEaXJlY3QgY2hhcmFjdGVyIG9yICcmJy5cbiAgICAgIGlmIChpbkJhc2U2NCkge1xuICAgICAgICBpZiAoYmFzZTY0QWNjdW1JZHggPiAwKSB7XG4gICAgICAgICAgYnVmSWR4ICs9IGJ1Zi53cml0ZShiYXNlNjRBY2N1bS5zbGljZSgwLCBiYXNlNjRBY2N1bUlkeCkudG9TdHJpbmcoXCJiYXNlNjRcIikucmVwbGFjZSgvXFwvL2csIFwiLFwiKS5yZXBsYWNlKC89KyQvLCBcIlwiKSwgYnVmSWR4KVxuICAgICAgICAgIGJhc2U2NEFjY3VtSWR4ID0gMFxuICAgICAgICB9XG5cbiAgICAgICAgYnVmW2J1ZklkeCsrXSA9IG1pbnVzQ2hhciAvLyBXcml0ZSAnLScsIHRoZW4gZ28gdG8gZGlyZWN0IG1vZGUuXG4gICAgICAgIGluQmFzZTY0ID0gZmFsc2VcbiAgICAgIH1cblxuICAgICAgaWYgKCFpbkJhc2U2NCkge1xuICAgICAgICBidWZbYnVmSWR4KytdID0gdUNoYXIgLy8gV3JpdGUgZGlyZWN0IGNoYXJhY3RlclxuXG4gICAgICAgIGlmICh1Q2hhciA9PT0gYW5kQ2hhcikgIC8vIEFtcGVyc2FuZCAtPiAnJi0nXG4gICAgICAgIHsgYnVmW2J1ZklkeCsrXSA9IG1pbnVzQ2hhciB9XG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gTm9uLWRpcmVjdCBjaGFyYWN0ZXJcbiAgICAgIGlmICghaW5CYXNlNjQpIHtcbiAgICAgICAgYnVmW2J1ZklkeCsrXSA9IGFuZENoYXIgLy8gV3JpdGUgJyYnLCB0aGVuIGdvIHRvIGJhc2U2NCBtb2RlLlxuICAgICAgICBpbkJhc2U2NCA9IHRydWVcbiAgICAgIH1cbiAgICAgIGlmIChpbkJhc2U2NCkge1xuICAgICAgICBiYXNlNjRBY2N1bVtiYXNlNjRBY2N1bUlkeCsrXSA9IHVDaGFyID4+IDhcbiAgICAgICAgYmFzZTY0QWNjdW1bYmFzZTY0QWNjdW1JZHgrK10gPSB1Q2hhciAmIDB4RkZcblxuICAgICAgICBpZiAoYmFzZTY0QWNjdW1JZHggPT0gYmFzZTY0QWNjdW0ubGVuZ3RoKSB7XG4gICAgICAgICAgYnVmSWR4ICs9IGJ1Zi53cml0ZShiYXNlNjRBY2N1bS50b1N0cmluZyhcImJhc2U2NFwiKS5yZXBsYWNlKC9cXC8vZywgXCIsXCIpLCBidWZJZHgpXG4gICAgICAgICAgYmFzZTY0QWNjdW1JZHggPSAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLmluQmFzZTY0ID0gaW5CYXNlNjRcbiAgdGhpcy5iYXNlNjRBY2N1bUlkeCA9IGJhc2U2NEFjY3VtSWR4XG5cbiAgcmV0dXJuIGJ1Zi5zbGljZSgwLCBidWZJZHgpXG59XG5cblV0ZjdJTUFQRW5jb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYnVmID0gQnVmZmVyLmFsbG9jKDEwKTsgdmFyIGJ1ZklkeCA9IDBcbiAgaWYgKHRoaXMuaW5CYXNlNjQpIHtcbiAgICBpZiAodGhpcy5iYXNlNjRBY2N1bUlkeCA+IDApIHtcbiAgICAgIGJ1ZklkeCArPSBidWYud3JpdGUodGhpcy5iYXNlNjRBY2N1bS5zbGljZSgwLCB0aGlzLmJhc2U2NEFjY3VtSWR4KS50b1N0cmluZyhcImJhc2U2NFwiKS5yZXBsYWNlKC9cXC8vZywgXCIsXCIpLnJlcGxhY2UoLz0rJC8sIFwiXCIpLCBidWZJZHgpXG4gICAgICB0aGlzLmJhc2U2NEFjY3VtSWR4ID0gMFxuICAgIH1cblxuICAgIGJ1ZltidWZJZHgrK10gPSBtaW51c0NoYXIgLy8gV3JpdGUgJy0nLCB0aGVuIGdvIHRvIGRpcmVjdCBtb2RlLlxuICAgIHRoaXMuaW5CYXNlNjQgPSBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIGJ1Zi5zbGljZSgwLCBidWZJZHgpXG59XG5cbi8vIC0tIERlY29kaW5nXG5cbmZ1bmN0aW9uIFV0ZjdJTUFQRGVjb2RlciAob3B0aW9ucywgY29kZWMpIHtcbiAgdGhpcy5pY29udiA9IGNvZGVjLmljb252XG4gIHRoaXMuaW5CYXNlNjQgPSBmYWxzZVxuICB0aGlzLmJhc2U2NEFjY3VtID0gXCJcIlxufVxuXG52YXIgYmFzZTY0SU1BUENoYXJzID0gYmFzZTY0Q2hhcnMuc2xpY2UoKVxuYmFzZTY0SU1BUENoYXJzW1wiLFwiLmNoYXJDb2RlQXQoMCldID0gdHJ1ZVxuXG5VdGY3SU1BUERlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICB2YXIgcmVzID0gXCJcIjsgdmFyIGxhc3RJID0gMFxuICB2YXIgaW5CYXNlNjQgPSB0aGlzLmluQmFzZTY0XG4gIHZhciBiYXNlNjRBY2N1bSA9IHRoaXMuYmFzZTY0QWNjdW1cblxuICAvLyBUaGUgZGVjb2RlciBpcyBtb3JlIGludm9sdmVkIGFzIHdlIG11c3QgaGFuZGxlIGNodW5rcyBpbiBzdHJlYW0uXG4gIC8vIEl0IGlzIGZvcmdpdmluZywgY2xvc2VyIHRvIHN0YW5kYXJkIFVURi03IChmb3IgZXhhbXBsZSwgJy0nIGlzIG9wdGlvbmFsIGF0IHRoZSBlbmQpLlxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFpbkJhc2U2NCkgeyAvLyBXZSdyZSBpbiBkaXJlY3QgbW9kZS5cbiAgICAgIC8vIFdyaXRlIGRpcmVjdCBjaGFycyB1bnRpbCAnJidcbiAgICAgIGlmIChidWZbaV0gPT0gYW5kQ2hhcikge1xuICAgICAgICByZXMgKz0gdGhpcy5pY29udi5kZWNvZGUoYnVmLnNsaWNlKGxhc3RJLCBpKSwgXCJhc2NpaVwiKSAvLyBXcml0ZSBkaXJlY3QgY2hhcnMuXG4gICAgICAgIGxhc3RJID0gaSArIDFcbiAgICAgICAgaW5CYXNlNjQgPSB0cnVlXG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gV2UgZGVjb2RlIGJhc2U2NC5cbiAgICAgIGlmICghYmFzZTY0SU1BUENoYXJzW2J1ZltpXV0pIHsgLy8gQmFzZTY0IGVuZGVkLlxuICAgICAgICBpZiAoaSA9PSBsYXN0SSAmJiBidWZbaV0gPT0gbWludXNDaGFyKSB7IC8vIFwiJi1cIiAtPiBcIiZcIlxuICAgICAgICAgIHJlcyArPSBcIiZcIlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBiNjRzdHIgPSBiYXNlNjRBY2N1bSArIHRoaXMuaWNvbnYuZGVjb2RlKGJ1Zi5zbGljZShsYXN0SSwgaSksIFwiYXNjaWlcIikucmVwbGFjZSgvLC9nLCBcIi9cIilcbiAgICAgICAgICByZXMgKz0gdGhpcy5pY29udi5kZWNvZGUoQnVmZmVyLmZyb20oYjY0c3RyLCBcImJhc2U2NFwiKSwgXCJ1dGYxNi1iZVwiKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJ1ZltpXSAhPSBtaW51c0NoYXIpIC8vIE1pbnVzIG1heSBiZSBhYnNvcmJlZCBhZnRlciBiYXNlNjQuXG4gICAgICAgIHsgaS0tIH1cblxuICAgICAgICBsYXN0SSA9IGkgKyAxXG4gICAgICAgIGluQmFzZTY0ID0gZmFsc2VcbiAgICAgICAgYmFzZTY0QWNjdW0gPSBcIlwiXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCFpbkJhc2U2NCkge1xuICAgIHJlcyArPSB0aGlzLmljb252LmRlY29kZShidWYuc2xpY2UobGFzdEkpLCBcImFzY2lpXCIpIC8vIFdyaXRlIGRpcmVjdCBjaGFycy5cbiAgfSBlbHNlIHtcbiAgICB2YXIgYjY0c3RyID0gYmFzZTY0QWNjdW0gKyB0aGlzLmljb252LmRlY29kZShidWYuc2xpY2UobGFzdEkpLCBcImFzY2lpXCIpLnJlcGxhY2UoLywvZywgXCIvXCIpXG5cbiAgICB2YXIgY2FuQmVEZWNvZGVkID0gYjY0c3RyLmxlbmd0aCAtIChiNjRzdHIubGVuZ3RoICUgOCkgLy8gTWluaW1hbCBjaHVuazogMiBxdWFkcyAtPiAyeDMgYnl0ZXMgLT4gMyBjaGFycy5cbiAgICBiYXNlNjRBY2N1bSA9IGI2NHN0ci5zbGljZShjYW5CZURlY29kZWQpIC8vIFRoZSByZXN0IHdpbGwgYmUgZGVjb2RlZCBpbiBmdXR1cmUuXG4gICAgYjY0c3RyID0gYjY0c3RyLnNsaWNlKDAsIGNhbkJlRGVjb2RlZClcblxuICAgIHJlcyArPSB0aGlzLmljb252LmRlY29kZShCdWZmZXIuZnJvbShiNjRzdHIsIFwiYmFzZTY0XCIpLCBcInV0ZjE2LWJlXCIpXG4gIH1cblxuICB0aGlzLmluQmFzZTY0ID0gaW5CYXNlNjRcbiAgdGhpcy5iYXNlNjRBY2N1bSA9IGJhc2U2NEFjY3VtXG5cbiAgcmV0dXJuIHJlc1xufVxuXG5VdGY3SU1BUERlY29kZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlcyA9IFwiXCJcbiAgaWYgKHRoaXMuaW5CYXNlNjQgJiYgdGhpcy5iYXNlNjRBY2N1bS5sZW5ndGggPiAwKSB7IHJlcyA9IHRoaXMuaWNvbnYuZGVjb2RlKEJ1ZmZlci5mcm9tKHRoaXMuYmFzZTY0QWNjdW0sIFwiYmFzZTY0XCIpLCBcInV0ZjE2LWJlXCIpIH1cblxuICB0aGlzLmluQmFzZTY0ID0gZmFsc2VcbiAgdGhpcy5iYXNlNjRBY2N1bSA9IFwiXCJcbiAgcmV0dXJuIHJlc1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/utf7.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/mailparser/node_modules/iconv-lite/lib/bom-handling.js":
/*!******************************************************************************!*\
  !*** ../node_modules/mailparser/node_modules/iconv-lite/lib/bom-handling.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nvar BOMChar = \"\\uFEFF\"\n\nexports.PrependBOM = PrependBOMWrapper\nfunction PrependBOMWrapper (encoder, options) {\n  this.encoder = encoder\n  this.addBOM = true\n}\n\nPrependBOMWrapper.prototype.write = function (str) {\n  if (this.addBOM) {\n    str = BOMChar + str\n    this.addBOM = false\n  }\n\n  return this.encoder.write(str)\n}\n\nPrependBOMWrapper.prototype.end = function () {\n  return this.encoder.end()\n}\n\n// ------------------------------------------------------------------------------\n\nexports.StripBOM = StripBOMWrapper\nfunction StripBOMWrapper (decoder, options) {\n  this.decoder = decoder\n  this.pass = false\n  this.options = options || {}\n}\n\nStripBOMWrapper.prototype.write = function (buf) {\n  var res = this.decoder.write(buf)\n  if (this.pass || !res) { return res }\n\n  if (res[0] === BOMChar) {\n    res = res.slice(1)\n    if (typeof this.options.stripBOM === \"function\") { this.options.stripBOM() }\n  }\n\n  this.pass = true\n  return res\n}\n\nStripBOMWrapper.prototype.end = function () {\n  return this.decoder.end()\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL21haWxwYXJzZXIvbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvbGliL2JvbS1oYW5kbGluZy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xca2ZyeXRcXC5nZW1pbmlcXGFudGlncmF2aXR5XFxzY3JhdGNoXFxkcl9rYWxzX3ZpcnR1YWxfaG9zcGl0YWxcXG5vZGVfbW9kdWxlc1xcbWFpbHBhcnNlclxcbm9kZV9tb2R1bGVzXFxpY29udi1saXRlXFxsaWJcXGJvbS1oYW5kbGluZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxuXG52YXIgQk9NQ2hhciA9IFwiXFx1RkVGRlwiXG5cbmV4cG9ydHMuUHJlcGVuZEJPTSA9IFByZXBlbmRCT01XcmFwcGVyXG5mdW5jdGlvbiBQcmVwZW5kQk9NV3JhcHBlciAoZW5jb2Rlciwgb3B0aW9ucykge1xuICB0aGlzLmVuY29kZXIgPSBlbmNvZGVyXG4gIHRoaXMuYWRkQk9NID0gdHJ1ZVxufVxuXG5QcmVwZW5kQk9NV3JhcHBlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIGlmICh0aGlzLmFkZEJPTSkge1xuICAgIHN0ciA9IEJPTUNoYXIgKyBzdHJcbiAgICB0aGlzLmFkZEJPTSA9IGZhbHNlXG4gIH1cblxuICByZXR1cm4gdGhpcy5lbmNvZGVyLndyaXRlKHN0cilcbn1cblxuUHJlcGVuZEJPTVdyYXBwZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZW5jb2Rlci5lbmQoKVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0cy5TdHJpcEJPTSA9IFN0cmlwQk9NV3JhcHBlclxuZnVuY3Rpb24gU3RyaXBCT01XcmFwcGVyIChkZWNvZGVyLCBvcHRpb25zKSB7XG4gIHRoaXMuZGVjb2RlciA9IGRlY29kZXJcbiAgdGhpcy5wYXNzID0gZmFsc2VcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fVxufVxuXG5TdHJpcEJPTVdyYXBwZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICB2YXIgcmVzID0gdGhpcy5kZWNvZGVyLndyaXRlKGJ1ZilcbiAgaWYgKHRoaXMucGFzcyB8fCAhcmVzKSB7IHJldHVybiByZXMgfVxuXG4gIGlmIChyZXNbMF0gPT09IEJPTUNoYXIpIHtcbiAgICByZXMgPSByZXMuc2xpY2UoMSlcbiAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5zdHJpcEJPTSA9PT0gXCJmdW5jdGlvblwiKSB7IHRoaXMub3B0aW9ucy5zdHJpcEJPTSgpIH1cbiAgfVxuXG4gIHRoaXMucGFzcyA9IHRydWVcbiAgcmV0dXJuIHJlc1xufVxuXG5TdHJpcEJPTVdyYXBwZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZGVjb2Rlci5lbmQoKVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/mailparser/node_modules/iconv-lite/lib/bom-handling.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/mailparser/node_modules/iconv-lite/lib/helpers/merge-exports.js":
/*!***************************************************************************************!*\
  !*** ../node_modules/mailparser/node_modules/iconv-lite/lib/helpers/merge-exports.js ***!
  \***************************************************************************************/
/***/ ((module) => {

eval("\n\nvar hasOwn = typeof Object.hasOwn === \"undefined\" ? Function.call.bind(Object.prototype.hasOwnProperty) : Object.hasOwn\n\nfunction mergeModules (target, module) {\n  for (var key in module) {\n    if (hasOwn(module, key)) {\n      target[key] = module[key]\n    }\n  }\n}\n\nmodule.exports = mergeModules\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL21haWxwYXJzZXIvbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvbGliL2hlbHBlcnMvbWVyZ2UtZXhwb3J0cy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxrZnJ5dFxcLmdlbWluaVxcYW50aWdyYXZpdHlcXHNjcmF0Y2hcXGRyX2thbHNfdmlydHVhbF9ob3NwaXRhbFxcbm9kZV9tb2R1bGVzXFxtYWlscGFyc2VyXFxub2RlX21vZHVsZXNcXGljb252LWxpdGVcXGxpYlxcaGVscGVyc1xcbWVyZ2UtZXhwb3J0cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxuXG52YXIgaGFzT3duID0gdHlwZW9mIE9iamVjdC5oYXNPd24gPT09IFwidW5kZWZpbmVkXCIgPyBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSkgOiBPYmplY3QuaGFzT3duXG5cbmZ1bmN0aW9uIG1lcmdlTW9kdWxlcyAodGFyZ2V0LCBtb2R1bGUpIHtcbiAgZm9yICh2YXIga2V5IGluIG1vZHVsZSkge1xuICAgIGlmIChoYXNPd24obW9kdWxlLCBrZXkpKSB7XG4gICAgICB0YXJnZXRba2V5XSA9IG1vZHVsZVtrZXldXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVyZ2VNb2R1bGVzXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/mailparser/node_modules/iconv-lite/lib/helpers/merge-exports.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/mailparser/node_modules/iconv-lite/lib/index.js":
/*!***********************************************************************!*\
  !*** ../node_modules/mailparser/node_modules/iconv-lite/lib/index.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(rsc)/../node_modules/safer-buffer/safer.js\").Buffer)\n\nvar bomHandling = __webpack_require__(/*! ./bom-handling */ \"(rsc)/../node_modules/mailparser/node_modules/iconv-lite/lib/bom-handling.js\")\nvar mergeModules = __webpack_require__(/*! ./helpers/merge-exports */ \"(rsc)/../node_modules/mailparser/node_modules/iconv-lite/lib/helpers/merge-exports.js\")\nvar iconv = module.exports\n\n// All codecs and aliases are kept here, keyed by encoding name/alias.\n// They are lazy loaded in `iconv.getCodec` from `encodings/index.js`.\n// Cannot initialize with { __proto__: null } because Boolean({ __proto__: null }) === true\niconv.encodings = null\n\n// Characters emitted in case of error.\niconv.defaultCharUnicode = \"\"\niconv.defaultCharSingleByte = \"?\"\n\n// Public API.\niconv.encode = function encode (str, encoding, options) {\n  str = \"\" + (str || \"\") // Ensure string.\n\n  var encoder = iconv.getEncoder(encoding, options)\n\n  var res = encoder.write(str)\n  var trail = encoder.end()\n\n  return (trail && trail.length > 0) ? Buffer.concat([res, trail]) : res\n}\n\niconv.decode = function decode (buf, encoding, options) {\n  if (typeof buf === \"string\") {\n    if (!iconv.skipDecodeWarning) {\n      console.error(\"Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding\")\n      iconv.skipDecodeWarning = true\n    }\n\n    buf = Buffer.from(\"\" + (buf || \"\"), \"binary\") // Ensure buffer.\n  }\n\n  var decoder = iconv.getDecoder(encoding, options)\n\n  var res = decoder.write(buf)\n  var trail = decoder.end()\n\n  return trail ? (res + trail) : res\n}\n\niconv.encodingExists = function encodingExists (enc) {\n  try {\n    iconv.getCodec(enc)\n    return true\n  } catch (e) {\n    return false\n  }\n}\n\n// Legacy aliases to convert functions\niconv.toEncoding = iconv.encode\niconv.fromEncoding = iconv.decode\n\n// Search for a codec in iconv.encodings. Cache codec data in iconv._codecDataCache.\niconv._codecDataCache = { __proto__: null }\n\niconv.getCodec = function getCodec (encoding) {\n  if (!iconv.encodings) {\n    var raw = __webpack_require__(/*! ../encodings */ \"(rsc)/../node_modules/mailparser/node_modules/iconv-lite/encodings/index.js\")\n    // TODO: In future versions when old nodejs support is removed can use object.assign\n    iconv.encodings = { __proto__: null } // Initialize as empty object.\n    mergeModules(iconv.encodings, raw)\n  }\n\n  // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.\n  var enc = iconv._canonicalizeEncoding(encoding)\n\n  // Traverse iconv.encodings to find actual codec.\n  var codecOptions = {}\n  while (true) {\n    var codec = iconv._codecDataCache[enc]\n\n    if (codec) { return codec }\n\n    var codecDef = iconv.encodings[enc]\n\n    switch (typeof codecDef) {\n      case \"string\": // Direct alias to other encoding.\n        enc = codecDef\n        break\n\n      case \"object\": // Alias with options. Can be layered.\n        for (var key in codecDef) { codecOptions[key] = codecDef[key] }\n\n        if (!codecOptions.encodingName) { codecOptions.encodingName = enc }\n\n        enc = codecDef.type\n        break\n\n      case \"function\": // Codec itself.\n        if (!codecOptions.encodingName) { codecOptions.encodingName = enc }\n\n        // The codec function must load all tables and return object with .encoder and .decoder methods.\n        // It'll be called only once (for each different options object).\n        //\n        codec = new codecDef(codecOptions, iconv)\n\n        iconv._codecDataCache[codecOptions.encodingName] = codec // Save it to be reused later.\n        return codec\n\n      default:\n        throw new Error(\"Encoding not recognized: '\" + encoding + \"' (searched as: '\" + enc + \"')\")\n    }\n  }\n}\n\niconv._canonicalizeEncoding = function (encoding) {\n  // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.\n  return (\"\" + encoding).toLowerCase().replace(/:\\d{4}$|[^0-9a-z]/g, \"\")\n}\n\niconv.getEncoder = function getEncoder (encoding, options) {\n  var codec = iconv.getCodec(encoding)\n  var encoder = new codec.encoder(options, codec)\n\n  if (codec.bomAware && options && options.addBOM) { encoder = new bomHandling.PrependBOM(encoder, options) }\n\n  return encoder\n}\n\niconv.getDecoder = function getDecoder (encoding, options) {\n  var codec = iconv.getCodec(encoding)\n  var decoder = new codec.decoder(options, codec)\n\n  if (codec.bomAware && !(options && options.stripBOM === false)) { decoder = new bomHandling.StripBOM(decoder, options) }\n\n  return decoder\n}\n\n// Streaming API\n// NOTE: Streaming API naturally depends on 'stream' module from Node.js. Unfortunately in browser environments this module can add\n// up to 100Kb to the output bundle. To avoid unnecessary code bloat, we don't enable Streaming API in browser by default.\n// If you would like to enable it explicitly, please add the following code to your app:\n// > iconv.enableStreamingAPI(require('stream'));\niconv.enableStreamingAPI = function enableStreamingAPI (streamModule) {\n  if (iconv.supportsStreams) { return }\n\n  // Dependency-inject stream module to create IconvLite stream classes.\n  var streams = __webpack_require__(/*! ./streams */ \"(rsc)/../node_modules/mailparser/node_modules/iconv-lite/lib/streams.js\")(streamModule)\n\n  // Not public API yet, but expose the stream classes.\n  iconv.IconvLiteEncoderStream = streams.IconvLiteEncoderStream\n  iconv.IconvLiteDecoderStream = streams.IconvLiteDecoderStream\n\n  // Streaming API.\n  iconv.encodeStream = function encodeStream (encoding, options) {\n    return new iconv.IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options)\n  }\n\n  iconv.decodeStream = function decodeStream (encoding, options) {\n    return new iconv.IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options)\n  }\n\n  iconv.supportsStreams = true\n}\n\n// Enable Streaming API automatically if 'stream' module is available and non-empty (the majority of environments).\nvar streamModule\ntry {\n  streamModule = __webpack_require__(/*! stream */ \"stream\")\n} catch (e) {}\n\nif (streamModule && streamModule.Transform) {\n  iconv.enableStreamingAPI(streamModule)\n} else {\n  // In rare cases where 'stream' module is not available by default, throw a helpful exception.\n  iconv.encodeStream = iconv.decodeStream = function () {\n    throw new Error(\"iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.\")\n  }\n}\n\n// Some environments, such as browsers, may not load JavaScript files as UTF-8\n// eslint-disable-next-line no-constant-condition\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL21haWxwYXJzZXIvbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGFBQWEsK0ZBQThCOztBQUUzQyxrQkFBa0IsbUJBQU8sQ0FBQyxvR0FBZ0I7QUFDMUMsbUJBQW1CLG1CQUFPLENBQUMsc0hBQXlCO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCLGtCQUFrQixpQkFBaUI7QUFDakY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsaUdBQWM7QUFDcEM7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7O0FBRWpCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DOztBQUVwQywwQ0FBMEM7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9ELEVBQUU7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFEQUFxRDs7QUFFckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0VBQW9FOztBQUVwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQywwRkFBVzs7QUFFbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsK0dBQStHO0FBQy9HO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUksS0FBZ0IsRUFBRSxFQUVyQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxrZnJ5dFxcLmdlbWluaVxcYW50aWdyYXZpdHlcXHNjcmF0Y2hcXGRyX2thbHNfdmlydHVhbF9ob3NwaXRhbFxcbm9kZV9tb2R1bGVzXFxtYWlscGFyc2VyXFxub2RlX21vZHVsZXNcXGljb252LWxpdGVcXGxpYlxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoXCJzYWZlci1idWZmZXJcIikuQnVmZmVyXG5cbnZhciBib21IYW5kbGluZyA9IHJlcXVpcmUoXCIuL2JvbS1oYW5kbGluZ1wiKVxudmFyIG1lcmdlTW9kdWxlcyA9IHJlcXVpcmUoXCIuL2hlbHBlcnMvbWVyZ2UtZXhwb3J0c1wiKVxudmFyIGljb252ID0gbW9kdWxlLmV4cG9ydHNcblxuLy8gQWxsIGNvZGVjcyBhbmQgYWxpYXNlcyBhcmUga2VwdCBoZXJlLCBrZXllZCBieSBlbmNvZGluZyBuYW1lL2FsaWFzLlxuLy8gVGhleSBhcmUgbGF6eSBsb2FkZWQgaW4gYGljb252LmdldENvZGVjYCBmcm9tIGBlbmNvZGluZ3MvaW5kZXguanNgLlxuLy8gQ2Fubm90IGluaXRpYWxpemUgd2l0aCB7IF9fcHJvdG9fXzogbnVsbCB9IGJlY2F1c2UgQm9vbGVhbih7IF9fcHJvdG9fXzogbnVsbCB9KSA9PT0gdHJ1ZVxuaWNvbnYuZW5jb2RpbmdzID0gbnVsbFxuXG4vLyBDaGFyYWN0ZXJzIGVtaXR0ZWQgaW4gY2FzZSBvZiBlcnJvci5cbmljb252LmRlZmF1bHRDaGFyVW5pY29kZSA9IFwi77+9XCJcbmljb252LmRlZmF1bHRDaGFyU2luZ2xlQnl0ZSA9IFwiP1wiXG5cbi8vIFB1YmxpYyBBUEkuXG5pY29udi5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUgKHN0ciwgZW5jb2RpbmcsIG9wdGlvbnMpIHtcbiAgc3RyID0gXCJcIiArIChzdHIgfHwgXCJcIikgLy8gRW5zdXJlIHN0cmluZy5cblxuICB2YXIgZW5jb2RlciA9IGljb252LmdldEVuY29kZXIoZW5jb2RpbmcsIG9wdGlvbnMpXG5cbiAgdmFyIHJlcyA9IGVuY29kZXIud3JpdGUoc3RyKVxuICB2YXIgdHJhaWwgPSBlbmNvZGVyLmVuZCgpXG5cbiAgcmV0dXJuICh0cmFpbCAmJiB0cmFpbC5sZW5ndGggPiAwKSA/IEJ1ZmZlci5jb25jYXQoW3JlcywgdHJhaWxdKSA6IHJlc1xufVxuXG5pY29udi5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUgKGJ1ZiwgZW5jb2RpbmcsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBidWYgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoIWljb252LnNraXBEZWNvZGVXYXJuaW5nKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiSWNvbnYtbGl0ZSB3YXJuaW5nOiBkZWNvZGUoKS1pbmcgc3RyaW5ncyBpcyBkZXByZWNhdGVkLiBSZWZlciB0byBodHRwczovL2dpdGh1Yi5jb20vYXNodHVjaGtpbi9pY29udi1saXRlL3dpa2kvVXNlLUJ1ZmZlcnMtd2hlbi1kZWNvZGluZ1wiKVxuICAgICAgaWNvbnYuc2tpcERlY29kZVdhcm5pbmcgPSB0cnVlXG4gICAgfVxuXG4gICAgYnVmID0gQnVmZmVyLmZyb20oXCJcIiArIChidWYgfHwgXCJcIiksIFwiYmluYXJ5XCIpIC8vIEVuc3VyZSBidWZmZXIuXG4gIH1cblxuICB2YXIgZGVjb2RlciA9IGljb252LmdldERlY29kZXIoZW5jb2RpbmcsIG9wdGlvbnMpXG5cbiAgdmFyIHJlcyA9IGRlY29kZXIud3JpdGUoYnVmKVxuICB2YXIgdHJhaWwgPSBkZWNvZGVyLmVuZCgpXG5cbiAgcmV0dXJuIHRyYWlsID8gKHJlcyArIHRyYWlsKSA6IHJlc1xufVxuXG5pY29udi5lbmNvZGluZ0V4aXN0cyA9IGZ1bmN0aW9uIGVuY29kaW5nRXhpc3RzIChlbmMpIHtcbiAgdHJ5IHtcbiAgICBpY29udi5nZXRDb2RlYyhlbmMpXG4gICAgcmV0dXJuIHRydWVcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbi8vIExlZ2FjeSBhbGlhc2VzIHRvIGNvbnZlcnQgZnVuY3Rpb25zXG5pY29udi50b0VuY29kaW5nID0gaWNvbnYuZW5jb2RlXG5pY29udi5mcm9tRW5jb2RpbmcgPSBpY29udi5kZWNvZGVcblxuLy8gU2VhcmNoIGZvciBhIGNvZGVjIGluIGljb252LmVuY29kaW5ncy4gQ2FjaGUgY29kZWMgZGF0YSBpbiBpY29udi5fY29kZWNEYXRhQ2FjaGUuXG5pY29udi5fY29kZWNEYXRhQ2FjaGUgPSB7IF9fcHJvdG9fXzogbnVsbCB9XG5cbmljb252LmdldENvZGVjID0gZnVuY3Rpb24gZ2V0Q29kZWMgKGVuY29kaW5nKSB7XG4gIGlmICghaWNvbnYuZW5jb2RpbmdzKSB7XG4gICAgdmFyIHJhdyA9IHJlcXVpcmUoXCIuLi9lbmNvZGluZ3NcIilcbiAgICAvLyBUT0RPOiBJbiBmdXR1cmUgdmVyc2lvbnMgd2hlbiBvbGQgbm9kZWpzIHN1cHBvcnQgaXMgcmVtb3ZlZCBjYW4gdXNlIG9iamVjdC5hc3NpZ25cbiAgICBpY29udi5lbmNvZGluZ3MgPSB7IF9fcHJvdG9fXzogbnVsbCB9IC8vIEluaXRpYWxpemUgYXMgZW1wdHkgb2JqZWN0LlxuICAgIG1lcmdlTW9kdWxlcyhpY29udi5lbmNvZGluZ3MsIHJhdylcbiAgfVxuXG4gIC8vIENhbm9uaWNhbGl6ZSBlbmNvZGluZyBuYW1lOiBzdHJpcCBhbGwgbm9uLWFscGhhbnVtZXJpYyBjaGFycyBhbmQgYXBwZW5kZWQgeWVhci5cbiAgdmFyIGVuYyA9IGljb252Ll9jYW5vbmljYWxpemVFbmNvZGluZyhlbmNvZGluZylcblxuICAvLyBUcmF2ZXJzZSBpY29udi5lbmNvZGluZ3MgdG8gZmluZCBhY3R1YWwgY29kZWMuXG4gIHZhciBjb2RlY09wdGlvbnMgPSB7fVxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBjb2RlYyA9IGljb252Ll9jb2RlY0RhdGFDYWNoZVtlbmNdXG5cbiAgICBpZiAoY29kZWMpIHsgcmV0dXJuIGNvZGVjIH1cblxuICAgIHZhciBjb2RlY0RlZiA9IGljb252LmVuY29kaW5nc1tlbmNdXG5cbiAgICBzd2l0Y2ggKHR5cGVvZiBjb2RlY0RlZikge1xuICAgICAgY2FzZSBcInN0cmluZ1wiOiAvLyBEaXJlY3QgYWxpYXMgdG8gb3RoZXIgZW5jb2RpbmcuXG4gICAgICAgIGVuYyA9IGNvZGVjRGVmXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCJvYmplY3RcIjogLy8gQWxpYXMgd2l0aCBvcHRpb25zLiBDYW4gYmUgbGF5ZXJlZC5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIGNvZGVjRGVmKSB7IGNvZGVjT3B0aW9uc1trZXldID0gY29kZWNEZWZba2V5XSB9XG5cbiAgICAgICAgaWYgKCFjb2RlY09wdGlvbnMuZW5jb2RpbmdOYW1lKSB7IGNvZGVjT3B0aW9ucy5lbmNvZGluZ05hbWUgPSBlbmMgfVxuXG4gICAgICAgIGVuYyA9IGNvZGVjRGVmLnR5cGVcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6IC8vIENvZGVjIGl0c2VsZi5cbiAgICAgICAgaWYgKCFjb2RlY09wdGlvbnMuZW5jb2RpbmdOYW1lKSB7IGNvZGVjT3B0aW9ucy5lbmNvZGluZ05hbWUgPSBlbmMgfVxuXG4gICAgICAgIC8vIFRoZSBjb2RlYyBmdW5jdGlvbiBtdXN0IGxvYWQgYWxsIHRhYmxlcyBhbmQgcmV0dXJuIG9iamVjdCB3aXRoIC5lbmNvZGVyIGFuZCAuZGVjb2RlciBtZXRob2RzLlxuICAgICAgICAvLyBJdCdsbCBiZSBjYWxsZWQgb25seSBvbmNlIChmb3IgZWFjaCBkaWZmZXJlbnQgb3B0aW9ucyBvYmplY3QpLlxuICAgICAgICAvL1xuICAgICAgICBjb2RlYyA9IG5ldyBjb2RlY0RlZihjb2RlY09wdGlvbnMsIGljb252KVxuXG4gICAgICAgIGljb252Ll9jb2RlY0RhdGFDYWNoZVtjb2RlY09wdGlvbnMuZW5jb2RpbmdOYW1lXSA9IGNvZGVjIC8vIFNhdmUgaXQgdG8gYmUgcmV1c2VkIGxhdGVyLlxuICAgICAgICByZXR1cm4gY29kZWNcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW5jb2Rpbmcgbm90IHJlY29nbml6ZWQ6ICdcIiArIGVuY29kaW5nICsgXCInIChzZWFyY2hlZCBhczogJ1wiICsgZW5jICsgXCInKVwiKVxuICAgIH1cbiAgfVxufVxuXG5pY29udi5fY2Fub25pY2FsaXplRW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgLy8gQ2Fub25pY2FsaXplIGVuY29kaW5nIG5hbWU6IHN0cmlwIGFsbCBub24tYWxwaGFudW1lcmljIGNoYXJzIGFuZCBhcHBlbmRlZCB5ZWFyLlxuICByZXR1cm4gKFwiXCIgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC86XFxkezR9JHxbXjAtOWEtel0vZywgXCJcIilcbn1cblxuaWNvbnYuZ2V0RW5jb2RlciA9IGZ1bmN0aW9uIGdldEVuY29kZXIgKGVuY29kaW5nLCBvcHRpb25zKSB7XG4gIHZhciBjb2RlYyA9IGljb252LmdldENvZGVjKGVuY29kaW5nKVxuICB2YXIgZW5jb2RlciA9IG5ldyBjb2RlYy5lbmNvZGVyKG9wdGlvbnMsIGNvZGVjKVxuXG4gIGlmIChjb2RlYy5ib21Bd2FyZSAmJiBvcHRpb25zICYmIG9wdGlvbnMuYWRkQk9NKSB7IGVuY29kZXIgPSBuZXcgYm9tSGFuZGxpbmcuUHJlcGVuZEJPTShlbmNvZGVyLCBvcHRpb25zKSB9XG5cbiAgcmV0dXJuIGVuY29kZXJcbn1cblxuaWNvbnYuZ2V0RGVjb2RlciA9IGZ1bmN0aW9uIGdldERlY29kZXIgKGVuY29kaW5nLCBvcHRpb25zKSB7XG4gIHZhciBjb2RlYyA9IGljb252LmdldENvZGVjKGVuY29kaW5nKVxuICB2YXIgZGVjb2RlciA9IG5ldyBjb2RlYy5kZWNvZGVyKG9wdGlvbnMsIGNvZGVjKVxuXG4gIGlmIChjb2RlYy5ib21Bd2FyZSAmJiAhKG9wdGlvbnMgJiYgb3B0aW9ucy5zdHJpcEJPTSA9PT0gZmFsc2UpKSB7IGRlY29kZXIgPSBuZXcgYm9tSGFuZGxpbmcuU3RyaXBCT00oZGVjb2Rlciwgb3B0aW9ucykgfVxuXG4gIHJldHVybiBkZWNvZGVyXG59XG5cbi8vIFN0cmVhbWluZyBBUElcbi8vIE5PVEU6IFN0cmVhbWluZyBBUEkgbmF0dXJhbGx5IGRlcGVuZHMgb24gJ3N0cmVhbScgbW9kdWxlIGZyb20gTm9kZS5qcy4gVW5mb3J0dW5hdGVseSBpbiBicm93c2VyIGVudmlyb25tZW50cyB0aGlzIG1vZHVsZSBjYW4gYWRkXG4vLyB1cCB0byAxMDBLYiB0byB0aGUgb3V0cHV0IGJ1bmRsZS4gVG8gYXZvaWQgdW5uZWNlc3NhcnkgY29kZSBibG9hdCwgd2UgZG9uJ3QgZW5hYmxlIFN0cmVhbWluZyBBUEkgaW4gYnJvd3NlciBieSBkZWZhdWx0LlxuLy8gSWYgeW91IHdvdWxkIGxpa2UgdG8gZW5hYmxlIGl0IGV4cGxpY2l0bHksIHBsZWFzZSBhZGQgdGhlIGZvbGxvd2luZyBjb2RlIHRvIHlvdXIgYXBwOlxuLy8gPiBpY29udi5lbmFibGVTdHJlYW1pbmdBUEkocmVxdWlyZSgnc3RyZWFtJykpO1xuaWNvbnYuZW5hYmxlU3RyZWFtaW5nQVBJID0gZnVuY3Rpb24gZW5hYmxlU3RyZWFtaW5nQVBJIChzdHJlYW1Nb2R1bGUpIHtcbiAgaWYgKGljb252LnN1cHBvcnRzU3RyZWFtcykgeyByZXR1cm4gfVxuXG4gIC8vIERlcGVuZGVuY3ktaW5qZWN0IHN0cmVhbSBtb2R1bGUgdG8gY3JlYXRlIEljb252TGl0ZSBzdHJlYW0gY2xhc3Nlcy5cbiAgdmFyIHN0cmVhbXMgPSByZXF1aXJlKFwiLi9zdHJlYW1zXCIpKHN0cmVhbU1vZHVsZSlcblxuICAvLyBOb3QgcHVibGljIEFQSSB5ZXQsIGJ1dCBleHBvc2UgdGhlIHN0cmVhbSBjbGFzc2VzLlxuICBpY29udi5JY29udkxpdGVFbmNvZGVyU3RyZWFtID0gc3RyZWFtcy5JY29udkxpdGVFbmNvZGVyU3RyZWFtXG4gIGljb252Lkljb252TGl0ZURlY29kZXJTdHJlYW0gPSBzdHJlYW1zLkljb252TGl0ZURlY29kZXJTdHJlYW1cblxuICAvLyBTdHJlYW1pbmcgQVBJLlxuICBpY29udi5lbmNvZGVTdHJlYW0gPSBmdW5jdGlvbiBlbmNvZGVTdHJlYW0gKGVuY29kaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBpY29udi5JY29udkxpdGVFbmNvZGVyU3RyZWFtKGljb252LmdldEVuY29kZXIoZW5jb2RpbmcsIG9wdGlvbnMpLCBvcHRpb25zKVxuICB9XG5cbiAgaWNvbnYuZGVjb2RlU3RyZWFtID0gZnVuY3Rpb24gZGVjb2RlU3RyZWFtIChlbmNvZGluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgaWNvbnYuSWNvbnZMaXRlRGVjb2RlclN0cmVhbShpY29udi5nZXREZWNvZGVyKGVuY29kaW5nLCBvcHRpb25zKSwgb3B0aW9ucylcbiAgfVxuXG4gIGljb252LnN1cHBvcnRzU3RyZWFtcyA9IHRydWVcbn1cblxuLy8gRW5hYmxlIFN0cmVhbWluZyBBUEkgYXV0b21hdGljYWxseSBpZiAnc3RyZWFtJyBtb2R1bGUgaXMgYXZhaWxhYmxlIGFuZCBub24tZW1wdHkgKHRoZSBtYWpvcml0eSBvZiBlbnZpcm9ubWVudHMpLlxudmFyIHN0cmVhbU1vZHVsZVxudHJ5IHtcbiAgc3RyZWFtTW9kdWxlID0gcmVxdWlyZShcInN0cmVhbVwiKVxufSBjYXRjaCAoZSkge31cblxuaWYgKHN0cmVhbU1vZHVsZSAmJiBzdHJlYW1Nb2R1bGUuVHJhbnNmb3JtKSB7XG4gIGljb252LmVuYWJsZVN0cmVhbWluZ0FQSShzdHJlYW1Nb2R1bGUpXG59IGVsc2Uge1xuICAvLyBJbiByYXJlIGNhc2VzIHdoZXJlICdzdHJlYW0nIG1vZHVsZSBpcyBub3QgYXZhaWxhYmxlIGJ5IGRlZmF1bHQsIHRocm93IGEgaGVscGZ1bCBleGNlcHRpb24uXG4gIGljb252LmVuY29kZVN0cmVhbSA9IGljb252LmRlY29kZVN0cmVhbSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpY29udi1saXRlIFN0cmVhbWluZyBBUEkgaXMgbm90IGVuYWJsZWQuIFVzZSBpY29udi5lbmFibGVTdHJlYW1pbmdBUEkocmVxdWlyZSgnc3RyZWFtJykpOyB0byBlbmFibGUgaXQuXCIpXG4gIH1cbn1cblxuLy8gU29tZSBlbnZpcm9ubWVudHMsIHN1Y2ggYXMgYnJvd3NlcnMsIG1heSBub3QgbG9hZCBKYXZhU2NyaXB0IGZpbGVzIGFzIFVURi04XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG5pZiAoXCLEgFwiICE9PSBcIlxcdTAxMDBcIikge1xuICBjb25zb2xlLmVycm9yKFwiaWNvbnYtbGl0ZSB3YXJuaW5nOiBqcyBmaWxlcyB1c2Ugbm9uLXV0ZjggZW5jb2RpbmcuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYXNodHVjaGtpbi9pY29udi1saXRlL3dpa2kvSmF2YXNjcmlwdC1zb3VyY2UtZmlsZS1lbmNvZGluZ3MgZm9yIG1vcmUgaW5mby5cIilcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/mailparser/node_modules/iconv-lite/lib/index.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/mailparser/node_modules/iconv-lite/lib/streams.js":
/*!*************************************************************************!*\
  !*** ../node_modules/mailparser/node_modules/iconv-lite/lib/streams.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar Buffer = (__webpack_require__(/*! safer-buffer */ \"(rsc)/../node_modules/safer-buffer/safer.js\").Buffer)\n\n// NOTE: Due to 'stream' module being pretty large (~100Kb, significant in browser environments),\n// we opt to dependency-inject it instead of creating a hard dependency.\nmodule.exports = function (streamModule) {\n  var Transform = streamModule.Transform\n\n  // == Encoder stream =======================================================\n\n  function IconvLiteEncoderStream (conv, options) {\n    this.conv = conv\n    options = options || {}\n    options.decodeStrings = false // We accept only strings, so we don't need to decode them.\n    Transform.call(this, options)\n  }\n\n  IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {\n    constructor: { value: IconvLiteEncoderStream }\n  })\n\n  IconvLiteEncoderStream.prototype._transform = function (chunk, encoding, done) {\n    if (typeof chunk !== \"string\") {\n      return done(new Error(\"Iconv encoding stream needs strings as its input.\"))\n    }\n\n    try {\n      var res = this.conv.write(chunk)\n      if (res && res.length) this.push(res)\n      done()\n    } catch (e) {\n      done(e)\n    }\n  }\n\n  IconvLiteEncoderStream.prototype._flush = function (done) {\n    try {\n      var res = this.conv.end()\n      if (res && res.length) this.push(res)\n      done()\n    } catch (e) {\n      done(e)\n    }\n  }\n\n  IconvLiteEncoderStream.prototype.collect = function (cb) {\n    var chunks = []\n    this.on(\"error\", cb)\n    this.on(\"data\", function (chunk) { chunks.push(chunk) })\n    this.on(\"end\", function () {\n      cb(null, Buffer.concat(chunks))\n    })\n    return this\n  }\n\n  // == Decoder stream =======================================================\n\n  function IconvLiteDecoderStream (conv, options) {\n    this.conv = conv\n    options = options || {}\n    options.encoding = this.encoding = \"utf8\" // We output strings.\n    Transform.call(this, options)\n  }\n\n  IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {\n    constructor: { value: IconvLiteDecoderStream }\n  })\n\n  IconvLiteDecoderStream.prototype._transform = function (chunk, encoding, done) {\n    if (!Buffer.isBuffer(chunk) && !(chunk instanceof Uint8Array)) { return done(new Error(\"Iconv decoding stream needs buffers as its input.\")) }\n    try {\n      var res = this.conv.write(chunk)\n      if (res && res.length) this.push(res, this.encoding)\n      done()\n    } catch (e) {\n      done(e)\n    }\n  }\n\n  IconvLiteDecoderStream.prototype._flush = function (done) {\n    try {\n      var res = this.conv.end()\n      if (res && res.length) this.push(res, this.encoding)\n      done()\n    } catch (e) {\n      done(e)\n    }\n  }\n\n  IconvLiteDecoderStream.prototype.collect = function (cb) {\n    var res = \"\"\n    this.on(\"error\", cb)\n    this.on(\"data\", function (chunk) { res += chunk })\n    this.on(\"end\", function () {\n      cb(null, res)\n    })\n    return this\n  }\n\n  return {\n    IconvLiteEncoderStream: IconvLiteEncoderStream,\n    IconvLiteDecoderStream: IconvLiteDecoderStream\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL21haWxwYXJzZXIvbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvbGliL3N0cmVhbXMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosYUFBYSwrRkFBOEI7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjtBQUNuQixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsb0JBQW9CO0FBQzNEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUI7QUFDbkIsR0FBRzs7QUFFSDtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGNBQWM7QUFDckQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xca2ZyeXRcXC5nZW1pbmlcXGFudGlncmF2aXR5XFxzY3JhdGNoXFxkcl9rYWxzX3ZpcnR1YWxfaG9zcGl0YWxcXG5vZGVfbW9kdWxlc1xcbWFpbHBhcnNlclxcbm9kZV9tb2R1bGVzXFxpY29udi1saXRlXFxsaWJcXHN0cmVhbXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoXCJzYWZlci1idWZmZXJcIikuQnVmZmVyXG5cbi8vIE5PVEU6IER1ZSB0byAnc3RyZWFtJyBtb2R1bGUgYmVpbmcgcHJldHR5IGxhcmdlICh+MTAwS2IsIHNpZ25pZmljYW50IGluIGJyb3dzZXIgZW52aXJvbm1lbnRzKSxcbi8vIHdlIG9wdCB0byBkZXBlbmRlbmN5LWluamVjdCBpdCBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgaGFyZCBkZXBlbmRlbmN5LlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyZWFtTW9kdWxlKSB7XG4gIHZhciBUcmFuc2Zvcm0gPSBzdHJlYW1Nb2R1bGUuVHJhbnNmb3JtXG5cbiAgLy8gPT0gRW5jb2RlciBzdHJlYW0gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIEljb252TGl0ZUVuY29kZXJTdHJlYW0gKGNvbnYsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmNvbnYgPSBjb252XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgICBvcHRpb25zLmRlY29kZVN0cmluZ3MgPSBmYWxzZSAvLyBXZSBhY2NlcHQgb25seSBzdHJpbmdzLCBzbyB3ZSBkb24ndCBuZWVkIHRvIGRlY29kZSB0aGVtLlxuICAgIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpXG4gIH1cblxuICBJY29udkxpdGVFbmNvZGVyU3RyZWFtLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVHJhbnNmb3JtLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBJY29udkxpdGVFbmNvZGVyU3RyZWFtIH1cbiAgfSlcblxuICBJY29udkxpdGVFbmNvZGVyU3RyZWFtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgZG9uZSkge1xuICAgIGlmICh0eXBlb2YgY2h1bmsgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBkb25lKG5ldyBFcnJvcihcIkljb252IGVuY29kaW5nIHN0cmVhbSBuZWVkcyBzdHJpbmdzIGFzIGl0cyBpbnB1dC5cIikpXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHZhciByZXMgPSB0aGlzLmNvbnYud3JpdGUoY2h1bmspXG4gICAgICBpZiAocmVzICYmIHJlcy5sZW5ndGgpIHRoaXMucHVzaChyZXMpXG4gICAgICBkb25lKClcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkb25lKGUpXG4gICAgfVxuICB9XG5cbiAgSWNvbnZMaXRlRW5jb2RlclN0cmVhbS5wcm90b3R5cGUuX2ZsdXNoID0gZnVuY3Rpb24gKGRvbmUpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHJlcyA9IHRoaXMuY29udi5lbmQoKVxuICAgICAgaWYgKHJlcyAmJiByZXMubGVuZ3RoKSB0aGlzLnB1c2gocmVzKVxuICAgICAgZG9uZSgpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZG9uZShlKVxuICAgIH1cbiAgfVxuXG4gIEljb252TGl0ZUVuY29kZXJTdHJlYW0ucHJvdG90eXBlLmNvbGxlY3QgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICB2YXIgY2h1bmtzID0gW11cbiAgICB0aGlzLm9uKFwiZXJyb3JcIiwgY2IpXG4gICAgdGhpcy5vbihcImRhdGFcIiwgZnVuY3Rpb24gKGNodW5rKSB7IGNodW5rcy5wdXNoKGNodW5rKSB9KVxuICAgIHRoaXMub24oXCJlbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgY2IobnVsbCwgQnVmZmVyLmNvbmNhdChjaHVua3MpKVxuICAgIH0pXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vID09IERlY29kZXIgc3RyZWFtID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBJY29udkxpdGVEZWNvZGVyU3RyZWFtIChjb252LCBvcHRpb25zKSB7XG4gICAgdGhpcy5jb252ID0gY29udlxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gICAgb3B0aW9ucy5lbmNvZGluZyA9IHRoaXMuZW5jb2RpbmcgPSBcInV0ZjhcIiAvLyBXZSBvdXRwdXQgc3RyaW5ncy5cbiAgICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKVxuICB9XG5cbiAgSWNvbnZMaXRlRGVjb2RlclN0cmVhbS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRyYW5zZm9ybS5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogSWNvbnZMaXRlRGVjb2RlclN0cmVhbSB9XG4gIH0pXG5cbiAgSWNvbnZMaXRlRGVjb2RlclN0cmVhbS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGRvbmUpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiYgIShjaHVuayBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7IHJldHVybiBkb25lKG5ldyBFcnJvcihcIkljb252IGRlY29kaW5nIHN0cmVhbSBuZWVkcyBidWZmZXJzIGFzIGl0cyBpbnB1dC5cIikpIH1cbiAgICB0cnkge1xuICAgICAgdmFyIHJlcyA9IHRoaXMuY29udi53cml0ZShjaHVuaylcbiAgICAgIGlmIChyZXMgJiYgcmVzLmxlbmd0aCkgdGhpcy5wdXNoKHJlcywgdGhpcy5lbmNvZGluZylcbiAgICAgIGRvbmUoKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGRvbmUoZSlcbiAgICB9XG4gIH1cblxuICBJY29udkxpdGVEZWNvZGVyU3RyZWFtLnByb3RvdHlwZS5fZmx1c2ggPSBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgcmVzID0gdGhpcy5jb252LmVuZCgpXG4gICAgICBpZiAocmVzICYmIHJlcy5sZW5ndGgpIHRoaXMucHVzaChyZXMsIHRoaXMuZW5jb2RpbmcpXG4gICAgICBkb25lKClcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkb25lKGUpXG4gICAgfVxuICB9XG5cbiAgSWNvbnZMaXRlRGVjb2RlclN0cmVhbS5wcm90b3R5cGUuY29sbGVjdCA9IGZ1bmN0aW9uIChjYikge1xuICAgIHZhciByZXMgPSBcIlwiXG4gICAgdGhpcy5vbihcImVycm9yXCIsIGNiKVxuICAgIHRoaXMub24oXCJkYXRhXCIsIGZ1bmN0aW9uIChjaHVuaykgeyByZXMgKz0gY2h1bmsgfSlcbiAgICB0aGlzLm9uKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNiKG51bGwsIHJlcylcbiAgICB9KVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICByZXR1cm4ge1xuICAgIEljb252TGl0ZUVuY29kZXJTdHJlYW06IEljb252TGl0ZUVuY29kZXJTdHJlYW0sXG4gICAgSWNvbnZMaXRlRGVjb2RlclN0cmVhbTogSWNvbnZMaXRlRGVjb2RlclN0cmVhbVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/mailparser/node_modules/iconv-lite/lib/streams.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/mailparser/node_modules/nodemailer/lib/addressparser/index.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/mailparser/node_modules/nodemailer/lib/addressparser/index.js ***!
  \*************************************************************************************/
/***/ ((module) => {

eval("\n\n/**\n * Converts tokens for a single address into an address object\n *\n * @param {Array} tokens Tokens object\n * @param {Number} depth Current recursion depth for nested group protection\n * @return {Object} Address object\n */\nfunction _handleAddress(tokens, depth) {\n    let isGroup = false;\n    let state = 'text';\n    let address;\n    let addresses = [];\n    let data = {\n        address: [],\n        comment: [],\n        group: [],\n        text: [],\n        textWasQuoted: [] // Track which text tokens came from inside quotes\n    };\n    let i;\n    let len;\n    let insideQuotes = false; // Track if we're currently inside a quoted string\n\n    // Filter out <addresses>, (comments) and regular text\n    for (i = 0, len = tokens.length; i < len; i++) {\n        let token = tokens[i];\n        let prevToken = i ? tokens[i - 1] : null;\n        if (token.type === 'operator') {\n            switch (token.value) {\n                case '<':\n                    state = 'address';\n                    insideQuotes = false;\n                    break;\n                case '(':\n                    state = 'comment';\n                    insideQuotes = false;\n                    break;\n                case ':':\n                    state = 'group';\n                    isGroup = true;\n                    insideQuotes = false;\n                    break;\n                case '\"':\n                    // Track quote state for text tokens\n                    insideQuotes = !insideQuotes;\n                    state = 'text';\n                    break;\n                default:\n                    state = 'text';\n                    insideQuotes = false;\n                    break;\n            }\n        } else if (token.value) {\n            if (state === 'address') {\n                // handle use case where unquoted name includes a \"<\"\n                // Apple Mail truncates everything between an unexpected < and an address\n                // and so will we\n                token.value = token.value.replace(/^[^<]*<\\s*/, '');\n            }\n\n            if (prevToken && prevToken.noBreak && data[state].length) {\n                // join values\n                data[state][data[state].length - 1] += token.value;\n                if (state === 'text' && insideQuotes) {\n                    data.textWasQuoted[data.textWasQuoted.length - 1] = true;\n                }\n            } else {\n                data[state].push(token.value);\n                if (state === 'text') {\n                    data.textWasQuoted.push(insideQuotes);\n                }\n            }\n        }\n    }\n\n    // If there is no text but a comment, replace the two\n    if (!data.text.length && data.comment.length) {\n        data.text = data.comment;\n        data.comment = [];\n    }\n\n    if (isGroup) {\n        // http://tools.ietf.org/html/rfc2822#appendix-A.1.3\n        data.text = data.text.join(' ');\n\n        // Parse group members, but flatten any nested groups (RFC 5322 doesn't allow nesting)\n        let groupMembers = [];\n        if (data.group.length) {\n            let parsedGroup = addressparser(data.group.join(','), { _depth: depth + 1 });\n            // Flatten: if any member is itself a group, extract its members into the sequence\n            parsedGroup.forEach(member => {\n                if (member.group) {\n                    // Nested group detected - flatten it by adding its members directly\n                    groupMembers = groupMembers.concat(member.group);\n                } else {\n                    groupMembers.push(member);\n                }\n            });\n        }\n\n        addresses.push({\n            name: data.text || (address && address.name),\n            group: groupMembers\n        });\n    } else {\n        // If no address was found, try to detect one from regular text\n        if (!data.address.length && data.text.length) {\n            for (i = data.text.length - 1; i >= 0; i--) {\n                // Security fix: Do not extract email addresses from quoted strings\n                // RFC 5321 allows @ inside quoted local-parts like \"user@domain\"@example.com\n                // Extracting emails from quoted text leads to misrouting vulnerabilities\n                if (!data.textWasQuoted[i] && data.text[i].match(/^[^@\\s]+@[^@\\s]+$/)) {\n                    data.address = data.text.splice(i, 1);\n                    data.textWasQuoted.splice(i, 1);\n                    break;\n                }\n            }\n\n            let _regexHandler = function (address) {\n                if (!data.address.length) {\n                    data.address = [address.trim()];\n                    return ' ';\n                } else {\n                    return address;\n                }\n            };\n\n            // still no address\n            if (!data.address.length) {\n                for (i = data.text.length - 1; i >= 0; i--) {\n                    // Security fix: Do not extract email addresses from quoted strings\n                    if (!data.textWasQuoted[i]) {\n                        // fixed the regex to parse email address correctly when email address has more than one @\n                        data.text[i] = data.text[i].replace(/\\s*\\b[^@\\s]+@[^\\s]+\\b\\s*/, _regexHandler).trim();\n                        if (data.address.length) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        // If there's still is no text but a comment exixts, replace the two\n        if (!data.text.length && data.comment.length) {\n            data.text = data.comment;\n            data.comment = [];\n        }\n\n        // Keep only the first address occurence, push others to regular text\n        if (data.address.length > 1) {\n            data.text = data.text.concat(data.address.splice(1));\n        }\n\n        // Join values with spaces\n        data.text = data.text.join(' ');\n        data.address = data.address.join(' ');\n\n        if (!data.address && isGroup) {\n            return [];\n        } else {\n            address = {\n                address: data.address || data.text || '',\n                name: data.text || data.address || ''\n            };\n\n            if (address.address === address.name) {\n                if ((address.address || '').match(/@/)) {\n                    address.name = '';\n                } else {\n                    address.address = '';\n                }\n            }\n\n            addresses.push(address);\n        }\n    }\n\n    return addresses;\n}\n\n/**\n * Creates a Tokenizer object for tokenizing address field strings\n *\n * @constructor\n * @param {String} str Address field string\n */\nclass Tokenizer {\n    constructor(str) {\n        this.str = (str || '').toString();\n        this.operatorCurrent = '';\n        this.operatorExpecting = '';\n        this.node = null;\n        this.escaped = false;\n\n        this.list = [];\n        /**\n         * Operator tokens and which tokens are expected to end the sequence\n         */\n        this.operators = {\n            '\"': '\"',\n            '(': ')',\n            '<': '>',\n            ',': '',\n            ':': ';',\n            // Semicolons are not a legal delimiter per the RFC2822 grammar other\n            // than for terminating a group, but they are also not valid for any\n            // other use in this context.  Given that some mail clients have\n            // historically allowed the semicolon as a delimiter equivalent to the\n            // comma in their UI, it makes sense to treat them the same as a comma\n            // when used outside of a group.\n            ';': ''\n        };\n    }\n\n    /**\n     * Tokenizes the original input string\n     *\n     * @return {Array} An array of operator|text tokens\n     */\n    tokenize() {\n        let list = [];\n\n        for (let i = 0, len = this.str.length; i < len; i++) {\n            let chr = this.str.charAt(i);\n            let nextChr = i < len - 1 ? this.str.charAt(i + 1) : null;\n            this.checkChar(chr, nextChr);\n        }\n\n        this.list.forEach(node => {\n            node.value = (node.value || '').toString().trim();\n            if (node.value) {\n                list.push(node);\n            }\n        });\n\n        return list;\n    }\n\n    /**\n     * Checks if a character is an operator or text and acts accordingly\n     *\n     * @param {String} chr Character from the address field\n     */\n    checkChar(chr, nextChr) {\n        if (this.escaped) {\n            // ignore next condition blocks\n        } else if (chr === this.operatorExpecting) {\n            this.node = {\n                type: 'operator',\n                value: chr\n            };\n\n            if (nextChr && ![' ', '\\t', '\\r', '\\n', ',', ';'].includes(nextChr)) {\n                this.node.noBreak = true;\n            }\n\n            this.list.push(this.node);\n            this.node = null;\n            this.operatorExpecting = '';\n            this.escaped = false;\n\n            return;\n        } else if (!this.operatorExpecting && chr in this.operators) {\n            this.node = {\n                type: 'operator',\n                value: chr\n            };\n            this.list.push(this.node);\n            this.node = null;\n            this.operatorExpecting = this.operators[chr];\n            this.escaped = false;\n            return;\n        } else if (['\"', \"'\"].includes(this.operatorExpecting) && chr === '\\\\') {\n            this.escaped = true;\n            return;\n        }\n\n        if (!this.node) {\n            this.node = {\n                type: 'text',\n                value: ''\n            };\n            this.list.push(this.node);\n        }\n\n        if (chr === '\\n') {\n            // Convert newlines to spaces. Carriage return is ignored as \\r and \\n usually\n            // go together anyway and there already is a WS for \\n. Lone \\r means something is fishy.\n            chr = ' ';\n        }\n\n        if (chr.charCodeAt(0) >= 0x21 || [' ', '\\t'].includes(chr)) {\n            // skip command bytes\n            this.node.value += chr;\n        }\n\n        this.escaped = false;\n    }\n}\n\n/**\n * Maximum recursion depth for parsing nested groups.\n * RFC 5322 doesn't allow nested groups, so this is a safeguard against\n * malicious input that could cause stack overflow.\n */\nconst MAX_NESTED_GROUP_DEPTH = 50;\n\n/**\n * Parses structured e-mail addresses from an address field\n *\n * Example:\n *\n *    'Name <address@domain>'\n *\n * will be converted to\n *\n *     [{name: 'Name', address: 'address@domain'}]\n *\n * @param {String} str Address field\n * @param {Object} options Optional options object\n * @param {Number} options._depth Internal recursion depth counter (do not set manually)\n * @return {Array} An array of address objects\n */\nfunction addressparser(str, options) {\n    options = options || {};\n    let depth = options._depth || 0;\n\n    // Prevent stack overflow from deeply nested groups (DoS protection)\n    if (depth > MAX_NESTED_GROUP_DEPTH) {\n        return [];\n    }\n\n    let tokenizer = new Tokenizer(str);\n    let tokens = tokenizer.tokenize();\n\n    let addresses = [];\n    let address = [];\n    let parsedAddresses = [];\n\n    tokens.forEach(token => {\n        if (token.type === 'operator' && (token.value === ',' || token.value === ';')) {\n            if (address.length) {\n                addresses.push(address);\n            }\n            address = [];\n        } else {\n            address.push(token);\n        }\n    });\n\n    if (address.length) {\n        addresses.push(address);\n    }\n\n    addresses.forEach(address => {\n        address = _handleAddress(address, depth);\n        if (address.length) {\n            parsedAddresses = parsedAddresses.concat(address);\n        }\n    });\n\n    if (options.flatten) {\n        let addresses = [];\n        let walkAddressList = list => {\n            list.forEach(address => {\n                if (address.group) {\n                    return walkAddressList(address.group);\n                } else {\n                    addresses.push(address);\n                }\n            });\n        };\n        walkAddressList(parsedAddresses);\n        return addresses;\n    }\n\n    return parsedAddresses;\n}\n\n// expose to the world\nmodule.exports = addressparser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL21haWxwYXJzZXIvbm9kZV9tb2R1bGVzL25vZGVtYWlsZXIvbGliL2FkZHJlc3NwYXJzZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxtQkFBbUI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0MsU0FBUztBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyREFBMkQ7QUFDM0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHdDQUF3QztBQUNqRDtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGtmcnl0XFwuZ2VtaW5pXFxhbnRpZ3Jhdml0eVxcc2NyYXRjaFxcZHJfa2Fsc192aXJ0dWFsX2hvc3BpdGFsXFxub2RlX21vZHVsZXNcXG1haWxwYXJzZXJcXG5vZGVfbW9kdWxlc1xcbm9kZW1haWxlclxcbGliXFxhZGRyZXNzcGFyc2VyXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29udmVydHMgdG9rZW5zIGZvciBhIHNpbmdsZSBhZGRyZXNzIGludG8gYW4gYWRkcmVzcyBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB0b2tlbnMgVG9rZW5zIG9iamVjdFxuICogQHBhcmFtIHtOdW1iZXJ9IGRlcHRoIEN1cnJlbnQgcmVjdXJzaW9uIGRlcHRoIGZvciBuZXN0ZWQgZ3JvdXAgcHJvdGVjdGlvblxuICogQHJldHVybiB7T2JqZWN0fSBBZGRyZXNzIG9iamVjdFxuICovXG5mdW5jdGlvbiBfaGFuZGxlQWRkcmVzcyh0b2tlbnMsIGRlcHRoKSB7XG4gICAgbGV0IGlzR3JvdXAgPSBmYWxzZTtcbiAgICBsZXQgc3RhdGUgPSAndGV4dCc7XG4gICAgbGV0IGFkZHJlc3M7XG4gICAgbGV0IGFkZHJlc3NlcyA9IFtdO1xuICAgIGxldCBkYXRhID0ge1xuICAgICAgICBhZGRyZXNzOiBbXSxcbiAgICAgICAgY29tbWVudDogW10sXG4gICAgICAgIGdyb3VwOiBbXSxcbiAgICAgICAgdGV4dDogW10sXG4gICAgICAgIHRleHRXYXNRdW90ZWQ6IFtdIC8vIFRyYWNrIHdoaWNoIHRleHQgdG9rZW5zIGNhbWUgZnJvbSBpbnNpZGUgcXVvdGVzXG4gICAgfTtcbiAgICBsZXQgaTtcbiAgICBsZXQgbGVuO1xuICAgIGxldCBpbnNpZGVRdW90ZXMgPSBmYWxzZTsgLy8gVHJhY2sgaWYgd2UncmUgY3VycmVudGx5IGluc2lkZSBhIHF1b3RlZCBzdHJpbmdcblxuICAgIC8vIEZpbHRlciBvdXQgPGFkZHJlc3Nlcz4sIChjb21tZW50cykgYW5kIHJlZ3VsYXIgdGV4dFxuICAgIGZvciAoaSA9IDAsIGxlbiA9IHRva2Vucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBsZXQgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgIGxldCBwcmV2VG9rZW4gPSBpID8gdG9rZW5zW2kgLSAxXSA6IG51bGw7XG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSAnb3BlcmF0b3InKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRva2VuLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gJ2FkZHJlc3MnO1xuICAgICAgICAgICAgICAgICAgICBpbnNpZGVRdW90ZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnKCc6XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gJ2NvbW1lbnQnO1xuICAgICAgICAgICAgICAgICAgICBpbnNpZGVRdW90ZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnOic6XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gJ2dyb3VwJztcbiAgICAgICAgICAgICAgICAgICAgaXNHcm91cCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGluc2lkZVF1b3RlcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyYWNrIHF1b3RlIHN0YXRlIGZvciB0ZXh0IHRva2Vuc1xuICAgICAgICAgICAgICAgICAgICBpbnNpZGVRdW90ZXMgPSAhaW5zaWRlUXVvdGVzO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9ICd0ZXh0JztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAndGV4dCc7XG4gICAgICAgICAgICAgICAgICAgIGluc2lkZVF1b3RlcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0b2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlID09PSAnYWRkcmVzcycpIHtcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgdXNlIGNhc2Ugd2hlcmUgdW5xdW90ZWQgbmFtZSBpbmNsdWRlcyBhIFwiPFwiXG4gICAgICAgICAgICAgICAgLy8gQXBwbGUgTWFpbCB0cnVuY2F0ZXMgZXZlcnl0aGluZyBiZXR3ZWVuIGFuIHVuZXhwZWN0ZWQgPCBhbmQgYW4gYWRkcmVzc1xuICAgICAgICAgICAgICAgIC8vIGFuZCBzbyB3aWxsIHdlXG4gICAgICAgICAgICAgICAgdG9rZW4udmFsdWUgPSB0b2tlbi52YWx1ZS5yZXBsYWNlKC9eW148XSo8XFxzKi8sICcnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHByZXZUb2tlbiAmJiBwcmV2VG9rZW4ubm9CcmVhayAmJiBkYXRhW3N0YXRlXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBqb2luIHZhbHVlc1xuICAgICAgICAgICAgICAgIGRhdGFbc3RhdGVdW2RhdGFbc3RhdGVdLmxlbmd0aCAtIDFdICs9IHRva2VuLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gJ3RleHQnICYmIGluc2lkZVF1b3Rlcykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnRleHRXYXNRdW90ZWRbZGF0YS50ZXh0V2FzUXVvdGVkLmxlbmd0aCAtIDFdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGFbc3RhdGVdLnB1c2godG9rZW4udmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEudGV4dFdhc1F1b3RlZC5wdXNoKGluc2lkZVF1b3Rlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gdGV4dCBidXQgYSBjb21tZW50LCByZXBsYWNlIHRoZSB0d29cbiAgICBpZiAoIWRhdGEudGV4dC5sZW5ndGggJiYgZGF0YS5jb21tZW50Lmxlbmd0aCkge1xuICAgICAgICBkYXRhLnRleHQgPSBkYXRhLmNvbW1lbnQ7XG4gICAgICAgIGRhdGEuY29tbWVudCA9IFtdO1xuICAgIH1cblxuICAgIGlmIChpc0dyb3VwKSB7XG4gICAgICAgIC8vIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI4MjIjYXBwZW5kaXgtQS4xLjNcbiAgICAgICAgZGF0YS50ZXh0ID0gZGF0YS50ZXh0LmpvaW4oJyAnKTtcblxuICAgICAgICAvLyBQYXJzZSBncm91cCBtZW1iZXJzLCBidXQgZmxhdHRlbiBhbnkgbmVzdGVkIGdyb3VwcyAoUkZDIDUzMjIgZG9lc24ndCBhbGxvdyBuZXN0aW5nKVxuICAgICAgICBsZXQgZ3JvdXBNZW1iZXJzID0gW107XG4gICAgICAgIGlmIChkYXRhLmdyb3VwLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHBhcnNlZEdyb3VwID0gYWRkcmVzc3BhcnNlcihkYXRhLmdyb3VwLmpvaW4oJywnKSwgeyBfZGVwdGg6IGRlcHRoICsgMSB9KTtcbiAgICAgICAgICAgIC8vIEZsYXR0ZW46IGlmIGFueSBtZW1iZXIgaXMgaXRzZWxmIGEgZ3JvdXAsIGV4dHJhY3QgaXRzIG1lbWJlcnMgaW50byB0aGUgc2VxdWVuY2VcbiAgICAgICAgICAgIHBhcnNlZEdyb3VwLmZvckVhY2gobWVtYmVyID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobWVtYmVyLmdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5lc3RlZCBncm91cCBkZXRlY3RlZCAtIGZsYXR0ZW4gaXQgYnkgYWRkaW5nIGl0cyBtZW1iZXJzIGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwTWVtYmVycyA9IGdyb3VwTWVtYmVycy5jb25jYXQobWVtYmVyLmdyb3VwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBncm91cE1lbWJlcnMucHVzaChtZW1iZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYWRkcmVzc2VzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogZGF0YS50ZXh0IHx8IChhZGRyZXNzICYmIGFkZHJlc3MubmFtZSksXG4gICAgICAgICAgICBncm91cDogZ3JvdXBNZW1iZXJzXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIG5vIGFkZHJlc3Mgd2FzIGZvdW5kLCB0cnkgdG8gZGV0ZWN0IG9uZSBmcm9tIHJlZ3VsYXIgdGV4dFxuICAgICAgICBpZiAoIWRhdGEuYWRkcmVzcy5sZW5ndGggJiYgZGF0YS50ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yIChpID0gZGF0YS50ZXh0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgLy8gU2VjdXJpdHkgZml4OiBEbyBub3QgZXh0cmFjdCBlbWFpbCBhZGRyZXNzZXMgZnJvbSBxdW90ZWQgc3RyaW5nc1xuICAgICAgICAgICAgICAgIC8vIFJGQyA1MzIxIGFsbG93cyBAIGluc2lkZSBxdW90ZWQgbG9jYWwtcGFydHMgbGlrZSBcInVzZXJAZG9tYWluXCJAZXhhbXBsZS5jb21cbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0aW5nIGVtYWlscyBmcm9tIHF1b3RlZCB0ZXh0IGxlYWRzIHRvIG1pc3JvdXRpbmcgdnVsbmVyYWJpbGl0aWVzXG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhLnRleHRXYXNRdW90ZWRbaV0gJiYgZGF0YS50ZXh0W2ldLm1hdGNoKC9eW15AXFxzXStAW15AXFxzXSskLykpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5hZGRyZXNzID0gZGF0YS50ZXh0LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS50ZXh0V2FzUXVvdGVkLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgX3JlZ2V4SGFuZGxlciA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhLmFkZHJlc3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuYWRkcmVzcyA9IFthZGRyZXNzLnRyaW0oKV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnICc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gc3RpbGwgbm8gYWRkcmVzc1xuICAgICAgICAgICAgaWYgKCFkYXRhLmFkZHJlc3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gZGF0YS50ZXh0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNlY3VyaXR5IGZpeDogRG8gbm90IGV4dHJhY3QgZW1haWwgYWRkcmVzc2VzIGZyb20gcXVvdGVkIHN0cmluZ3NcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhLnRleHRXYXNRdW90ZWRbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpeGVkIHRoZSByZWdleCB0byBwYXJzZSBlbWFpbCBhZGRyZXNzIGNvcnJlY3RseSB3aGVuIGVtYWlsIGFkZHJlc3MgaGFzIG1vcmUgdGhhbiBvbmUgQFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50ZXh0W2ldID0gZGF0YS50ZXh0W2ldLnJlcGxhY2UoL1xccypcXGJbXkBcXHNdK0BbXlxcc10rXFxiXFxzKi8sIF9yZWdleEhhbmRsZXIpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmFkZHJlc3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGVyZSdzIHN0aWxsIGlzIG5vIHRleHQgYnV0IGEgY29tbWVudCBleGl4dHMsIHJlcGxhY2UgdGhlIHR3b1xuICAgICAgICBpZiAoIWRhdGEudGV4dC5sZW5ndGggJiYgZGF0YS5jb21tZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgZGF0YS50ZXh0ID0gZGF0YS5jb21tZW50O1xuICAgICAgICAgICAgZGF0YS5jb21tZW50ID0gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBLZWVwIG9ubHkgdGhlIGZpcnN0IGFkZHJlc3Mgb2NjdXJlbmNlLCBwdXNoIG90aGVycyB0byByZWd1bGFyIHRleHRcbiAgICAgICAgaWYgKGRhdGEuYWRkcmVzcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBkYXRhLnRleHQgPSBkYXRhLnRleHQuY29uY2F0KGRhdGEuYWRkcmVzcy5zcGxpY2UoMSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSm9pbiB2YWx1ZXMgd2l0aCBzcGFjZXNcbiAgICAgICAgZGF0YS50ZXh0ID0gZGF0YS50ZXh0LmpvaW4oJyAnKTtcbiAgICAgICAgZGF0YS5hZGRyZXNzID0gZGF0YS5hZGRyZXNzLmpvaW4oJyAnKTtcblxuICAgICAgICBpZiAoIWRhdGEuYWRkcmVzcyAmJiBpc0dyb3VwKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGRyZXNzID0ge1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IGRhdGEuYWRkcmVzcyB8fCBkYXRhLnRleHQgfHwgJycsXG4gICAgICAgICAgICAgICAgbmFtZTogZGF0YS50ZXh0IHx8IGRhdGEuYWRkcmVzcyB8fCAnJ1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGFkZHJlc3MuYWRkcmVzcyA9PT0gYWRkcmVzcy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKChhZGRyZXNzLmFkZHJlc3MgfHwgJycpLm1hdGNoKC9ALykpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcy5uYW1lID0gJyc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcy5hZGRyZXNzID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhZGRyZXNzZXMucHVzaChhZGRyZXNzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhZGRyZXNzZXM7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIFRva2VuaXplciBvYmplY3QgZm9yIHRva2VuaXppbmcgYWRkcmVzcyBmaWVsZCBzdHJpbmdzXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIEFkZHJlc3MgZmllbGQgc3RyaW5nXG4gKi9cbmNsYXNzIFRva2VuaXplciB7XG4gICAgY29uc3RydWN0b3Ioc3RyKSB7XG4gICAgICAgIHRoaXMuc3RyID0gKHN0ciB8fCAnJykudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5vcGVyYXRvckN1cnJlbnQgPSAnJztcbiAgICAgICAgdGhpcy5vcGVyYXRvckV4cGVjdGluZyA9ICcnO1xuICAgICAgICB0aGlzLm5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmVzY2FwZWQgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLmxpc3QgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wZXJhdG9yIHRva2VucyBhbmQgd2hpY2ggdG9rZW5zIGFyZSBleHBlY3RlZCB0byBlbmQgdGhlIHNlcXVlbmNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wZXJhdG9ycyA9IHtcbiAgICAgICAgICAgICdcIic6ICdcIicsXG4gICAgICAgICAgICAnKCc6ICcpJyxcbiAgICAgICAgICAgICc8JzogJz4nLFxuICAgICAgICAgICAgJywnOiAnJyxcbiAgICAgICAgICAgICc6JzogJzsnLFxuICAgICAgICAgICAgLy8gU2VtaWNvbG9ucyBhcmUgbm90IGEgbGVnYWwgZGVsaW1pdGVyIHBlciB0aGUgUkZDMjgyMiBncmFtbWFyIG90aGVyXG4gICAgICAgICAgICAvLyB0aGFuIGZvciB0ZXJtaW5hdGluZyBhIGdyb3VwLCBidXQgdGhleSBhcmUgYWxzbyBub3QgdmFsaWQgZm9yIGFueVxuICAgICAgICAgICAgLy8gb3RoZXIgdXNlIGluIHRoaXMgY29udGV4dC4gIEdpdmVuIHRoYXQgc29tZSBtYWlsIGNsaWVudHMgaGF2ZVxuICAgICAgICAgICAgLy8gaGlzdG9yaWNhbGx5IGFsbG93ZWQgdGhlIHNlbWljb2xvbiBhcyBhIGRlbGltaXRlciBlcXVpdmFsZW50IHRvIHRoZVxuICAgICAgICAgICAgLy8gY29tbWEgaW4gdGhlaXIgVUksIGl0IG1ha2VzIHNlbnNlIHRvIHRyZWF0IHRoZW0gdGhlIHNhbWUgYXMgYSBjb21tYVxuICAgICAgICAgICAgLy8gd2hlbiB1c2VkIG91dHNpZGUgb2YgYSBncm91cC5cbiAgICAgICAgICAgICc7JzogJydcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2tlbml6ZXMgdGhlIG9yaWdpbmFsIGlucHV0IHN0cmluZ1xuICAgICAqXG4gICAgICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIG9wZXJhdG9yfHRleHQgdG9rZW5zXG4gICAgICovXG4gICAgdG9rZW5pemUoKSB7XG4gICAgICAgIGxldCBsaXN0ID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hyID0gdGhpcy5zdHIuY2hhckF0KGkpO1xuICAgICAgICAgICAgbGV0IG5leHRDaHIgPSBpIDwgbGVuIC0gMSA/IHRoaXMuc3RyLmNoYXJBdChpICsgMSkgOiBudWxsO1xuICAgICAgICAgICAgdGhpcy5jaGVja0NoYXIoY2hyLCBuZXh0Q2hyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGlzdC5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgbm9kZS52YWx1ZSA9IChub2RlLnZhbHVlIHx8ICcnKS50b1N0cmluZygpLnRyaW0oKTtcbiAgICAgICAgICAgIGlmIChub2RlLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBjaGFyYWN0ZXIgaXMgYW4gb3BlcmF0b3Igb3IgdGV4dCBhbmQgYWN0cyBhY2NvcmRpbmdseVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNociBDaGFyYWN0ZXIgZnJvbSB0aGUgYWRkcmVzcyBmaWVsZFxuICAgICAqL1xuICAgIGNoZWNrQ2hhcihjaHIsIG5leHRDaHIpIHtcbiAgICAgICAgaWYgKHRoaXMuZXNjYXBlZCkge1xuICAgICAgICAgICAgLy8gaWdub3JlIG5leHQgY29uZGl0aW9uIGJsb2Nrc1xuICAgICAgICB9IGVsc2UgaWYgKGNociA9PT0gdGhpcy5vcGVyYXRvckV4cGVjdGluZykge1xuICAgICAgICAgICAgdGhpcy5ub2RlID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdvcGVyYXRvcicsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGNoclxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKG5leHRDaHIgJiYgIVsnICcsICdcXHQnLCAnXFxyJywgJ1xcbicsICcsJywgJzsnXS5pbmNsdWRlcyhuZXh0Q2hyKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZS5ub0JyZWFrID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5saXN0LnB1c2godGhpcy5ub2RlKTtcbiAgICAgICAgICAgIHRoaXMubm9kZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm9wZXJhdG9yRXhwZWN0aW5nID0gJyc7XG4gICAgICAgICAgICB0aGlzLmVzY2FwZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLm9wZXJhdG9yRXhwZWN0aW5nICYmIGNociBpbiB0aGlzLm9wZXJhdG9ycykge1xuICAgICAgICAgICAgdGhpcy5ub2RlID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdvcGVyYXRvcicsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGNoclxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMubGlzdC5wdXNoKHRoaXMubm9kZSk7XG4gICAgICAgICAgICB0aGlzLm5vZGUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5vcGVyYXRvckV4cGVjdGluZyA9IHRoaXMub3BlcmF0b3JzW2Nocl07XG4gICAgICAgICAgICB0aGlzLmVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChbJ1wiJywgXCInXCJdLmluY2x1ZGVzKHRoaXMub3BlcmF0b3JFeHBlY3RpbmcpICYmIGNociA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICB0aGlzLmVzY2FwZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLm5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICcnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5saXN0LnB1c2godGhpcy5ub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaHIgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IG5ld2xpbmVzIHRvIHNwYWNlcy4gQ2FycmlhZ2UgcmV0dXJuIGlzIGlnbm9yZWQgYXMgXFxyIGFuZCBcXG4gdXN1YWxseVxuICAgICAgICAgICAgLy8gZ28gdG9nZXRoZXIgYW55d2F5IGFuZCB0aGVyZSBhbHJlYWR5IGlzIGEgV1MgZm9yIFxcbi4gTG9uZSBcXHIgbWVhbnMgc29tZXRoaW5nIGlzIGZpc2h5LlxuICAgICAgICAgICAgY2hyID0gJyAnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoci5jaGFyQ29kZUF0KDApID49IDB4MjEgfHwgWycgJywgJ1xcdCddLmluY2x1ZGVzKGNocikpIHtcbiAgICAgICAgICAgIC8vIHNraXAgY29tbWFuZCBieXRlc1xuICAgICAgICAgICAgdGhpcy5ub2RlLnZhbHVlICs9IGNocjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZXNjYXBlZCA9IGZhbHNlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBNYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aCBmb3IgcGFyc2luZyBuZXN0ZWQgZ3JvdXBzLlxuICogUkZDIDUzMjIgZG9lc24ndCBhbGxvdyBuZXN0ZWQgZ3JvdXBzLCBzbyB0aGlzIGlzIGEgc2FmZWd1YXJkIGFnYWluc3RcbiAqIG1hbGljaW91cyBpbnB1dCB0aGF0IGNvdWxkIGNhdXNlIHN0YWNrIG92ZXJmbG93LlxuICovXG5jb25zdCBNQVhfTkVTVEVEX0dST1VQX0RFUFRIID0gNTA7XG5cbi8qKlxuICogUGFyc2VzIHN0cnVjdHVyZWQgZS1tYWlsIGFkZHJlc3NlcyBmcm9tIGFuIGFkZHJlc3MgZmllbGRcbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICdOYW1lIDxhZGRyZXNzQGRvbWFpbj4nXG4gKlxuICogd2lsbCBiZSBjb252ZXJ0ZWQgdG9cbiAqXG4gKiAgICAgW3tuYW1lOiAnTmFtZScsIGFkZHJlc3M6ICdhZGRyZXNzQGRvbWFpbid9XVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgQWRkcmVzcyBmaWVsZFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLl9kZXB0aCBJbnRlcm5hbCByZWN1cnNpb24gZGVwdGggY291bnRlciAoZG8gbm90IHNldCBtYW51YWxseSlcbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiBhZGRyZXNzIG9iamVjdHNcbiAqL1xuZnVuY3Rpb24gYWRkcmVzc3BhcnNlcihzdHIsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBsZXQgZGVwdGggPSBvcHRpb25zLl9kZXB0aCB8fCAwO1xuXG4gICAgLy8gUHJldmVudCBzdGFjayBvdmVyZmxvdyBmcm9tIGRlZXBseSBuZXN0ZWQgZ3JvdXBzIChEb1MgcHJvdGVjdGlvbilcbiAgICBpZiAoZGVwdGggPiBNQVhfTkVTVEVEX0dST1VQX0RFUFRIKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBsZXQgdG9rZW5pemVyID0gbmV3IFRva2VuaXplcihzdHIpO1xuICAgIGxldCB0b2tlbnMgPSB0b2tlbml6ZXIudG9rZW5pemUoKTtcblxuICAgIGxldCBhZGRyZXNzZXMgPSBbXTtcbiAgICBsZXQgYWRkcmVzcyA9IFtdO1xuICAgIGxldCBwYXJzZWRBZGRyZXNzZXMgPSBbXTtcblxuICAgIHRva2Vucy5mb3JFYWNoKHRva2VuID0+IHtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdvcGVyYXRvcicgJiYgKHRva2VuLnZhbHVlID09PSAnLCcgfHwgdG9rZW4udmFsdWUgPT09ICc7JykpIHtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFkZHJlc3Nlcy5wdXNoKGFkZHJlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkcmVzcyA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWRkcmVzcy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGFkZHJlc3MubGVuZ3RoKSB7XG4gICAgICAgIGFkZHJlc3Nlcy5wdXNoKGFkZHJlc3MpO1xuICAgIH1cblxuICAgIGFkZHJlc3Nlcy5mb3JFYWNoKGFkZHJlc3MgPT4ge1xuICAgICAgICBhZGRyZXNzID0gX2hhbmRsZUFkZHJlc3MoYWRkcmVzcywgZGVwdGgpO1xuICAgICAgICBpZiAoYWRkcmVzcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBhcnNlZEFkZHJlc3NlcyA9IHBhcnNlZEFkZHJlc3Nlcy5jb25jYXQoYWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChvcHRpb25zLmZsYXR0ZW4pIHtcbiAgICAgICAgbGV0IGFkZHJlc3NlcyA9IFtdO1xuICAgICAgICBsZXQgd2Fsa0FkZHJlc3NMaXN0ID0gbGlzdCA9PiB7XG4gICAgICAgICAgICBsaXN0LmZvckVhY2goYWRkcmVzcyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MuZ3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdhbGtBZGRyZXNzTGlzdChhZGRyZXNzLmdyb3VwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzZXMucHVzaChhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgd2Fsa0FkZHJlc3NMaXN0KHBhcnNlZEFkZHJlc3Nlcyk7XG4gICAgICAgIHJldHVybiBhZGRyZXNzZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZEFkZHJlc3Nlcztcbn1cblxuLy8gZXhwb3NlIHRvIHRoZSB3b3JsZFxubW9kdWxlLmV4cG9ydHMgPSBhZGRyZXNzcGFyc2VyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/mailparser/node_modules/nodemailer/lib/addressparser/index.js\n");

/***/ })

};
;