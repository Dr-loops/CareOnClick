"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./lib/global_sync.js":
/*!****************************!*\
  !*** ./lib/global_sync.js ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   KEYS: () => (/* binding */ KEYS),\n/* harmony export */   SYNC_EVENT: () => (/* binding */ SYNC_EVENT),\n/* harmony export */   addNotification: () => (/* binding */ addNotification),\n/* harmony export */   checkAppointmentCompletion: () => (/* binding */ checkAppointmentCompletion),\n/* harmony export */   deleteAppointment: () => (/* binding */ deleteAppointment),\n/* harmony export */   deleteGlobalMessage: () => (/* binding */ deleteGlobalMessage),\n/* harmony export */   dispatchSync: () => (/* binding */ dispatchSync),\n/* harmony export */   getBookingCount: () => (/* binding */ getBookingCount),\n/* harmony export */   getConfig: () => (/* binding */ getConfig),\n/* harmony export */   getGlobalData: () => (/* binding */ getGlobalData),\n/* harmony export */   logActivity: () => (/* binding */ logActivity),\n/* harmony export */   logAudit: () => (/* binding */ logAudit),\n/* harmony export */   saveAppointment: () => (/* binding */ saveAppointment),\n/* harmony export */   saveGlobalRecord: () => (/* binding */ saveGlobalRecord),\n/* harmony export */   savePatientProfile: () => (/* binding */ savePatientProfile),\n/* harmony export */   savePrescription: () => (/* binding */ savePrescription),\n/* harmony export */   sendGlobalMessage: () => (/* binding */ sendGlobalMessage),\n/* harmony export */   updateAppointment: () => (/* binding */ updateAppointment),\n/* harmony export */   updateAppointmentStatus: () => (/* binding */ updateAppointmentStatus),\n/* harmony export */   updateConfig: () => (/* binding */ updateConfig),\n/* harmony export */   updateNotificationStatus: () => (/* binding */ updateNotificationStatus),\n/* harmony export */   updatePatientVitals: () => (/* binding */ updatePatientVitals),\n/* harmony export */   updatePrescription: () => (/* binding */ updatePrescription)\n/* harmony export */ });\n/* harmony import */ var _integrations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./integrations */ \"(app-pages-browser)/./lib/integrations.js\");\n/* harmony import */ var _socket__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./socket */ \"(app-pages-browser)/./lib/socket.js\");\n/* __next_internal_client_entry_do_not_use__ KEYS,updatePrescription,deleteAppointment,savePatientProfile,SYNC_EVENT,dispatchSync,saveGlobalRecord,updatePatientVitals,sendGlobalMessage,deleteGlobalMessage,getGlobalData,saveAppointment,updateAppointmentStatus,checkAppointmentCompletion,updateAppointment,addNotification,updateNotificationStatus,getBookingCount,logActivity,logAudit,updateConfig,savePrescription,getConfig auto */ \n\n// Keys for LocalStorage\nconst KEYS = {\n    RECORDS: 'dr_kal_global_records',\n    PRESCRIPTIONS: 'dr_kal_prescriptions',\n    VITALS: 'dr_kal_vitals',\n    MESSAGES: 'dr_kal_messages',\n    TASKS: 'dr_kal_tasks',\n    PATIENT_PROFILES: 'dr_kal_patient_profiles',\n    APPOINTMENTS: 'dr_kal_appointments',\n    NOTIFICATIONS: 'dr_kal_notifications',\n    ACTIVITY: 'dr_kal_activity',\n    CONFIG: 'dr_kal_config',\n    EMAIL_LOGS: 'dr_kal_email_logs',\n    AUDIT: 'dr_kal_audit_logs'\n};\n// Helper to push changes to Server DB\nconst syncToServer = async (collection, action, item, id, updates)=>{\n    try {\n        await fetch('/api/db', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                collection,\n                action,\n                item,\n                id,\n                updates\n            })\n        });\n    } catch (e) {\n        console.error(\"Server Write Failed\", e);\n    }\n};\nconst updatePrescription = (rxId, updates)=>{\n    if (false) {}\n    const prescriptions = JSON.parse(localStorage.getItem(KEYS.PRESCRIPTIONS) || '[]');\n    let updatedRx = null;\n    const updated = prescriptions.map((rx)=>{\n        if (rx.id === rxId) {\n            updatedRx = {\n                ...rx,\n                ...updates\n            };\n            return updatedRx;\n        }\n        return rx;\n    });\n    localStorage.setItem(KEYS.PRESCRIPTIONS, JSON.stringify(updated));\n    if (updatedRx && updates.status) {\n        // External Sync & Activity Log\n        (0,_integrations__WEBPACK_IMPORTED_MODULE_0__.syncToExternalSystems)('PRESCRIPTION_UPDATED', {\n            rxId,\n            status: updates.status,\n            patientId: updatedRx.patientId\n        });\n        logAudit({\n            actorName: updates.updatedBy || 'Staff',\n            action: 'DISPATCHED PRESCRIPTION',\n            targetName: \"Prescription #\".concat(rxId),\n            details: 'Updated status to \"'.concat(updates.status, '\"'),\n            notes: JSON.stringify({\n                rxId,\n                status: updates.status\n            })\n        });\n        // Internal Alert for Doctors\n        addNotification({\n            recipientId: 'DOCTOR',\n            professionalName: 'Doctor',\n            type: 'PRESCRIPTION_UPDATED',\n            title: 'Prescription Status Updated',\n            message: \"Pharmacist \".concat(updates.updatedBy || 'Staff', \" updated status of RX-\").concat(rxId, ' to \"').concat(updates.status, '\".'),\n            details: {\n                rxId,\n                status: updates.status,\n                patientId: updatedRx.patientId\n            }\n        });\n    }\n    dispatchSync();\n    return updatedRx;\n};\nconst deleteAppointment = (id)=>{\n    if (false) {}\n    const appointments = JSON.parse(localStorage.getItem(KEYS.APPOINTMENTS) || '[]');\n    const appointmentToDelete = appointments.find((a)=>a.id === id);\n    if (appointmentToDelete) {\n        const filteredAppointments = appointments.filter((a)=>a.id !== id);\n        localStorage.setItem(KEYS.APPOINTMENTS, JSON.stringify(filteredAppointments));\n        syncToServer('appointments', 'delete', null, id);\n        logAudit({\n            actorName: appointmentToDelete.patientName || 'Patient',\n            action: 'CANCELLED APPOINTMENT',\n            targetName: \"Session with \".concat(appointmentToDelete.professionalName),\n            details: \"Cancelled appointment on \".concat(appointmentToDelete.date),\n            notes: \"Appointment ID: \".concat(id)\n        });\n        // Notify Professional of Cancellation\n        addNotification({\n            recipientId: appointmentToDelete.professionalId,\n            professionalName: appointmentToDelete.professionalName,\n            type: 'APPOINTMENT_CANCELLED',\n            title: 'Appointment Cancelled',\n            message: \"\".concat(appointmentToDelete.patientName, \" has cancelled their appointment for \").concat(appointmentToDelete.date, \" at \").concat(appointmentToDelete.time, \".\"),\n            details: {\n                patientName: appointmentToDelete.patientName,\n                date: appointmentToDelete.date,\n                time: appointmentToDelete.time\n            }\n        });\n        dispatchSync();\n        return true;\n    }\n    return false;\n};\nconst savePatientProfile = (userId, profileData)=>{\n    if (false) {}\n    let profiles = JSON.parse(localStorage.getItem(KEYS.PATIENT_PROFILES) || '[]');\n    // Migration: If legacy object format, convert to array\n    if (!Array.isArray(profiles)) {\n        profiles = Object.values(profiles);\n    }\n    const index = profiles.findIndex((p)=>p.userId === userId);\n    const newProfile = {\n        userId,\n        ...profileData,\n        lastUpdated: new Date().toISOString()\n    };\n    if (index !== -1) {\n        profiles[index] = {\n            ...profiles[index],\n            ...newProfile\n        };\n    } else {\n        profiles.push(newProfile);\n    }\n    localStorage.setItem(KEYS.PATIENT_PROFILES, JSON.stringify(profiles));\n    syncToServer('patient_profiles', 'save', newProfile, userId);\n    logAudit({\n        actorName: 'System/User',\n        action: 'UPDATED PROFILE',\n        targetName: \"Patient Profile \".concat(userId),\n        details: 'Updated personal or medical details',\n        notes: \"Profile Update for \".concat(userId)\n    });\n    dispatchSync();\n};\n// Custom Event for cross-component sync\nconst SYNC_EVENT = 'dr_kal_sync';\nconst dispatchSync = ()=>{\n    if (true) {\n        window.dispatchEvent(new Event(SYNC_EVENT));\n    }\n};\nconst saveGlobalRecord = async (record)=>{\n    if (false) {}\n    const records = JSON.parse(localStorage.getItem(KEYS.RECORDS) || '[]');\n    const newRecord = {\n        id: \"REC-\".concat(Date.now()),\n        date: new Date().toLocaleDateString(),\n        time: new Date().toLocaleTimeString([], {\n            hour: '2-digit',\n            minute: '2-digit'\n        }),\n        ...record\n    };\n    records.unshift(newRecord);\n    localStorage.setItem(KEYS.RECORDS, JSON.stringify(records));\n    // Persist to Server Database\n    try {\n        const res = await fetch('/api/records', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                patientId: newRecord.pathNumber,\n                fileName: newRecord.fileName,\n                unit: newRecord.unit,\n                professionalRole: newRecord.professionalRole || 'SCIENTIST',\n                structuredResults: newRecord.structuredResults\n            })\n        });\n        if (!res.ok) {\n            const errData = await res.json();\n            throw new Error(errData.error || 'Failed to sync record to DB');\n        }\n    } catch (err) {\n        console.error(\"Failed to sync record to DB\", err);\n        throw err; // Re-throw so caller can handle it\n    }\n    // External Sync & Activity Log\n    (0,_integrations__WEBPACK_IMPORTED_MODULE_0__.syncToExternalSystems)('RECORD_UPDATED', {\n        recordId: newRecord.id,\n        patientId: newRecord.pathNumber,\n        professionalRole: newRecord.professionalRole,\n        fileName: newRecord.fileName\n    });\n    logAudit({\n        actorName: newRecord.scientist || newRecord.professionalRole || 'Staff',\n        action: 'DISPATCHED RECORD',\n        targetName: newRecord.fileName,\n        details: \"Dispatched new \".concat(newRecord.unit || 'record', \" for Patient \").concat(newRecord.pathNumber),\n        notes: \"Record ID: \".concat(newRecord.id)\n    });\n    // Internal Dashboard Alert for Doctors/Nurses\n    addNotification({\n        recipientId: 'STAFF',\n        professionalName: 'Doctor',\n        type: 'RECORD_UPDATED',\n        title: 'New Clinical Record',\n        message: \"\".concat(newRecord.scientist || 'Staff', ' dispatched record \"').concat(newRecord.fileName, '\" for Patient ').concat(newRecord.pathNumber, \".\"),\n        details: {\n            patientId: newRecord.pathNumber,\n            fileName: newRecord.fileName\n        }\n    });\n    dispatchSync();\n    return newRecord;\n};\nconst updatePatientVitals = (pathNumber, vitals)=>{\n    if (false) {}\n    const allVitals = JSON.parse(localStorage.getItem(KEYS.VITALS) || '{}');\n    allVitals[pathNumber] = {\n        ...allVitals[pathNumber],\n        ...vitals,\n        lastUpdated: new Date().toISOString()\n    };\n    localStorage.setItem(KEYS.VITALS, JSON.stringify(allVitals));\n    dispatchSync();\n};\nconst sendGlobalMessage = (msg)=>{\n    if (false) {}\n    const messages = JSON.parse(localStorage.getItem(KEYS.MESSAGES) || '[]');\n    const newMsg = {\n        id: \"MSG-\".concat(Date.now()),\n        timestamp: new Date().toISOString(),\n        ...msg\n    };\n    messages.push(newMsg);\n    localStorage.setItem(KEYS.MESSAGES, JSON.stringify(messages));\n    dispatchSync();\n    return newMsg;\n};\nconst deleteGlobalMessage = (id)=>{\n    if (false) {}\n    const messages = JSON.parse(localStorage.getItem(KEYS.MESSAGES) || '[]');\n    const newMessages = messages.filter((msg)=>msg.id !== id);\n    if (messages.length !== newMessages.length) {\n        localStorage.setItem(KEYS.MESSAGES, JSON.stringify(newMessages));\n        dispatchSync();\n        return true;\n    }\n    return false;\n};\nconst getGlobalData = function(key) {\n    let defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n    if (false) {}\n    try {\n        const data = localStorage.getItem(key);\n        return data ? JSON.parse(data) : defaultValue;\n    } catch (e) {\n        console.error(\"Failed to parse global data for key \".concat(key), e);\n        return defaultValue;\n    }\n};\nconst saveAppointment = (appointment)=>{\n    if (false) {}\n    const appointments = JSON.parse(localStorage.getItem(KEYS.APPOINTMENTS) || '[]');\n    const newAppointment = {\n        id: \"APP-\".concat(Date.now()),\n        createdAt: new Date().toISOString(),\n        status: 'Upcoming',\n        ...appointment\n    };\n    appointments.unshift(newAppointment);\n    localStorage.setItem(KEYS.APPOINTMENTS, JSON.stringify(appointments));\n    syncToServer('appointments', 'add', newAppointment);\n    // External Sync & Activity Log\n    (0,_integrations__WEBPACK_IMPORTED_MODULE_0__.syncToExternalSystems)('APPOINTMENT_BOOKED', {\n        appointmentId: newAppointment.id,\n        patientName: newAppointment.patientName,\n        professionalName: newAppointment.professionalName,\n        date: newAppointment.date,\n        time: newAppointment.time\n    });\n    logAudit({\n        actorName: newAppointment.patientName || 'Patient',\n        action: 'BOOKED APPOINTMENT',\n        targetName: \"Session with \".concat(newAppointment.professionalName),\n        details: \"Booked for \".concat(newAppointment.date, \" at \").concat(newAppointment.time),\n        notes: \"Appointment ID: \".concat(newAppointment.id)\n    });\n};\nconst updateAppointmentStatus = (id, updates)=>{\n    if (false) {}\n    const appointments = JSON.parse(localStorage.getItem(KEYS.APPOINTMENTS) || '[]');\n    const appIndex = appointments.findIndex((a)=>a.id === id);\n    if (appIndex !== -1) {\n        // Merge updates\n        appointments[appIndex] = {\n            ...appointments[appIndex],\n            ...updates\n        };\n        // Save\n        localStorage.setItem(KEYS.APPOINTMENTS, JSON.stringify(appointments));\n        dispatchSync();\n        // Check for \"Complete\" Transition Logic\n        // Triggers: ServiceRendered OR Payment\n        checkAppointmentCompletion(id);\n    }\n};\nconst checkAppointmentCompletion = (id)=>{\n    if (false) {}\n    const appointments = JSON.parse(localStorage.getItem(KEYS.APPOINTMENTS) || '[]');\n    const app = appointments.find((a)=>a.id === id);\n    if (app && app.status !== 'Complete' && app.status !== 'Cancelled') {\n        const isPaid = parseFloat(app.amountPaid || 0) >= parseFloat(app.balanceDue || 0);\n        // 'servicesRendered' is a flag set when a consultation/lab result is submitted\n        const isServiceDone = app.servicesRendered === true;\n        if (isPaid && isServiceDone) {\n            app.status = 'Complete';\n            // Save updated status\n            localStorage.setItem(KEYS.APPOINTMENTS, JSON.stringify(appointments));\n            dispatchSync();\n            // Notify\n            addNotification({\n                recipientId: app.patientId,\n                professionalName: app.professionalName,\n                type: 'APPOINTMENT_COMPLETE',\n                title: 'Session Completed',\n                message: \"Your appointment with \".concat(app.professionalName, \" is now marked as Complete. Thank you!\"),\n                details: {\n                    appointmentId: id\n                }\n            });\n        }\n    }\n    // Internal Dashboard Alert for the Professional\n    // Fix: Send to 'scientist' role (like Pharmacist) if category is Scientist\n    const recipientId = app.professionalCategory === 'Scientist' ? 'scientist' : app.professionalId;\n    addNotification({\n        recipientId: recipientId,\n        professionalName: app.professionalName,\n        type: 'APPOINTMENT_BOOKING',\n        title: 'New Appointment Booking',\n        message: \"\".concat(app.patientName, \" booked a \").concat(app.type, \" session for \").concat(app.date, \" at \").concat(app.time, \".\"),\n        details: {\n            patientName: app.patientName,\n            patientId: app.patientId,\n            appointmentType: app.type,\n            date: app.date,\n            time: app.time,\n            amountPaid: app.amountPaid,\n            balanceDue: app.balanceDue\n        }\n    });\n    // Internal Dashboard Alert for the Patient (Payment Confirmation)\n    addNotification({\n        recipientId: app.patientId,\n        professionalName: app.patientName,\n        type: 'APPOINTMENT_CONFIRMED',\n        title: 'Appointment Confirmed & Payment Received',\n        message: \"Your appointment with \".concat(app.professionalName, \" for \").concat(app.date, \" at \").concat(app.time, \" has been successfully booked and payment processed.\"),\n        details: {\n            appointmentId: app.id,\n            patientId: app.patientId,\n            professionalName: app.professionalName,\n            date: app.date,\n            time: app.time,\n            paymentStatus: 'Paid'\n        }\n    });\n    // Payment Confirmation Alert for the Professional (Only if paid)\n    if (app.amountPaid > 0) {\n        addNotification({\n            recipientId: app.professionalId,\n            professionalName: app.professionalName,\n            type: 'PAYMENT_CONFIRMATION',\n            title: 'Payment Confirmed',\n            message: \"Payment of GHS \".concat(app.amountPaid, \" confirmed for \").concat(app.patientName, \"'s appointment on \").concat(app.date, \".\"),\n            details: {\n                patientName: app.patientName,\n                amount: \"GHS \".concat(app.amountPaid)\n            }\n        });\n    }\n    dispatchSync();\n    return app;\n};\nconst updateAppointment = (id, updates)=>{\n    if (false) {}\n    const appointments = JSON.parse(localStorage.getItem(KEYS.APPOINTMENTS) || '[]');\n    const index = appointments.findIndex((a)=>a.id === id);\n    if (index !== -1) {\n        appointments[index] = {\n            ...appointments[index],\n            ...updates\n        };\n        localStorage.setItem(KEYS.APPOINTMENTS, JSON.stringify(appointments));\n        syncToServer('appointments', 'update', null, id, updates);\n        // External Sync & Activity Log if status or payment changed\n        if (updates.status || updates.paymentStatus) {\n            const eventType = updates.paymentStatus === 'Paid' ? 'PAYMENT_RECEIVED' : 'APPOINTMENT_UPDATED';\n            (0,_integrations__WEBPACK_IMPORTED_MODULE_0__.syncToExternalSystems)(eventType, {\n                appointmentId: id,\n                patientName: appointments[index].patientName,\n                status: updates.status || appointments[index].status,\n                paymentStatus: updates.paymentStatus || appointments[index].paymentStatus\n            });\n            logAudit({\n                actorName: updates.updatedBy || 'Staff',\n                action: eventType === 'PAYMENT_RECEIVED' ? 'RECEIVED PAYMENT' : 'UPDATED BOOKING',\n                targetName: \"Appointment \".concat(id),\n                details: eventType === 'PAYMENT_RECEIVED' ? \"Payment confirmed\" : \"Status updated to \".concat(updates.status),\n                notes: \"ID: \".concat(id)\n            });\n            // Alert for the Patient\n            addNotification({\n                recipientId: appointments[index].patientId,\n                professionalName: appointments[index].patientName,\n                type: 'APPOINTMENT_CONFIRMED',\n                title: 'Healthcare Update',\n                message: \"Your appointment status has been updated to: \".concat(updates.status || appointments[index].status, \".\"),\n                details: {\n                    appointmentId: id\n                }\n            });\n        }\n        dispatchSync();\n    }\n};\nconst addNotification = (notification)=>{\n    if (false) {}\n    const notifications = JSON.parse(localStorage.getItem(KEYS.NOTIFICATIONS) || '[]');\n    const newNotif = {\n        id: \"NOTIF-\".concat(Date.now(), \"-\").concat(Math.floor(Math.random() * 1000)),\n        timestamp: new Date().toISOString(),\n        status: 'Unread',\n        ...notification\n    };\n    notifications.unshift(newNotif);\n    localStorage.setItem(KEYS.NOTIFICATIONS, JSON.stringify(notifications));\n    syncToServer('notifications', 'add', newNotif);\n    dispatchSync();\n    return newNotif;\n};\nconst updateNotificationStatus = (id, updates)=>{\n    if (false) {}\n    const notifications = JSON.parse(localStorage.getItem(KEYS.NOTIFICATIONS) || '[]');\n    const index = notifications.findIndex((n)=>n.id === id);\n    if (index !== -1) {\n        notifications[index] = {\n            ...notifications[index],\n            ...updates\n        };\n        localStorage.setItem(KEYS.NOTIFICATIONS, JSON.stringify(notifications));\n        syncToServer('notifications', 'update', null, id, updates);\n        dispatchSync();\n    }\n};\nconst getBookingCount = (professionalName, date)=>{\n    if (false) {}\n    const appointments = JSON.parse(localStorage.getItem(KEYS.APPOINTMENTS) || '[]');\n    // Filter by professional name and date (strip time if stored as full ISO)\n    return appointments.filter((a)=>a.professionalName === professionalName && a.date === date && a.status !== 'Cancelled').length;\n};\nconst logActivity = (activity)=>{\n    if (false) {}\n    const activities = JSON.parse(localStorage.getItem(KEYS.ACTIVITY) || '[]');\n    const newActivity = {\n        id: \"ACT-\".concat(Date.now()),\n        timestamp: new Date().toISOString(),\n        ...activity\n    };\n    activities.unshift(newActivity);\n    // Limit to last 200 activities to avoid localStorage bloat\n    // Limit to last 200 activities to avoid localStorage bloat\n    localStorage.setItem(KEYS.ACTIVITY, JSON.stringify(activities.slice(0, 200)));\n    syncToServer('activity_logs', 'add', newActivity);\n    dispatchSync();\n    return newActivity;\n};\nconst logAudit = (param)=>{\n    let { actorId, actorName, action, targetId, targetName, location = 'System', notes = '' } = param;\n    if (false) {}\n    const auditLogs = JSON.parse(localStorage.getItem(KEYS.AUDIT) || '[]');\n    // Format: DOCTOR_123 viewed PATIENT_456 record at 10:42 UTC\n    // We store structured data but also a human-readable message similar to the requirement\n    const timestamp = new Date().toISOString();\n    const newLog = {\n        id: \"AUDIT-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substr(2, 9)),\n        timestamp,\n        actorId,\n        actorName,\n        action,\n        targetId,\n        targetName,\n        location,\n        notes,\n        formattedLog: \"\".concat(actorName, \" (\").concat(actorId, \") \").concat(action, \" \").concat(targetName, \" (\").concat(targetId, \") at \").concat(timestamp)\n    };\n    auditLogs.unshift(newLog);\n    // Keep a reasonable history, maybe more than activity logs for legal reasons\n    localStorage.setItem(KEYS.AUDIT, JSON.stringify(auditLogs.slice(0, 1000)));\n    syncToServer('audit_logs', 'add', newLog);\n    dispatchSync();\n    return newLog;\n};\nconst updateConfig = (updates)=>{\n    if (false) {}\n    const config = JSON.parse(localStorage.getItem(KEYS.CONFIG) || '{}');\n    const newConfig = {\n        ...config,\n        ...updates\n    };\n    localStorage.setItem(KEYS.CONFIG, JSON.stringify(newConfig));\n    dispatchSync();\n    return newConfig;\n};\nconst savePrescription = (rx)=>{\n    if (false) {}\n    const prescriptions = JSON.parse(localStorage.getItem(KEYS.PRESCRIPTIONS) || '[]');\n    const newRx = {\n        id: \"RX-\".concat(Date.now()),\n        status: 'Active',\n        dateIssued: new Date().toISOString().split('T')[0],\n        ...rx\n    };\n    prescriptions.unshift(newRx);\n    localStorage.setItem(KEYS.PRESCRIPTIONS, JSON.stringify(prescriptions));\n    syncToServer('prescriptions', 'add', newRx);\n    logAudit({\n        actorName: rx.doctorName || 'Doctor',\n        action: 'ISSUED PRESCRIPTION',\n        targetName: rx.drug,\n        details: \"Prescribed \".concat(rx.dosage, \" for \").concat(rx.patientName),\n        notes: \"RX ID: \".concat(newRx.id)\n    });\n    addNotification({\n        recipientId: 'PHARMACIST',\n        professionalName: 'Pharmacist',\n        type: 'PRESCRIPTION_ISSUED',\n        title: 'New Prescription Entry',\n        message: \"New manual entry for \".concat(rx.patientName, \": \").concat(rx.drug),\n        details: {\n            rxId: newRx.id\n        }\n    });\n    dispatchSync();\n    return newRx;\n};\nconst getConfig = (key, defaultValue)=>{\n    if (false) {}\n    const config = JSON.parse(localStorage.getItem(KEYS.CONFIG) || '{}');\n    var _config_key;\n    return key ? (_config_key = config[key]) !== null && _config_key !== void 0 ? _config_key : defaultValue : config;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q1I2QixZQUFZUCxHQUFHeUksSUFBSTtRQUNuQmpJLFNBQVMsY0FBK0JSLE9BQWpCQSxHQUFHMEksTUFBTSxFQUFDLFNBQXNCLE9BQWYxSSxHQUFHd0IsV0FBVztRQUN0RGYsT0FBTyxVQUFtQixPQUFUNEgsTUFBTXpKLEVBQUU7SUFDN0I7SUFFQThCLGdCQUFnQjtRQUNaQyxhQUFhO1FBQ2JDLGtCQUFrQjtRQUNsQkMsTUFBTTtRQUNOQyxPQUFPO1FBQ1BDLFNBQVMsd0JBQTJDZixPQUFuQkEsR0FBR3dCLFdBQVcsRUFBQyxNQUFZLE9BQVJ4QixHQUFHeUksSUFBSTtRQUMzRGpJLFNBQVM7WUFBRWhCLE1BQU02SSxNQUFNekosRUFBRTtRQUFDO0lBQzlCO0lBRUFvQztJQUNBLE9BQU9xSDtBQUNYLEVBQUU7QUFFSyxNQUFNTSxZQUFZLENBQUN4RCxLQUFLQztJQUMzQixJQUFJLEtBQTZCLEVBQUUsRUFBb0JBO0lBQ3ZELE1BQU04QyxTQUFTaEosS0FBS1EsS0FBSyxDQUFDQyxhQUFhQyxPQUFPLENBQUNqQyxLQUFLVSxNQUFNLEtBQUs7UUFDakQ2SjtJQUFkLE9BQU8vQyxNQUFPK0MsQ0FBQUEsY0FBQUEsTUFBTSxDQUFDL0MsSUFBSSxjQUFYK0MseUJBQUFBLGNBQWU5QyxlQUFnQjhDO0FBQ2pELEVBQUUiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xca2ZyeXRcXC5nZW1pbmlcXGFudGlncmF2aXR5XFxzY3JhdGNoXFxkcl9rYWxzX3ZpcnR1YWxfaG9zcGl0YWxcXGZyb250ZW5kXFxsaWJcXGdsb2JhbF9zeW5jLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xyXG5pbXBvcnQgeyBzeW5jVG9FeHRlcm5hbFN5c3RlbXMgfSBmcm9tICcuL2ludGVncmF0aW9ucyc7XHJcbmltcG9ydCB7IGdldFNvY2tldCB9IGZyb20gJy4vc29ja2V0JztcclxuXHJcbi8vIEtleXMgZm9yIExvY2FsU3RvcmFnZVxyXG5leHBvcnQgY29uc3QgS0VZUyA9IHtcclxuICAgIFJFQ09SRFM6ICdkcl9rYWxfZ2xvYmFsX3JlY29yZHMnLFxyXG4gICAgUFJFU0NSSVBUSU9OUzogJ2RyX2thbF9wcmVzY3JpcHRpb25zJyxcclxuICAgIFZJVEFMUzogJ2RyX2thbF92aXRhbHMnLFxyXG4gICAgTUVTU0FHRVM6ICdkcl9rYWxfbWVzc2FnZXMnLFxyXG4gICAgVEFTS1M6ICdkcl9rYWxfdGFza3MnLFxyXG4gICAgUEFUSUVOVF9QUk9GSUxFUzogJ2RyX2thbF9wYXRpZW50X3Byb2ZpbGVzJyxcclxuICAgIEFQUE9JTlRNRU5UUzogJ2RyX2thbF9hcHBvaW50bWVudHMnLFxyXG4gICAgTk9USUZJQ0FUSU9OUzogJ2RyX2thbF9ub3RpZmljYXRpb25zJyxcclxuICAgIEFDVElWSVRZOiAnZHJfa2FsX2FjdGl2aXR5JyxcclxuICAgIENPTkZJRzogJ2RyX2thbF9jb25maWcnLFxyXG4gICAgRU1BSUxfTE9HUzogJ2RyX2thbF9lbWFpbF9sb2dzJyxcclxuICAgIEFVRElUOiAnZHJfa2FsX2F1ZGl0X2xvZ3MnXHJcbn07XHJcblxyXG4vLyBIZWxwZXIgdG8gcHVzaCBjaGFuZ2VzIHRvIFNlcnZlciBEQlxyXG5jb25zdCBzeW5jVG9TZXJ2ZXIgPSBhc3luYyAoY29sbGVjdGlvbiwgYWN0aW9uLCBpdGVtLCBpZCwgdXBkYXRlcykgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBhd2FpdCBmZXRjaCgnL2FwaS9kYicsIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxyXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGNvbGxlY3Rpb24sIGFjdGlvbiwgaXRlbSwgaWQsIHVwZGF0ZXMgfSlcclxuICAgICAgICB9KTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiU2VydmVyIFdyaXRlIEZhaWxlZFwiLCBlKTtcclxuICAgIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB1cGRhdGVQcmVzY3JpcHRpb24gPSAocnhJZCwgdXBkYXRlcykgPT4ge1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XHJcbiAgICBjb25zdCBwcmVzY3JpcHRpb25zID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShLRVlTLlBSRVNDUklQVElPTlMpIHx8ICdbXScpO1xyXG4gICAgbGV0IHVwZGF0ZWRSeCA9IG51bGw7XHJcbiAgICBjb25zdCB1cGRhdGVkID0gcHJlc2NyaXB0aW9ucy5tYXAocnggPT4ge1xyXG4gICAgICAgIGlmIChyeC5pZCA9PT0gcnhJZCkge1xyXG4gICAgICAgICAgICB1cGRhdGVkUnggPSB7IC4uLnJ4LCAuLi51cGRhdGVzIH07XHJcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVkUng7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByeDtcclxuICAgIH0pO1xyXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oS0VZUy5QUkVTQ1JJUFRJT05TLCBKU09OLnN0cmluZ2lmeSh1cGRhdGVkKSk7XHJcblxyXG4gICAgaWYgKHVwZGF0ZWRSeCAmJiB1cGRhdGVzLnN0YXR1cykge1xyXG4gICAgICAgIC8vIEV4dGVybmFsIFN5bmMgJiBBY3Rpdml0eSBMb2dcclxuICAgICAgICBzeW5jVG9FeHRlcm5hbFN5c3RlbXMoJ1BSRVNDUklQVElPTl9VUERBVEVEJywge1xyXG4gICAgICAgICAgICByeElkLFxyXG4gICAgICAgICAgICBzdGF0dXM6IHVwZGF0ZXMuc3RhdHVzLFxyXG4gICAgICAgICAgICBwYXRpZW50SWQ6IHVwZGF0ZWRSeC5wYXRpZW50SWRcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbG9nQXVkaXQoe1xyXG4gICAgICAgICAgICBhY3Rvck5hbWU6IHVwZGF0ZXMudXBkYXRlZEJ5IHx8ICdTdGFmZicsXHJcbiAgICAgICAgICAgIGFjdGlvbjogJ0RJU1BBVENIRUQgUFJFU0NSSVBUSU9OJyxcclxuICAgICAgICAgICAgdGFyZ2V0TmFtZTogYFByZXNjcmlwdGlvbiAjJHtyeElkfWAsXHJcbiAgICAgICAgICAgIGRldGFpbHM6IGBVcGRhdGVkIHN0YXR1cyB0byBcIiR7dXBkYXRlcy5zdGF0dXN9XCJgLFxyXG4gICAgICAgICAgICBub3RlczogSlNPTi5zdHJpbmdpZnkoeyByeElkLCBzdGF0dXM6IHVwZGF0ZXMuc3RhdHVzIH0pXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIEludGVybmFsIEFsZXJ0IGZvciBEb2N0b3JzXHJcbiAgICAgICAgYWRkTm90aWZpY2F0aW9uKHtcclxuICAgICAgICAgICAgcmVjaXBpZW50SWQ6ICdET0NUT1InLFxyXG4gICAgICAgICAgICBwcm9mZXNzaW9uYWxOYW1lOiAnRG9jdG9yJyxcclxuICAgICAgICAgICAgdHlwZTogJ1BSRVNDUklQVElPTl9VUERBVEVEJyxcclxuICAgICAgICAgICAgdGl0bGU6ICdQcmVzY3JpcHRpb24gU3RhdHVzIFVwZGF0ZWQnLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiBgUGhhcm1hY2lzdCAke3VwZGF0ZXMudXBkYXRlZEJ5IHx8ICdTdGFmZid9IHVwZGF0ZWQgc3RhdHVzIG9mIFJYLSR7cnhJZH0gdG8gXCIke3VwZGF0ZXMuc3RhdHVzfVwiLmAsXHJcbiAgICAgICAgICAgIGRldGFpbHM6IHsgcnhJZCwgc3RhdHVzOiB1cGRhdGVzLnN0YXR1cywgcGF0aWVudElkOiB1cGRhdGVkUngucGF0aWVudElkIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBkaXNwYXRjaFN5bmMoKTtcclxuICAgIHJldHVybiB1cGRhdGVkUng7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZGVsZXRlQXBwb2ludG1lbnQgPSAoaWQpID0+IHtcclxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xyXG4gICAgY29uc3QgYXBwb2ludG1lbnRzID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShLRVlTLkFQUE9JTlRNRU5UUykgfHwgJ1tdJyk7XHJcbiAgICBjb25zdCBhcHBvaW50bWVudFRvRGVsZXRlID0gYXBwb2ludG1lbnRzLmZpbmQoYSA9PiBhLmlkID09PSBpZCk7XHJcblxyXG4gICAgaWYgKGFwcG9pbnRtZW50VG9EZWxldGUpIHtcclxuICAgICAgICBjb25zdCBmaWx0ZXJlZEFwcG9pbnRtZW50cyA9IGFwcG9pbnRtZW50cy5maWx0ZXIoYSA9PiBhLmlkICE9PSBpZCk7XHJcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oS0VZUy5BUFBPSU5UTUVOVFMsIEpTT04uc3RyaW5naWZ5KGZpbHRlcmVkQXBwb2ludG1lbnRzKSk7XHJcbiAgICAgICAgc3luY1RvU2VydmVyKCdhcHBvaW50bWVudHMnLCAnZGVsZXRlJywgbnVsbCwgaWQpO1xyXG5cclxuICAgICAgICBsb2dBdWRpdCh7XHJcbiAgICAgICAgICAgIGFjdG9yTmFtZTogYXBwb2ludG1lbnRUb0RlbGV0ZS5wYXRpZW50TmFtZSB8fCAnUGF0aWVudCcsXHJcbiAgICAgICAgICAgIGFjdGlvbjogJ0NBTkNFTExFRCBBUFBPSU5UTUVOVCcsXHJcbiAgICAgICAgICAgIHRhcmdldE5hbWU6IGBTZXNzaW9uIHdpdGggJHthcHBvaW50bWVudFRvRGVsZXRlLnByb2Zlc3Npb25hbE5hbWV9YCxcclxuICAgICAgICAgICAgZGV0YWlsczogYENhbmNlbGxlZCBhcHBvaW50bWVudCBvbiAke2FwcG9pbnRtZW50VG9EZWxldGUuZGF0ZX1gLFxyXG4gICAgICAgICAgICBub3RlczogYEFwcG9pbnRtZW50IElEOiAke2lkfWBcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gTm90aWZ5IFByb2Zlc3Npb25hbCBvZiBDYW5jZWxsYXRpb25cclxuICAgICAgICBhZGROb3RpZmljYXRpb24oe1xyXG4gICAgICAgICAgICByZWNpcGllbnRJZDogYXBwb2ludG1lbnRUb0RlbGV0ZS5wcm9mZXNzaW9uYWxJZCxcclxuICAgICAgICAgICAgcHJvZmVzc2lvbmFsTmFtZTogYXBwb2ludG1lbnRUb0RlbGV0ZS5wcm9mZXNzaW9uYWxOYW1lLFxyXG4gICAgICAgICAgICB0eXBlOiAnQVBQT0lOVE1FTlRfQ0FOQ0VMTEVEJyxcclxuICAgICAgICAgICAgdGl0bGU6ICdBcHBvaW50bWVudCBDYW5jZWxsZWQnLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiBgJHthcHBvaW50bWVudFRvRGVsZXRlLnBhdGllbnROYW1lfSBoYXMgY2FuY2VsbGVkIHRoZWlyIGFwcG9pbnRtZW50IGZvciAke2FwcG9pbnRtZW50VG9EZWxldGUuZGF0ZX0gYXQgJHthcHBvaW50bWVudFRvRGVsZXRlLnRpbWV9LmAsXHJcbiAgICAgICAgICAgIGRldGFpbHM6IHtcclxuICAgICAgICAgICAgICAgIHBhdGllbnROYW1lOiBhcHBvaW50bWVudFRvRGVsZXRlLnBhdGllbnROYW1lLFxyXG4gICAgICAgICAgICAgICAgZGF0ZTogYXBwb2ludG1lbnRUb0RlbGV0ZS5kYXRlLFxyXG4gICAgICAgICAgICAgICAgdGltZTogYXBwb2ludG1lbnRUb0RlbGV0ZS50aW1lXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZGlzcGF0Y2hTeW5jKCk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG5cclxuXHJcbmV4cG9ydCBjb25zdCBzYXZlUGF0aWVudFByb2ZpbGUgPSAodXNlcklkLCBwcm9maWxlRGF0YSkgPT4ge1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XHJcbiAgICBsZXQgcHJvZmlsZXMgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKEtFWVMuUEFUSUVOVF9QUk9GSUxFUykgfHwgJ1tdJyk7XHJcblxyXG4gICAgLy8gTWlncmF0aW9uOiBJZiBsZWdhY3kgb2JqZWN0IGZvcm1hdCwgY29udmVydCB0byBhcnJheVxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHByb2ZpbGVzKSkge1xyXG4gICAgICAgIHByb2ZpbGVzID0gT2JqZWN0LnZhbHVlcyhwcm9maWxlcyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaW5kZXggPSBwcm9maWxlcy5maW5kSW5kZXgocCA9PiBwLnVzZXJJZCA9PT0gdXNlcklkKTtcclxuXHJcbiAgICBjb25zdCBuZXdQcm9maWxlID0ge1xyXG4gICAgICAgIHVzZXJJZCxcclxuICAgICAgICAuLi5wcm9maWxlRGF0YSxcclxuICAgICAgICBsYXN0VXBkYXRlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICBwcm9maWxlc1tpbmRleF0gPSB7IC4uLnByb2ZpbGVzW2luZGV4XSwgLi4ubmV3UHJvZmlsZSB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBwcm9maWxlcy5wdXNoKG5ld1Byb2ZpbGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKEtFWVMuUEFUSUVOVF9QUk9GSUxFUywgSlNPTi5zdHJpbmdpZnkocHJvZmlsZXMpKTtcclxuICAgIHN5bmNUb1NlcnZlcigncGF0aWVudF9wcm9maWxlcycsICdzYXZlJywgbmV3UHJvZmlsZSwgdXNlcklkKTtcclxuXHJcbiAgICBsb2dBdWRpdCh7XHJcbiAgICAgICAgYWN0b3JOYW1lOiAnU3lzdGVtL1VzZXInLFxyXG4gICAgICAgIGFjdGlvbjogJ1VQREFURUQgUFJPRklMRScsXHJcbiAgICAgICAgdGFyZ2V0TmFtZTogYFBhdGllbnQgUHJvZmlsZSAke3VzZXJJZH1gLFxyXG4gICAgICAgIGRldGFpbHM6ICdVcGRhdGVkIHBlcnNvbmFsIG9yIG1lZGljYWwgZGV0YWlscycsXHJcbiAgICAgICAgbm90ZXM6IGBQcm9maWxlIFVwZGF0ZSBmb3IgJHt1c2VySWR9YFxyXG4gICAgfSk7XHJcblxyXG4gICAgZGlzcGF0Y2hTeW5jKCk7XHJcbn07XHJcblxyXG4vLyBDdXN0b20gRXZlbnQgZm9yIGNyb3NzLWNvbXBvbmVudCBzeW5jXHJcbmV4cG9ydCBjb25zdCBTWU5DX0VWRU5UID0gJ2RyX2thbF9zeW5jJztcclxuXHJcbmV4cG9ydCBjb25zdCBkaXNwYXRjaFN5bmMgPSAoKSA9PiB7XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoU1lOQ19FVkVOVCkpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHNhdmVHbG9iYWxSZWNvcmQgPSBhc3luYyAocmVjb3JkKSA9PiB7XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcclxuICAgIGNvbnN0IHJlY29yZHMgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKEtFWVMuUkVDT1JEUykgfHwgJ1tdJyk7XHJcbiAgICBjb25zdCBuZXdSZWNvcmQgPSB7XHJcbiAgICAgICAgaWQ6IGBSRUMtJHtEYXRlLm5vdygpfWAsXHJcbiAgICAgICAgZGF0ZTogbmV3IERhdGUoKS50b0xvY2FsZURhdGVTdHJpbmcoKSxcclxuICAgICAgICB0aW1lOiBuZXcgRGF0ZSgpLnRvTG9jYWxlVGltZVN0cmluZyhbXSwgeyBob3VyOiAnMi1kaWdpdCcsIG1pbnV0ZTogJzItZGlnaXQnIH0pLFxyXG4gICAgICAgIC4uLnJlY29yZFxyXG4gICAgfTtcclxuICAgIHJlY29yZHMudW5zaGlmdChuZXdSZWNvcmQpO1xyXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oS0VZUy5SRUNPUkRTLCBKU09OLnN0cmluZ2lmeShyZWNvcmRzKSk7XHJcblxyXG4gICAgLy8gUGVyc2lzdCB0byBTZXJ2ZXIgRGF0YWJhc2VcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goJy9hcGkvcmVjb3JkcycsIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgICAgICAgIHBhdGllbnRJZDogbmV3UmVjb3JkLnBhdGhOdW1iZXIsIC8vIE1hcHBpbmcgcGF0aE51bWJlciB0byBwYXRpZW50SWRcclxuICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBuZXdSZWNvcmQuZmlsZU5hbWUsXHJcbiAgICAgICAgICAgICAgICB1bml0OiBuZXdSZWNvcmQudW5pdCxcclxuICAgICAgICAgICAgICAgIHByb2Zlc3Npb25hbFJvbGU6IG5ld1JlY29yZC5wcm9mZXNzaW9uYWxSb2xlIHx8ICdTQ0lFTlRJU1QnLCAvLyBEZWZhdWx0IGlmIG1pc3NpbmdcclxuICAgICAgICAgICAgICAgIHN0cnVjdHVyZWRSZXN1bHRzOiBuZXdSZWNvcmQuc3RydWN0dXJlZFJlc3VsdHNcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKCFyZXMub2spIHtcclxuICAgICAgICAgICAgY29uc3QgZXJyRGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJEYXRhLmVycm9yIHx8ICdGYWlsZWQgdG8gc3luYyByZWNvcmQgdG8gREInKTtcclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHN5bmMgcmVjb3JkIHRvIERCXCIsIGVycik7XHJcbiAgICAgICAgdGhyb3cgZXJyOyAvLyBSZS10aHJvdyBzbyBjYWxsZXIgY2FuIGhhbmRsZSBpdFxyXG4gICAgfVxyXG5cclxuICAgIC8vIEV4dGVybmFsIFN5bmMgJiBBY3Rpdml0eSBMb2dcclxuICAgIHN5bmNUb0V4dGVybmFsU3lzdGVtcygnUkVDT1JEX1VQREFURUQnLCB7XHJcbiAgICAgICAgcmVjb3JkSWQ6IG5ld1JlY29yZC5pZCxcclxuICAgICAgICBwYXRpZW50SWQ6IG5ld1JlY29yZC5wYXRoTnVtYmVyLFxyXG4gICAgICAgIHByb2Zlc3Npb25hbFJvbGU6IG5ld1JlY29yZC5wcm9mZXNzaW9uYWxSb2xlLFxyXG4gICAgICAgIGZpbGVOYW1lOiBuZXdSZWNvcmQuZmlsZU5hbWVcclxuICAgIH0pO1xyXG5cclxuICAgIGxvZ0F1ZGl0KHtcclxuICAgICAgICBhY3Rvck5hbWU6IG5ld1JlY29yZC5zY2llbnRpc3QgfHwgbmV3UmVjb3JkLnByb2Zlc3Npb25hbFJvbGUgfHwgJ1N0YWZmJyxcclxuICAgICAgICBhY3Rpb246ICdESVNQQVRDSEVEIFJFQ09SRCcsXHJcbiAgICAgICAgdGFyZ2V0TmFtZTogbmV3UmVjb3JkLmZpbGVOYW1lLFxyXG4gICAgICAgIGRldGFpbHM6IGBEaXNwYXRjaGVkIG5ldyAke25ld1JlY29yZC51bml0IHx8ICdyZWNvcmQnfSBmb3IgUGF0aWVudCAke25ld1JlY29yZC5wYXRoTnVtYmVyfWAsXHJcbiAgICAgICAgbm90ZXM6IGBSZWNvcmQgSUQ6ICR7bmV3UmVjb3JkLmlkfWBcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEludGVybmFsIERhc2hib2FyZCBBbGVydCBmb3IgRG9jdG9ycy9OdXJzZXNcclxuICAgIGFkZE5vdGlmaWNhdGlvbih7XHJcbiAgICAgICAgcmVjaXBpZW50SWQ6ICdTVEFGRicsXHJcbiAgICAgICAgcHJvZmVzc2lvbmFsTmFtZTogJ0RvY3RvcicsIC8vIERlZmF1bHRpbmcgdG8gRG9jdG9yIGZvciB0aGUgZGVtb1xyXG4gICAgICAgIHR5cGU6ICdSRUNPUkRfVVBEQVRFRCcsXHJcbiAgICAgICAgdGl0bGU6ICdOZXcgQ2xpbmljYWwgUmVjb3JkJyxcclxuICAgICAgICBtZXNzYWdlOiBgJHtuZXdSZWNvcmQuc2NpZW50aXN0IHx8ICdTdGFmZid9IGRpc3BhdGNoZWQgcmVjb3JkIFwiJHtuZXdSZWNvcmQuZmlsZU5hbWV9XCIgZm9yIFBhdGllbnQgJHtuZXdSZWNvcmQucGF0aE51bWJlcn0uYCxcclxuICAgICAgICBkZXRhaWxzOiB7XHJcbiAgICAgICAgICAgIHBhdGllbnRJZDogbmV3UmVjb3JkLnBhdGhOdW1iZXIsXHJcbiAgICAgICAgICAgIGZpbGVOYW1lOiBuZXdSZWNvcmQuZmlsZU5hbWVcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBkaXNwYXRjaFN5bmMoKTtcclxuICAgIHJldHVybiBuZXdSZWNvcmQ7XHJcbn07XHJcblxyXG5cclxuXHJcbmV4cG9ydCBjb25zdCB1cGRhdGVQYXRpZW50Vml0YWxzID0gKHBhdGhOdW1iZXIsIHZpdGFscykgPT4ge1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XHJcbiAgICBjb25zdCBhbGxWaXRhbHMgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKEtFWVMuVklUQUxTKSB8fCAne30nKTtcclxuICAgIGFsbFZpdGFsc1twYXRoTnVtYmVyXSA9IHtcclxuICAgICAgICAuLi5hbGxWaXRhbHNbcGF0aE51bWJlcl0sXHJcbiAgICAgICAgLi4udml0YWxzLFxyXG4gICAgICAgIGxhc3RVcGRhdGVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgIH07XHJcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShLRVlTLlZJVEFMUywgSlNPTi5zdHJpbmdpZnkoYWxsVml0YWxzKSk7XHJcbiAgICBkaXNwYXRjaFN5bmMoKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBzZW5kR2xvYmFsTWVzc2FnZSA9IChtc2cpID0+IHtcclxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xyXG4gICAgY29uc3QgbWVzc2FnZXMgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKEtFWVMuTUVTU0FHRVMpIHx8ICdbXScpO1xyXG4gICAgY29uc3QgbmV3TXNnID0ge1xyXG4gICAgICAgIGlkOiBgTVNHLSR7RGF0ZS5ub3coKX1gLFxyXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgIC4uLm1zZ1xyXG4gICAgfTtcclxuICAgIG1lc3NhZ2VzLnB1c2gobmV3TXNnKTtcclxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKEtFWVMuTUVTU0FHRVMsIEpTT04uc3RyaW5naWZ5KG1lc3NhZ2VzKSk7XHJcbiAgICBkaXNwYXRjaFN5bmMoKTtcclxuICAgIHJldHVybiBuZXdNc2c7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZGVsZXRlR2xvYmFsTWVzc2FnZSA9IChpZCkgPT4ge1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XHJcbiAgICBjb25zdCBtZXNzYWdlcyA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oS0VZUy5NRVNTQUdFUykgfHwgJ1tdJyk7XHJcbiAgICBjb25zdCBuZXdNZXNzYWdlcyA9IG1lc3NhZ2VzLmZpbHRlcihtc2cgPT4gbXNnLmlkICE9PSBpZCk7XHJcblxyXG4gICAgaWYgKG1lc3NhZ2VzLmxlbmd0aCAhPT0gbmV3TWVzc2FnZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oS0VZUy5NRVNTQUdFUywgSlNPTi5zdHJpbmdpZnkobmV3TWVzc2FnZXMpKTtcclxuICAgICAgICBkaXNwYXRjaFN5bmMoKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRHbG9iYWxEYXRhID0gKGtleSwgZGVmYXVsdFZhbHVlID0gW10pID0+IHtcclxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XHJcbiAgICAgICAgcmV0dXJuIGRhdGEgPyBKU09OLnBhcnNlKGRhdGEpIDogZGVmYXVsdFZhbHVlO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBwYXJzZSBnbG9iYWwgZGF0YSBmb3Iga2V5ICR7a2V5fWAsIGUpO1xyXG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XHJcbiAgICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3Qgc2F2ZUFwcG9pbnRtZW50ID0gKGFwcG9pbnRtZW50KSA9PiB7XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcclxuICAgIGNvbnN0IGFwcG9pbnRtZW50cyA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oS0VZUy5BUFBPSU5UTUVOVFMpIHx8ICdbXScpO1xyXG4gICAgY29uc3QgbmV3QXBwb2ludG1lbnQgPSB7XHJcbiAgICAgICAgaWQ6IGBBUFAtJHtEYXRlLm5vdygpfWAsXHJcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgc3RhdHVzOiAnVXBjb21pbmcnLFxyXG4gICAgICAgIC4uLmFwcG9pbnRtZW50XHJcbiAgICB9O1xyXG4gICAgYXBwb2ludG1lbnRzLnVuc2hpZnQobmV3QXBwb2ludG1lbnQpO1xyXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oS0VZUy5BUFBPSU5UTUVOVFMsIEpTT04uc3RyaW5naWZ5KGFwcG9pbnRtZW50cykpO1xyXG4gICAgc3luY1RvU2VydmVyKCdhcHBvaW50bWVudHMnLCAnYWRkJywgbmV3QXBwb2ludG1lbnQpO1xyXG5cclxuICAgIC8vIEV4dGVybmFsIFN5bmMgJiBBY3Rpdml0eSBMb2dcclxuICAgIHN5bmNUb0V4dGVybmFsU3lzdGVtcygnQVBQT0lOVE1FTlRfQk9PS0VEJywge1xyXG4gICAgICAgIGFwcG9pbnRtZW50SWQ6IG5ld0FwcG9pbnRtZW50LmlkLFxyXG4gICAgICAgIHBhdGllbnROYW1lOiBuZXdBcHBvaW50bWVudC5wYXRpZW50TmFtZSxcclxuICAgICAgICBwcm9mZXNzaW9uYWxOYW1lOiBuZXdBcHBvaW50bWVudC5wcm9mZXNzaW9uYWxOYW1lLFxyXG4gICAgICAgIGRhdGU6IG5ld0FwcG9pbnRtZW50LmRhdGUsXHJcbiAgICAgICAgdGltZTogbmV3QXBwb2ludG1lbnQudGltZVxyXG4gICAgfSk7XHJcblxyXG4gICAgbG9nQXVkaXQoe1xyXG4gICAgICAgIGFjdG9yTmFtZTogbmV3QXBwb2ludG1lbnQucGF0aWVudE5hbWUgfHwgJ1BhdGllbnQnLFxyXG4gICAgICAgIGFjdGlvbjogJ0JPT0tFRCBBUFBPSU5UTUVOVCcsXHJcbiAgICAgICAgdGFyZ2V0TmFtZTogYFNlc3Npb24gd2l0aCAke25ld0FwcG9pbnRtZW50LnByb2Zlc3Npb25hbE5hbWV9YCxcclxuICAgICAgICBkZXRhaWxzOiBgQm9va2VkIGZvciAke25ld0FwcG9pbnRtZW50LmRhdGV9IGF0ICR7bmV3QXBwb2ludG1lbnQudGltZX1gLFxyXG4gICAgICAgIG5vdGVzOiBgQXBwb2ludG1lbnQgSUQ6ICR7bmV3QXBwb2ludG1lbnQuaWR9YFxyXG4gICAgfSk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgdXBkYXRlQXBwb2ludG1lbnRTdGF0dXMgPSAoaWQsIHVwZGF0ZXMpID0+IHtcclxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xyXG4gICAgY29uc3QgYXBwb2ludG1lbnRzID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShLRVlTLkFQUE9JTlRNRU5UUykgfHwgJ1tdJyk7XHJcbiAgICBjb25zdCBhcHBJbmRleCA9IGFwcG9pbnRtZW50cy5maW5kSW5kZXgoYSA9PiBhLmlkID09PSBpZCk7XHJcblxyXG4gICAgaWYgKGFwcEluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgIC8vIE1lcmdlIHVwZGF0ZXNcclxuICAgICAgICBhcHBvaW50bWVudHNbYXBwSW5kZXhdID0geyAuLi5hcHBvaW50bWVudHNbYXBwSW5kZXhdLCAuLi51cGRhdGVzIH07XHJcblxyXG4gICAgICAgIC8vIFNhdmVcclxuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShLRVlTLkFQUE9JTlRNRU5UUywgSlNPTi5zdHJpbmdpZnkoYXBwb2ludG1lbnRzKSk7XHJcbiAgICAgICAgZGlzcGF0Y2hTeW5jKCk7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGZvciBcIkNvbXBsZXRlXCIgVHJhbnNpdGlvbiBMb2dpY1xyXG4gICAgICAgIC8vIFRyaWdnZXJzOiBTZXJ2aWNlUmVuZGVyZWQgT1IgUGF5bWVudFxyXG4gICAgICAgIGNoZWNrQXBwb2ludG1lbnRDb21wbGV0aW9uKGlkKTtcclxuICAgIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjaGVja0FwcG9pbnRtZW50Q29tcGxldGlvbiA9IChpZCkgPT4ge1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XHJcbiAgICBjb25zdCBhcHBvaW50bWVudHMgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKEtFWVMuQVBQT0lOVE1FTlRTKSB8fCAnW10nKTtcclxuICAgIGNvbnN0IGFwcCA9IGFwcG9pbnRtZW50cy5maW5kKGEgPT4gYS5pZCA9PT0gaWQpO1xyXG5cclxuICAgIGlmIChhcHAgJiYgYXBwLnN0YXR1cyAhPT0gJ0NvbXBsZXRlJyAmJiBhcHAuc3RhdHVzICE9PSAnQ2FuY2VsbGVkJykge1xyXG4gICAgICAgIGNvbnN0IGlzUGFpZCA9IChwYXJzZUZsb2F0KGFwcC5hbW91bnRQYWlkIHx8IDApID49IHBhcnNlRmxvYXQoYXBwLmJhbGFuY2VEdWUgfHwgMCkpO1xyXG4gICAgICAgIC8vICdzZXJ2aWNlc1JlbmRlcmVkJyBpcyBhIGZsYWcgc2V0IHdoZW4gYSBjb25zdWx0YXRpb24vbGFiIHJlc3VsdCBpcyBzdWJtaXR0ZWRcclxuICAgICAgICBjb25zdCBpc1NlcnZpY2VEb25lID0gYXBwLnNlcnZpY2VzUmVuZGVyZWQgPT09IHRydWU7XHJcblxyXG4gICAgICAgIGlmIChpc1BhaWQgJiYgaXNTZXJ2aWNlRG9uZSkge1xyXG4gICAgICAgICAgICBhcHAuc3RhdHVzID0gJ0NvbXBsZXRlJztcclxuICAgICAgICAgICAgLy8gU2F2ZSB1cGRhdGVkIHN0YXR1c1xyXG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShLRVlTLkFQUE9JTlRNRU5UUywgSlNPTi5zdHJpbmdpZnkoYXBwb2ludG1lbnRzKSk7XHJcbiAgICAgICAgICAgIGRpc3BhdGNoU3luYygpO1xyXG5cclxuICAgICAgICAgICAgLy8gTm90aWZ5XHJcbiAgICAgICAgICAgIGFkZE5vdGlmaWNhdGlvbih7XHJcbiAgICAgICAgICAgICAgICByZWNpcGllbnRJZDogYXBwLnBhdGllbnRJZCxcclxuICAgICAgICAgICAgICAgIHByb2Zlc3Npb25hbE5hbWU6IGFwcC5wcm9mZXNzaW9uYWxOYW1lLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogJ0FQUE9JTlRNRU5UX0NPTVBMRVRFJyxcclxuICAgICAgICAgICAgICAgIHRpdGxlOiAnU2Vzc2lvbiBDb21wbGV0ZWQnLFxyXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYFlvdXIgYXBwb2ludG1lbnQgd2l0aCAke2FwcC5wcm9mZXNzaW9uYWxOYW1lfSBpcyBub3cgbWFya2VkIGFzIENvbXBsZXRlLiBUaGFuayB5b3UhYCxcclxuICAgICAgICAgICAgICAgIGRldGFpbHM6IHsgYXBwb2ludG1lbnRJZDogaWQgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSW50ZXJuYWwgRGFzaGJvYXJkIEFsZXJ0IGZvciB0aGUgUHJvZmVzc2lvbmFsXHJcbiAgICAvLyBGaXg6IFNlbmQgdG8gJ3NjaWVudGlzdCcgcm9sZSAobGlrZSBQaGFybWFjaXN0KSBpZiBjYXRlZ29yeSBpcyBTY2llbnRpc3RcclxuICAgIGNvbnN0IHJlY2lwaWVudElkID0gYXBwLnByb2Zlc3Npb25hbENhdGVnb3J5ID09PSAnU2NpZW50aXN0JyA/ICdzY2llbnRpc3QnIDogYXBwLnByb2Zlc3Npb25hbElkO1xyXG5cclxuICAgIGFkZE5vdGlmaWNhdGlvbih7XHJcbiAgICAgICAgcmVjaXBpZW50SWQ6IHJlY2lwaWVudElkLFxyXG4gICAgICAgIHByb2Zlc3Npb25hbE5hbWU6IGFwcC5wcm9mZXNzaW9uYWxOYW1lLFxyXG4gICAgICAgIHR5cGU6ICdBUFBPSU5UTUVOVF9CT09LSU5HJyxcclxuICAgICAgICB0aXRsZTogJ05ldyBBcHBvaW50bWVudCBCb29raW5nJyxcclxuICAgICAgICBtZXNzYWdlOiBgJHthcHAucGF0aWVudE5hbWV9IGJvb2tlZCBhICR7YXBwLnR5cGV9IHNlc3Npb24gZm9yICR7YXBwLmRhdGV9IGF0ICR7YXBwLnRpbWV9LmAsXHJcbiAgICAgICAgZGV0YWlsczoge1xyXG4gICAgICAgICAgICBwYXRpZW50TmFtZTogYXBwLnBhdGllbnROYW1lLFxyXG4gICAgICAgICAgICBwYXRpZW50SWQ6IGFwcC5wYXRpZW50SWQsXHJcbiAgICAgICAgICAgIGFwcG9pbnRtZW50VHlwZTogYXBwLnR5cGUsXHJcbiAgICAgICAgICAgIGRhdGU6IGFwcC5kYXRlLFxyXG4gICAgICAgICAgICB0aW1lOiBhcHAudGltZSxcclxuICAgICAgICAgICAgYW1vdW50UGFpZDogYXBwLmFtb3VudFBhaWQsXHJcbiAgICAgICAgICAgIGJhbGFuY2VEdWU6IGFwcC5iYWxhbmNlRHVlXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gSW50ZXJuYWwgRGFzaGJvYXJkIEFsZXJ0IGZvciB0aGUgUGF0aWVudCAoUGF5bWVudCBDb25maXJtYXRpb24pXHJcbiAgICBhZGROb3RpZmljYXRpb24oe1xyXG4gICAgICAgIHJlY2lwaWVudElkOiBhcHAucGF0aWVudElkLFxyXG4gICAgICAgIHByb2Zlc3Npb25hbE5hbWU6IGFwcC5wYXRpZW50TmFtZSxcclxuICAgICAgICB0eXBlOiAnQVBQT0lOVE1FTlRfQ09ORklSTUVEJyxcclxuICAgICAgICB0aXRsZTogJ0FwcG9pbnRtZW50IENvbmZpcm1lZCAmIFBheW1lbnQgUmVjZWl2ZWQnLFxyXG4gICAgICAgIG1lc3NhZ2U6IGBZb3VyIGFwcG9pbnRtZW50IHdpdGggJHthcHAucHJvZmVzc2lvbmFsTmFtZX0gZm9yICR7YXBwLmRhdGV9IGF0ICR7YXBwLnRpbWV9IGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBib29rZWQgYW5kIHBheW1lbnQgcHJvY2Vzc2VkLmAsXHJcbiAgICAgICAgZGV0YWlsczoge1xyXG4gICAgICAgICAgICBhcHBvaW50bWVudElkOiBhcHAuaWQsXHJcbiAgICAgICAgICAgIHBhdGllbnRJZDogYXBwLnBhdGllbnRJZCxcclxuICAgICAgICAgICAgcHJvZmVzc2lvbmFsTmFtZTogYXBwLnByb2Zlc3Npb25hbE5hbWUsXHJcbiAgICAgICAgICAgIGRhdGU6IGFwcC5kYXRlLFxyXG4gICAgICAgICAgICB0aW1lOiBhcHAudGltZSxcclxuICAgICAgICAgICAgcGF5bWVudFN0YXR1czogJ1BhaWQnXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gUGF5bWVudCBDb25maXJtYXRpb24gQWxlcnQgZm9yIHRoZSBQcm9mZXNzaW9uYWwgKE9ubHkgaWYgcGFpZClcclxuICAgIGlmIChhcHAuYW1vdW50UGFpZCA+IDApIHtcclxuICAgICAgICBhZGROb3RpZmljYXRpb24oe1xyXG4gICAgICAgICAgICByZWNpcGllbnRJZDogYXBwLnByb2Zlc3Npb25hbElkLFxyXG4gICAgICAgICAgICBwcm9mZXNzaW9uYWxOYW1lOiBhcHAucHJvZmVzc2lvbmFsTmFtZSxcclxuICAgICAgICAgICAgdHlwZTogJ1BBWU1FTlRfQ09ORklSTUFUSU9OJyxcclxuICAgICAgICAgICAgdGl0bGU6ICdQYXltZW50IENvbmZpcm1lZCcsXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBQYXltZW50IG9mIEdIUyAke2FwcC5hbW91bnRQYWlkfSBjb25maXJtZWQgZm9yICR7YXBwLnBhdGllbnROYW1lfSdzIGFwcG9pbnRtZW50IG9uICR7YXBwLmRhdGV9LmAsXHJcbiAgICAgICAgICAgIGRldGFpbHM6IHtcclxuICAgICAgICAgICAgICAgIHBhdGllbnROYW1lOiBhcHAucGF0aWVudE5hbWUsXHJcbiAgICAgICAgICAgICAgICBhbW91bnQ6IGBHSFMgJHthcHAuYW1vdW50UGFpZH1gXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBkaXNwYXRjaFN5bmMoKTtcclxuICAgIHJldHVybiBhcHA7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgdXBkYXRlQXBwb2ludG1lbnQgPSAoaWQsIHVwZGF0ZXMpID0+IHtcclxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xyXG4gICAgY29uc3QgYXBwb2ludG1lbnRzID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShLRVlTLkFQUE9JTlRNRU5UUykgfHwgJ1tdJyk7XHJcbiAgICBjb25zdCBpbmRleCA9IGFwcG9pbnRtZW50cy5maW5kSW5kZXgoYSA9PiBhLmlkID09PSBpZCk7XHJcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgYXBwb2ludG1lbnRzW2luZGV4XSA9IHsgLi4uYXBwb2ludG1lbnRzW2luZGV4XSwgLi4udXBkYXRlcyB9O1xyXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKEtFWVMuQVBQT0lOVE1FTlRTLCBKU09OLnN0cmluZ2lmeShhcHBvaW50bWVudHMpKTtcclxuICAgICAgICBzeW5jVG9TZXJ2ZXIoJ2FwcG9pbnRtZW50cycsICd1cGRhdGUnLCBudWxsLCBpZCwgdXBkYXRlcyk7XHJcblxyXG4gICAgICAgIC8vIEV4dGVybmFsIFN5bmMgJiBBY3Rpdml0eSBMb2cgaWYgc3RhdHVzIG9yIHBheW1lbnQgY2hhbmdlZFxyXG4gICAgICAgIGlmICh1cGRhdGVzLnN0YXR1cyB8fCB1cGRhdGVzLnBheW1lbnRTdGF0dXMpIHtcclxuICAgICAgICAgICAgY29uc3QgZXZlbnRUeXBlID0gdXBkYXRlcy5wYXltZW50U3RhdHVzID09PSAnUGFpZCcgPyAnUEFZTUVOVF9SRUNFSVZFRCcgOiAnQVBQT0lOVE1FTlRfVVBEQVRFRCc7XHJcblxyXG4gICAgICAgICAgICBzeW5jVG9FeHRlcm5hbFN5c3RlbXMoZXZlbnRUeXBlLCB7XHJcbiAgICAgICAgICAgICAgICBhcHBvaW50bWVudElkOiBpZCxcclxuICAgICAgICAgICAgICAgIHBhdGllbnROYW1lOiBhcHBvaW50bWVudHNbaW5kZXhdLnBhdGllbnROYW1lLFxyXG4gICAgICAgICAgICAgICAgc3RhdHVzOiB1cGRhdGVzLnN0YXR1cyB8fCBhcHBvaW50bWVudHNbaW5kZXhdLnN0YXR1cyxcclxuICAgICAgICAgICAgICAgIHBheW1lbnRTdGF0dXM6IHVwZGF0ZXMucGF5bWVudFN0YXR1cyB8fCBhcHBvaW50bWVudHNbaW5kZXhdLnBheW1lbnRTdGF0dXNcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBsb2dBdWRpdCh7XHJcbiAgICAgICAgICAgICAgICBhY3Rvck5hbWU6IHVwZGF0ZXMudXBkYXRlZEJ5IHx8ICdTdGFmZicsXHJcbiAgICAgICAgICAgICAgICBhY3Rpb246IGV2ZW50VHlwZSA9PT0gJ1BBWU1FTlRfUkVDRUlWRUQnID8gJ1JFQ0VJVkVEIFBBWU1FTlQnIDogJ1VQREFURUQgQk9PS0lORycsXHJcbiAgICAgICAgICAgICAgICB0YXJnZXROYW1lOiBgQXBwb2ludG1lbnQgJHtpZH1gLFxyXG4gICAgICAgICAgICAgICAgZGV0YWlsczogZXZlbnRUeXBlID09PSAnUEFZTUVOVF9SRUNFSVZFRCcgPyBgUGF5bWVudCBjb25maXJtZWRgIDogYFN0YXR1cyB1cGRhdGVkIHRvICR7dXBkYXRlcy5zdGF0dXN9YCxcclxuICAgICAgICAgICAgICAgIG5vdGVzOiBgSUQ6ICR7aWR9YFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIEFsZXJ0IGZvciB0aGUgUGF0aWVudFxyXG4gICAgICAgICAgICBhZGROb3RpZmljYXRpb24oe1xyXG4gICAgICAgICAgICAgICAgcmVjaXBpZW50SWQ6IGFwcG9pbnRtZW50c1tpbmRleF0ucGF0aWVudElkLFxyXG4gICAgICAgICAgICAgICAgcHJvZmVzc2lvbmFsTmFtZTogYXBwb2ludG1lbnRzW2luZGV4XS5wYXRpZW50TmFtZSwgLy8gUGF0aWVudHMgYWxzbyB1c2UgQWxlcnRzVmlldyBpbiBzb21lIGNvbnRleHRzIG9yIHdlIGNhbiB1c2UgdGhpcyBmb3IgdGhlIGZlZWRcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdBUFBPSU5UTUVOVF9DT05GSVJNRUQnLFxyXG4gICAgICAgICAgICAgICAgdGl0bGU6ICdIZWFsdGhjYXJlIFVwZGF0ZScsXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBgWW91ciBhcHBvaW50bWVudCBzdGF0dXMgaGFzIGJlZW4gdXBkYXRlZCB0bzogJHt1cGRhdGVzLnN0YXR1cyB8fCBhcHBvaW50bWVudHNbaW5kZXhdLnN0YXR1c30uYCxcclxuICAgICAgICAgICAgICAgIGRldGFpbHM6IHsgYXBwb2ludG1lbnRJZDogaWQgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRpc3BhdGNoU3luYygpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGFkZE5vdGlmaWNhdGlvbiA9IChub3RpZmljYXRpb24pID0+IHtcclxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xyXG4gICAgY29uc3Qgbm90aWZpY2F0aW9ucyA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oS0VZUy5OT1RJRklDQVRJT05TKSB8fCAnW10nKTtcclxuICAgIGNvbnN0IG5ld05vdGlmID0ge1xyXG4gICAgICAgIGlkOiBgTk9USUYtJHtEYXRlLm5vdygpfS0ke01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDApfWAsXHJcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgc3RhdHVzOiAnVW5yZWFkJywgLy8gVW5yZWFkLCBSZWFkLCBEaXNtaXNzZWQsIFNub296ZWRcclxuICAgICAgICAuLi5ub3RpZmljYXRpb25cclxuICAgIH07XHJcbiAgICBub3RpZmljYXRpb25zLnVuc2hpZnQobmV3Tm90aWYpO1xyXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oS0VZUy5OT1RJRklDQVRJT05TLCBKU09OLnN0cmluZ2lmeShub3RpZmljYXRpb25zKSk7XHJcblxyXG4gICAgc3luY1RvU2VydmVyKCdub3RpZmljYXRpb25zJywgJ2FkZCcsIG5ld05vdGlmKTtcclxuXHJcbiAgICBkaXNwYXRjaFN5bmMoKTtcclxuICAgIHJldHVybiBuZXdOb3RpZjtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB1cGRhdGVOb3RpZmljYXRpb25TdGF0dXMgPSAoaWQsIHVwZGF0ZXMpID0+IHtcclxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xyXG4gICAgY29uc3Qgbm90aWZpY2F0aW9ucyA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oS0VZUy5OT1RJRklDQVRJT05TKSB8fCAnW10nKTtcclxuICAgIGNvbnN0IGluZGV4ID0gbm90aWZpY2F0aW9ucy5maW5kSW5kZXgobiA9PiBuLmlkID09PSBpZCk7XHJcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgbm90aWZpY2F0aW9uc1tpbmRleF0gPSB7IC4uLm5vdGlmaWNhdGlvbnNbaW5kZXhdLCAuLi51cGRhdGVzIH07XHJcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oS0VZUy5OT1RJRklDQVRJT05TLCBKU09OLnN0cmluZ2lmeShub3RpZmljYXRpb25zKSk7XHJcblxyXG4gICAgICAgIHN5bmNUb1NlcnZlcignbm90aWZpY2F0aW9ucycsICd1cGRhdGUnLCBudWxsLCBpZCwgdXBkYXRlcyk7XHJcblxyXG4gICAgICAgIGRpc3BhdGNoU3luYygpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldEJvb2tpbmdDb3VudCA9IChwcm9mZXNzaW9uYWxOYW1lLCBkYXRlKSA9PiB7XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiAwO1xyXG4gICAgY29uc3QgYXBwb2ludG1lbnRzID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShLRVlTLkFQUE9JTlRNRU5UUykgfHwgJ1tdJyk7XHJcbiAgICAvLyBGaWx0ZXIgYnkgcHJvZmVzc2lvbmFsIG5hbWUgYW5kIGRhdGUgKHN0cmlwIHRpbWUgaWYgc3RvcmVkIGFzIGZ1bGwgSVNPKVxyXG4gICAgcmV0dXJuIGFwcG9pbnRtZW50cy5maWx0ZXIoYSA9PlxyXG4gICAgICAgIGEucHJvZmVzc2lvbmFsTmFtZSA9PT0gcHJvZmVzc2lvbmFsTmFtZSAmJlxyXG4gICAgICAgIGEuZGF0ZSA9PT0gZGF0ZSAmJlxyXG4gICAgICAgIGEuc3RhdHVzICE9PSAnQ2FuY2VsbGVkJ1xyXG4gICAgKS5sZW5ndGg7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgbG9nQWN0aXZpdHkgPSAoYWN0aXZpdHkpID0+IHtcclxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xyXG4gICAgY29uc3QgYWN0aXZpdGllcyA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oS0VZUy5BQ1RJVklUWSkgfHwgJ1tdJyk7XHJcbiAgICBjb25zdCBuZXdBY3Rpdml0eSA9IHtcclxuICAgICAgICBpZDogYEFDVC0ke0RhdGUubm93KCl9YCxcclxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgICAuLi5hY3Rpdml0eVxyXG4gICAgfTtcclxuICAgIGFjdGl2aXRpZXMudW5zaGlmdChuZXdBY3Rpdml0eSk7XHJcbiAgICAvLyBMaW1pdCB0byBsYXN0IDIwMCBhY3Rpdml0aWVzIHRvIGF2b2lkIGxvY2FsU3RvcmFnZSBibG9hdFxyXG4gICAgLy8gTGltaXQgdG8gbGFzdCAyMDAgYWN0aXZpdGllcyB0byBhdm9pZCBsb2NhbFN0b3JhZ2UgYmxvYXRcclxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKEtFWVMuQUNUSVZJVFksIEpTT04uc3RyaW5naWZ5KGFjdGl2aXRpZXMuc2xpY2UoMCwgMjAwKSkpO1xyXG5cclxuICAgIHN5bmNUb1NlcnZlcignYWN0aXZpdHlfbG9ncycsICdhZGQnLCBuZXdBY3Rpdml0eSk7XHJcblxyXG4gICAgZGlzcGF0Y2hTeW5jKCk7XHJcbiAgICByZXR1cm4gbmV3QWN0aXZpdHk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgbG9nQXVkaXQgPSAoeyBhY3RvcklkLCBhY3Rvck5hbWUsIGFjdGlvbiwgdGFyZ2V0SWQsIHRhcmdldE5hbWUsIGxvY2F0aW9uID0gJ1N5c3RlbScsIG5vdGVzID0gJycgfSkgPT4ge1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XHJcbiAgICBjb25zdCBhdWRpdExvZ3MgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKEtFWVMuQVVESVQpIHx8ICdbXScpO1xyXG5cclxuICAgIC8vIEZvcm1hdDogRE9DVE9SXzEyMyB2aWV3ZWQgUEFUSUVOVF80NTYgcmVjb3JkIGF0IDEwOjQyIFVUQ1xyXG4gICAgLy8gV2Ugc3RvcmUgc3RydWN0dXJlZCBkYXRhIGJ1dCBhbHNvIGEgaHVtYW4tcmVhZGFibGUgbWVzc2FnZSBzaW1pbGFyIHRvIHRoZSByZXF1aXJlbWVudFxyXG4gICAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xyXG4gICAgY29uc3QgbmV3TG9nID0ge1xyXG4gICAgICAgIGlkOiBgQVVESVQtJHtEYXRlLm5vdygpfS0ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KX1gLFxyXG4gICAgICAgIHRpbWVzdGFtcCxcclxuICAgICAgICBhY3RvcklkLFxyXG4gICAgICAgIGFjdG9yTmFtZSxcclxuICAgICAgICBhY3Rpb24sXHJcbiAgICAgICAgdGFyZ2V0SWQsXHJcbiAgICAgICAgdGFyZ2V0TmFtZSxcclxuICAgICAgICBsb2NhdGlvbiwgLy8gZS5nLiwgSVAgYWRkcmVzcyBvciBcIk51cnNlRGFzaGJvYXJkXCJcclxuICAgICAgICBub3RlcyxcclxuICAgICAgICBmb3JtYXR0ZWRMb2c6IGAke2FjdG9yTmFtZX0gKCR7YWN0b3JJZH0pICR7YWN0aW9ufSAke3RhcmdldE5hbWV9ICgke3RhcmdldElkfSkgYXQgJHt0aW1lc3RhbXB9YFxyXG4gICAgfTtcclxuXHJcbiAgICBhdWRpdExvZ3MudW5zaGlmdChuZXdMb2cpO1xyXG4gICAgLy8gS2VlcCBhIHJlYXNvbmFibGUgaGlzdG9yeSwgbWF5YmUgbW9yZSB0aGFuIGFjdGl2aXR5IGxvZ3MgZm9yIGxlZ2FsIHJlYXNvbnNcclxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKEtFWVMuQVVESVQsIEpTT04uc3RyaW5naWZ5KGF1ZGl0TG9ncy5zbGljZSgwLCAxMDAwKSkpO1xyXG5cclxuICAgIHN5bmNUb1NlcnZlcignYXVkaXRfbG9ncycsICdhZGQnLCBuZXdMb2cpO1xyXG4gICAgZGlzcGF0Y2hTeW5jKCk7XHJcbiAgICByZXR1cm4gbmV3TG9nO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHVwZGF0ZUNvbmZpZyA9ICh1cGRhdGVzKSA9PiB7XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcclxuICAgIGNvbnN0IGNvbmZpZyA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oS0VZUy5DT05GSUcpIHx8ICd7fScpO1xyXG4gICAgY29uc3QgbmV3Q29uZmlnID0geyAuLi5jb25maWcsIC4uLnVwZGF0ZXMgfTtcclxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKEtFWVMuQ09ORklHLCBKU09OLnN0cmluZ2lmeShuZXdDb25maWcpKTtcclxuICAgIGRpc3BhdGNoU3luYygpO1xyXG4gICAgcmV0dXJuIG5ld0NvbmZpZztcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBzYXZlUHJlc2NyaXB0aW9uID0gKHJ4KSA9PiB7XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcclxuICAgIGNvbnN0IHByZXNjcmlwdGlvbnMgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKEtFWVMuUFJFU0NSSVBUSU9OUykgfHwgJ1tdJyk7XHJcbiAgICBjb25zdCBuZXdSeCA9IHtcclxuICAgICAgICBpZDogYFJYLSR7RGF0ZS5ub3coKX1gLFxyXG4gICAgICAgIHN0YXR1czogJ0FjdGl2ZScsXHJcbiAgICAgICAgZGF0ZUlzc3VlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0sXHJcbiAgICAgICAgLi4ucnhcclxuICAgIH07XHJcbiAgICBwcmVzY3JpcHRpb25zLnVuc2hpZnQobmV3UngpO1xyXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oS0VZUy5QUkVTQ1JJUFRJT05TLCBKU09OLnN0cmluZ2lmeShwcmVzY3JpcHRpb25zKSk7XHJcblxyXG4gICAgc3luY1RvU2VydmVyKCdwcmVzY3JpcHRpb25zJywgJ2FkZCcsIG5ld1J4KTtcclxuXHJcbiAgICBsb2dBdWRpdCh7XHJcbiAgICAgICAgYWN0b3JOYW1lOiByeC5kb2N0b3JOYW1lIHx8ICdEb2N0b3InLFxyXG4gICAgICAgIGFjdGlvbjogJ0lTU1VFRCBQUkVTQ1JJUFRJT04nLFxyXG4gICAgICAgIHRhcmdldE5hbWU6IHJ4LmRydWcsXHJcbiAgICAgICAgZGV0YWlsczogYFByZXNjcmliZWQgJHtyeC5kb3NhZ2V9IGZvciAke3J4LnBhdGllbnROYW1lfWAsXHJcbiAgICAgICAgbm90ZXM6IGBSWCBJRDogJHtuZXdSeC5pZH1gXHJcbiAgICB9KTtcclxuXHJcbiAgICBhZGROb3RpZmljYXRpb24oe1xyXG4gICAgICAgIHJlY2lwaWVudElkOiAnUEhBUk1BQ0lTVCcsXHJcbiAgICAgICAgcHJvZmVzc2lvbmFsTmFtZTogJ1BoYXJtYWNpc3QnLFxyXG4gICAgICAgIHR5cGU6ICdQUkVTQ1JJUFRJT05fSVNTVUVEJyxcclxuICAgICAgICB0aXRsZTogJ05ldyBQcmVzY3JpcHRpb24gRW50cnknLFxyXG4gICAgICAgIG1lc3NhZ2U6IGBOZXcgbWFudWFsIGVudHJ5IGZvciAke3J4LnBhdGllbnROYW1lfTogJHtyeC5kcnVnfWAsXHJcbiAgICAgICAgZGV0YWlsczogeyByeElkOiBuZXdSeC5pZCB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBkaXNwYXRjaFN5bmMoKTtcclxuICAgIHJldHVybiBuZXdSeDtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRDb25maWcgPSAoa2V5LCBkZWZhdWx0VmFsdWUpID0+IHtcclxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcclxuICAgIGNvbnN0IGNvbmZpZyA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oS0VZUy5DT05GSUcpIHx8ICd7fScpO1xyXG4gICAgcmV0dXJuIGtleSA/IChjb25maWdba2V5XSA/PyBkZWZhdWx0VmFsdWUpIDogY29uZmlnO1xyXG59O1xyXG5cclxuXHJcbiJdLCJuYW1lcyI6WyJzeW5jVG9FeHRlcm5hbFN5c3RlbXMiLCJnZXRTb2NrZXQiLCJLRVlTIiwiUkVDT1JEUyIsIlBSRVNDUklQVElPTlMiLCJWSVRBTFMiLCJNRVNTQUdFUyIsIlRBU0tTIiwiUEFUSUVOVF9QUk9GSUxFUyIsIkFQUE9JTlRNRU5UUyIsIk5PVElGSUNBVElPTlMiLCJBQ1RJVklUWSIsIkNPTkZJRyIsIkVNQUlMX0xPR1MiLCJBVURJVCIsInN5bmNUb1NlcnZlciIsImNvbGxlY3Rpb24iLCJhY3Rpb24iLCJpdGVtIiwiaWQiLCJ1cGRhdGVzIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJlIiwiY29uc29sZSIsImVycm9yIiwidXBkYXRlUHJlc2NyaXB0aW9uIiwicnhJZCIsInByZXNjcmlwdGlvbnMiLCJwYXJzZSIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJ1cGRhdGVkUngiLCJ1cGRhdGVkIiwibWFwIiwicngiLCJzZXRJdGVtIiwic3RhdHVzIiwicGF0aWVudElkIiwibG9nQXVkaXQiLCJhY3Rvck5hbWUiLCJ1cGRhdGVkQnkiLCJ0YXJnZXROYW1lIiwiZGV0YWlscyIsIm5vdGVzIiwiYWRkTm90aWZpY2F0aW9uIiwicmVjaXBpZW50SWQiLCJwcm9mZXNzaW9uYWxOYW1lIiwidHlwZSIsInRpdGxlIiwibWVzc2FnZSIsImRpc3BhdGNoU3luYyIsImRlbGV0ZUFwcG9pbnRtZW50IiwiYXBwb2ludG1lbnRzIiwiYXBwb2ludG1lbnRUb0RlbGV0ZSIsImZpbmQiLCJhIiwiZmlsdGVyZWRBcHBvaW50bWVudHMiLCJmaWx0ZXIiLCJwYXRpZW50TmFtZSIsImRhdGUiLCJwcm9mZXNzaW9uYWxJZCIsInRpbWUiLCJzYXZlUGF0aWVudFByb2ZpbGUiLCJ1c2VySWQiLCJwcm9maWxlRGF0YSIsInByb2ZpbGVzIiwiQXJyYXkiLCJpc0FycmF5IiwiT2JqZWN0IiwidmFsdWVzIiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJwIiwibmV3UHJvZmlsZSIsImxhc3RVcGRhdGVkIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwicHVzaCIsIlNZTkNfRVZFTlQiLCJ3aW5kb3ciLCJkaXNwYXRjaEV2ZW50IiwiRXZlbnQiLCJzYXZlR2xvYmFsUmVjb3JkIiwicmVjb3JkIiwicmVjb3JkcyIsIm5ld1JlY29yZCIsIm5vdyIsInRvTG9jYWxlRGF0ZVN0cmluZyIsInRvTG9jYWxlVGltZVN0cmluZyIsImhvdXIiLCJtaW51dGUiLCJ1bnNoaWZ0IiwicmVzIiwicGF0aE51bWJlciIsImZpbGVOYW1lIiwidW5pdCIsInByb2Zlc3Npb25hbFJvbGUiLCJzdHJ1Y3R1cmVkUmVzdWx0cyIsIm9rIiwiZXJyRGF0YSIsImpzb24iLCJFcnJvciIsImVyciIsInJlY29yZElkIiwic2NpZW50aXN0IiwidXBkYXRlUGF0aWVudFZpdGFscyIsInZpdGFscyIsImFsbFZpdGFscyIsInNlbmRHbG9iYWxNZXNzYWdlIiwibXNnIiwibWVzc2FnZXMiLCJuZXdNc2ciLCJ0aW1lc3RhbXAiLCJkZWxldGVHbG9iYWxNZXNzYWdlIiwibmV3TWVzc2FnZXMiLCJsZW5ndGgiLCJnZXRHbG9iYWxEYXRhIiwia2V5IiwiZGVmYXVsdFZhbHVlIiwiZGF0YSIsInNhdmVBcHBvaW50bWVudCIsImFwcG9pbnRtZW50IiwibmV3QXBwb2ludG1lbnQiLCJjcmVhdGVkQXQiLCJhcHBvaW50bWVudElkIiwidXBkYXRlQXBwb2ludG1lbnRTdGF0dXMiLCJhcHBJbmRleCIsImNoZWNrQXBwb2ludG1lbnRDb21wbGV0aW9uIiwiYXBwIiwiaXNQYWlkIiwicGFyc2VGbG9hdCIsImFtb3VudFBhaWQiLCJiYWxhbmNlRHVlIiwiaXNTZXJ2aWNlRG9uZSIsInNlcnZpY2VzUmVuZGVyZWQiLCJwcm9mZXNzaW9uYWxDYXRlZ29yeSIsImFwcG9pbnRtZW50VHlwZSIsInBheW1lbnRTdGF0dXMiLCJhbW91bnQiLCJ1cGRhdGVBcHBvaW50bWVudCIsImV2ZW50VHlwZSIsIm5vdGlmaWNhdGlvbiIsIm5vdGlmaWNhdGlvbnMiLCJuZXdOb3RpZiIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsInVwZGF0ZU5vdGlmaWNhdGlvblN0YXR1cyIsIm4iLCJnZXRCb29raW5nQ291bnQiLCJsb2dBY3Rpdml0eSIsImFjdGl2aXR5IiwiYWN0aXZpdGllcyIsIm5ld0FjdGl2aXR5Iiwic2xpY2UiLCJhY3RvcklkIiwidGFyZ2V0SWQiLCJsb2NhdGlvbiIsImF1ZGl0TG9ncyIsIm5ld0xvZyIsInRvU3RyaW5nIiwic3Vic3RyIiwiZm9ybWF0dGVkTG9nIiwidXBkYXRlQ29uZmlnIiwiY29uZmlnIiwibmV3Q29uZmlnIiwic2F2ZVByZXNjcmlwdGlvbiIsIm5ld1J4IiwiZGF0ZUlzc3VlZCIsInNwbGl0IiwiZG9jdG9yTmFtZSIsImRydWciLCJkb3NhZ2UiLCJnZXRDb25maWciXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/global_sync.js\n"));

/***/ })

});